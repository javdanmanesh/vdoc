<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Vim manual</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Vim manual</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_about_the_manuals">About the manuals</a>
<ul class="sectlevel2">
<li><a href="#_two_manuals">Two manuals</a></li>
<li><a href="#_vim_installed">Vim installed</a></li>
<li><a href="#_using_the_vim_tutor">Using the Vim tutor</a></li>
<li><a href="#_copyright">Copyright</a></li>
</ul>
</li>
<li><a href="#_the_first_steps_in_vim">The first steps in Vim</a>
<ul class="sectlevel2">
<li><a href="#_running_vim_for_the_first_time">Running Vim for the First Time</a></li>
<li><a href="#_inserting_text">Inserting text</a></li>
<li><a href="#_moving_around">Moving around</a></li>
<li><a href="#_deleting_characters">Deleting characters</a></li>
<li><a href="#_undo_and_redo">Undo and Redo</a></li>
<li><a href="#_other_editing_commands">Other editing commands</a></li>
<li><a href="#_getting_out">Getting out</a></li>
<li><a href="#_finding_help">Finding help</a></li>
</ul>
</li>
<li><a href="#_moving_around_2">Moving around</a>
<ul class="sectlevel2">
<li><a href="#_word_movement">Word movement</a></li>
<li><a href="#_moving_to_the_start_or_end_of_a_line">Moving to the start or end of a line</a></li>
<li><a href="#_moving_to_a_character">Moving to a character</a></li>
<li><a href="#_matching_a_parenthesis">Matching a parenthesis</a></li>
<li><a href="#_moving_to_a_specific_line">Moving to a specific line</a></li>
<li><a href="#_telling_where_you_are">Telling where you are</a></li>
<li><a href="#_scrolling_around">Scrolling around</a></li>
<li><a href="#_simple_searches">Simple searches</a></li>
<li><a href="#_simple_search_patterns">Simple search patterns</a></li>
<li><a href="#_using_marks">Using marks</a></li>
</ul>
</li>
<li><a href="#_making_small_changes">Making small changes</a>
<ul class="sectlevel2">
<li><a href="#_operators_and_motions">Operators and motions</a></li>
<li><a href="#_changing_text">Changing text</a></li>
<li><a href="#_repeating_a_change">Repeating a change</a></li>
<li><a href="#_visual_mode">Visual mode</a></li>
<li><a href="#_moving_text">Moving text</a></li>
<li><a href="#_copying_text">Copying text</a></li>
<li><a href="#_using_the_clipboard">Using the clipboard</a></li>
<li><a href="#_text_objects">Text objects</a></li>
<li><a href="#_replace_mode">Replace mode</a></li>
<li><a href="#_conclusion">Conclusion</a></li>
</ul>
</li>
<li><a href="#_set_your_settings">Set your settings</a>
<ul class="sectlevel2">
<li><a href="#_the_vimrc_file">The vimrc file</a></li>
<li><a href="#_the_example_vimrc_file_explained">The example vimrc file explained</a></li>
<li><a href="#_the_defaults_vim_file_explained">The defaults.vim file explained</a></li>
<li><a href="#_simple_mappings">Simple mappings</a></li>
<li><a href="#_adding_a_package">Adding a package</a></li>
<li><a href="#_adding_a_plugin">Adding a plugin</a></li>
<li><a href="#_adding_a_help_file">Adding a help file</a></li>
<li><a href="#_the_option_window">The option window</a></li>
<li><a href="#_often_used_options">Often used options</a></li>
</ul>
</li>
<li><a href="#_using_syntax_highlighting">Using syntax highlighting</a>
<ul class="sectlevel2">
<li><a href="#_switching_it_on">Switching it on</a></li>
<li><a href="#_no_or_wrong_colors">No or wrong colors?</a></li>
<li><a href="#_different_colors">Different colors</a></li>
<li><a href="#_with_colors_or_without_colors">With colors or without colors</a></li>
<li><a href="#_printing_with_colors">Printing with colors</a></li>
<li><a href="#_further_reading">Further reading</a></li>
</ul>
</li>
<li><a href="#_editing_more_than_one_file">Editing more than one file</a>
<ul class="sectlevel2">
<li><a href="#_edit_another_file">Edit another file</a></li>
<li><a href="#_a_list_of_files">A list of files</a></li>
<li><a href="#_jumping_from_file_to_file">Jumping from file to file</a></li>
<li><a href="#_backup_files">Backup files</a></li>
<li><a href="#_copy_text_between_files">Copy text between files</a></li>
<li><a href="#_viewing_a_file">Viewing a file</a></li>
<li><a href="#_changing_the_file_name">Changing the file name</a></li>
</ul>
</li>
<li><a href="#_splitting_windows">Splitting windows</a>
<ul class="sectlevel2">
<li><a href="#_split_a_window">Split a window</a></li>
<li><a href="#_split_a_window_on_another_file">Split a window on another file</a></li>
<li><a href="#_window_size">Window size</a></li>
<li><a href="#_vertical_splits">Vertical splits</a></li>
<li><a href="#_moving_windows">Moving windows</a></li>
<li><a href="#_commands_for_all_windows">Commands for all windows</a></li>
<li><a href="#_viewing_differences_with_vimdiff">Viewing differences with vimdiff</a></li>
<li><a href="#_various">Various</a></li>
<li><a href="#_tab_pages">Tab pages</a></li>
</ul>
</li>
<li><a href="#_using_the_gui">Using the GUI</a>
<ul class="sectlevel2">
<li><a href="#_parts_of_the_gui">Parts of the GUI</a></li>
<li><a href="#_using_the_mouse_2">Using the mouse</a></li>
<li><a href="#_the_clipboard">The clipboard</a></li>
<li><a href="#_select_mode">Select mode</a></li>
</ul>
</li>
<li><a href="#_making_big_changes">Making big changes</a>
<ul class="sectlevel2">
<li><a href="#_record_and_playback_commands">Record and playback commands</a></li>
<li><a href="#_substitution">Substitution</a></li>
<li><a href="#_command_ranges">Command ranges</a></li>
<li><a href="#_the_global_command">The global command</a></li>
<li><a href="#_visual_block_mode">Visual block mode</a></li>
<li><a href="#_reading_and_writing_part_of_a_file">Reading and writing part of a file</a></li>
<li><a href="#_formatting_text">Formatting text</a></li>
<li><a href="#_changing_case">Changing case</a></li>
<li><a href="#_using_an_external_program">Using an external program</a></li>
</ul>
</li>
<li><a href="#_recovering_from_a_crash">Recovering from a crash</a>
<ul class="sectlevel2">
<li><a href="#_basic_recovery">Basic recovery</a></li>
<li><a href="#_where_is_the_swap_file">Where is the swap file?</a></li>
<li><a href="#_crashed_or_not">Crashed or not?</a></li>
<li><a href="#_further_reading_2">Further reading</a></li>
</ul>
</li>
<li><a href="#_clever_tricks">Clever tricks</a>
<ul class="sectlevel2">
<li><a href="#_replace_a_word">Replace a word</a></li>
<li><a href="#_change_last_first_to_first_last">Change "Last, First" to "First Last"</a></li>
<li><a href="#_sort_a_list">Sort a list</a></li>
<li><a href="#_reverse_line_order">Reverse line order</a></li>
<li><a href="#_count_words">Count words</a></li>
<li><a href="#_find_a_man_page">Find a man page</a></li>
<li><a href="#_trim_blanks">Trim blanks</a></li>
<li><a href="#_find_where_a_word_is_used">Find where a word is used</a></li>
</ul>
</li>
<li><a href="#_typing_command_line_commands_quickly">Typing command-line commands quickly</a>
<ul class="sectlevel2">
<li><a href="#_command_line_editing">Command line editing</a></li>
<li><a href="#_command_line_abbreviations">Command line abbreviations</a></li>
<li><a href="#_command_line_completion">Command line completion</a></li>
<li><a href="#_command_line_history">Command line history</a></li>
<li><a href="#_command_line_window">Command line window</a></li>
</ul>
</li>
<li><a href="#_go_away_and_come_back">Go away and come back</a>
<ul class="sectlevel2">
<li><a href="#_suspend_and_resume">Suspend and resume</a></li>
<li><a href="#_executing_shell_commands">Executing shell commands</a></li>
<li><a href="#_remembering_information_viminfo">Remembering information; viminfo</a></li>
<li><a href="#_sessions">Sessions</a></li>
<li><a href="#_views">Views</a></li>
<li><a href="#_modelines">Modelines</a></li>
</ul>
</li>
<li><a href="#_finding_the_file_to_edit">Finding the file to edit</a>
<ul class="sectlevel2">
<li><a href="#_the_file_browser">The file browser</a></li>
<li><a href="#_the_current_directory">The current directory</a></li>
<li><a href="#_finding_a_file">Finding a file</a></li>
<li><a href="#_the_buffer_list">The buffer list</a></li>
</ul>
</li>
<li><a href="#_editing_other_files">Editing other files</a>
<ul class="sectlevel2">
<li><a href="#_dos_mac_and_unix_files">DOS, Mac and Unix files</a></li>
<li><a href="#_files_on_the_internet">Files on the internet</a></li>
<li><a href="#_encryption">Encryption</a></li>
<li><a href="#_binary_files">Binary files</a></li>
<li><a href="#_compressed_files">Compressed files</a></li>
</ul>
</li>
<li><a href="#_inserting_quickly">Inserting quickly</a>
<ul class="sectlevel2">
<li><a href="#_making_corrections">Making corrections</a></li>
<li><a href="#_showing_matches">Showing matches</a></li>
<li><a href="#_completion">Completion</a></li>
<li><a href="#_repeating_an_insert">Repeating an insert</a></li>
<li><a href="#_copying_from_another_line">Copying from another line</a></li>
<li><a href="#_inserting_a_register">Inserting a register</a></li>
<li><a href="#_abbreviations">Abbreviations</a></li>
<li><a href="#_entering_special_characters">Entering special characters</a></li>
<li><a href="#_digraphs">Digraphs</a></li>
<li><a href="#_normal_mode_commands">Normal mode commands</a></li>
</ul>
</li>
<li><a href="#_editing_formatted_text">Editing formatted text</a>
<ul class="sectlevel2">
<li><a href="#_breaking_lines">Breaking lines</a></li>
<li><a href="#_aligning_text">Aligning text</a></li>
<li><a href="#_indents_and_tabs">Indents and tabs</a></li>
<li><a href="#_dealing_with_long_lines">Dealing with long lines</a></li>
<li><a href="#_editing_tables">Editing tables</a></li>
</ul>
</li>
<li><a href="#_repeating">Repeating</a>
<ul class="sectlevel2">
<li><a href="#_repeating_with_visual_mode">Repeating with Visual mode</a></li>
<li><a href="#_add_and_subtract_2">Add and subtract</a></li>
<li><a href="#_making_a_change_in_many_files">Making a change in many files</a></li>
<li><a href="#_using_vim_from_a_shell_script">Using Vim from a shell script</a></li>
</ul>
</li>
<li><a href="#_search_commands_and_patterns">Search commands and patterns</a>
<ul class="sectlevel2">
<li><a href="#_ignoring_case_2">Ignoring case</a></li>
<li><a href="#_wrapping_around_the_file_end">Wrapping around the file end</a></li>
<li><a href="#_offsets">Offsets</a></li>
<li><a href="#_matching_multiple_times">Matching multiple times</a></li>
<li><a href="#_alternatives">Alternatives</a></li>
<li><a href="#_character_ranges">Character ranges</a></li>
<li><a href="#_character_classes">Character classes</a></li>
<li><a href="#_matching_a_line_break">Matching a line break</a></li>
<li><a href="#_examples">Examples</a></li>
</ul>
</li>
<li><a href="#_folding">Folding</a>
<ul class="sectlevel2">
<li><a href="#_what_is_folding">What is folding?</a></li>
<li><a href="#_manual_folding">Manual folding</a></li>
<li><a href="#_working_with_folds">Working with folds</a></li>
<li><a href="#_saving_and_restoring_folds">Saving and restoring folds</a></li>
<li><a href="#_folding_by_indent">Folding by indent</a></li>
<li><a href="#_folding_with_markers">Folding with markers</a></li>
<li><a href="#_folding_by_syntax">Folding by syntax</a></li>
<li><a href="#_folding_by_expression">Folding by expression</a></li>
<li><a href="#_folding_unchanged_lines">Folding unchanged lines</a></li>
<li><a href="#_which_fold_method_to_use">Which fold method to use?</a></li>
</ul>
</li>
<li><a href="#_moving_through_programs">Moving through programs</a>
<ul class="sectlevel2">
<li><a href="#_using_tags">Using tags</a></li>
<li><a href="#_the_preview_window">The preview window</a></li>
<li><a href="#_moving_through_a_program">Moving through a program</a></li>
<li><a href="#_finding_global_identifiers">Finding global identifiers</a></li>
<li><a href="#_finding_local_identifiers">Finding local identifiers</a></li>
</ul>
</li>
<li><a href="#_editing_programs">Editing programs</a>
<ul class="sectlevel2">
<li><a href="#_compiling">Compiling</a></li>
<li><a href="#_indenting_c_style_text">Indenting C style text</a></li>
<li><a href="#_automatic_indenting">Automatic indenting</a></li>
<li><a href="#_other_indenting">Other indenting</a></li>
<li><a href="#_tabs_and_spaces">Tabs and spaces</a></li>
<li><a href="#_formatting_comments">Formatting comments</a></li>
</ul>
</li>
<li><a href="#_exploiting_the_gui">Exploiting the GUI</a>
<ul class="sectlevel2">
<li><a href="#_the_file_browser_2">The file browser</a></li>
<li><a href="#_confirmation">Confirmation</a></li>
<li><a href="#_menu_shortcuts">Menu shortcuts</a></li>
<li><a href="#_vim_window_position_and_size">Vim window position and size</a></li>
<li><a href="#_various_2">Various</a></li>
</ul>
</li>
<li><a href="#_the_undo_tree">The undo tree</a>
<ul class="sectlevel2">
<li><a href="#_undo_up_to_a_file_write">Undo up to a file write</a></li>
<li><a href="#_numbering_changes">Numbering changes</a></li>
<li><a href="#_jumping_around_the_tree">Jumping around the tree</a></li>
<li><a href="#_time_travelling">Time travelling</a></li>
</ul>
</li>
<li><a href="#_make_new_commands">Make new commands</a>
<ul class="sectlevel2">
<li><a href="#_key_mapping">Key mapping</a></li>
<li><a href="#_defining_command_line_commands">Defining command-line commands</a></li>
<li><a href="#_autocommands">Autocommands</a></li>
</ul>
</li>
<li><a href="#_write_a_vim_script">Write a Vim script</a>
<ul class="sectlevel2">
<li><a href="#_introduction">Introduction</a></li>
<li><a href="#_variables">Variables</a></li>
<li><a href="#_expressions">Expressions</a></li>
<li><a href="#_conditionals">Conditionals</a></li>
<li><a href="#_executing_an_expression">Executing an expression</a></li>
<li><a href="#_using_functions">Using functions</a></li>
<li><a href="#_defining_a_function">Defining a function</a></li>
<li><a href="#_lists_and_dictionaries">Lists and Dictionaries</a></li>
<li><a href="#_exceptions">Exceptions</a></li>
<li><a href="#_various_remarks">Various remarks</a></li>
<li><a href="#_writing_a_plugin">Writing a plugin</a></li>
<li><a href="#_writing_a_filetype_plugin">Writing a filetype plugin</a></li>
<li><a href="#_writing_a_compiler_plugin">Writing a compiler plugin</a></li>
<li><a href="#_writing_a_plugin_that_loads_quickly">Writing a plugin that loads quickly</a></li>
<li><a href="#_writing_library_scripts">Writing library scripts</a></li>
<li><a href="#_distributing_vim_scripts">Distributing Vim scripts</a></li>
</ul>
</li>
<li><a href="#_add_new_menus">Add new menus</a>
<ul class="sectlevel2">
<li><a href="#_introduction_2">Introduction</a></li>
<li><a href="#_menu_commands">Menu commands</a></li>
<li><a href="#_various_3">Various</a></li>
<li><a href="#_toolbar_and_popup_menus">Toolbar and popup menus</a></li>
</ul>
</li>
<li><a href="#_using_filetypes">Using filetypes</a>
<ul class="sectlevel2">
<li><a href="#_plugins_for_a_filetype">Plugins for a filetype</a></li>
<li><a href="#_adding_a_filetype">Adding a filetype</a></li>
</ul>
</li>
<li><a href="#_your_own_syntax_highlighted">Your own syntax highlighted</a>
<ul class="sectlevel2">
<li><a href="#_basic_syntax_commands">Basic syntax commands</a></li>
<li><a href="#_keywords_2">Keywords</a></li>
<li><a href="#_matches">Matches</a></li>
<li><a href="#_regions">Regions</a></li>
<li><a href="#_nested_items">Nested items</a></li>
<li><a href="#_following_groups">Following groups</a></li>
<li><a href="#_other_arguments">Other arguments</a></li>
<li><a href="#_clusters">Clusters</a></li>
<li><a href="#_including_another_syntax_file">Including another syntax file</a></li>
<li><a href="#_synchronizing">Synchronizing</a></li>
<li><a href="#_installing_a_syntax_file">Installing a syntax file</a></li>
<li><a href="#_portable_syntax_file_layout">Portable syntax file layout</a></li>
</ul>
</li>
<li><a href="#_select_your_language">Select your language</a>
<ul class="sectlevel2">
<li><a href="#_language_for_messages">Language for Messages</a></li>
<li><a href="#_language_for_menus">Language for Menus</a></li>
<li><a href="#_using_another_encoding">Using another encoding</a></li>
<li><a href="#_editing_files_with_a_different_encoding">Editing files with a different encoding</a></li>
<li><a href="#_entering_language_text">Entering language text</a></li>
</ul>
</li>
<li><a href="#_installing_vim">Installing Vim</a>
<ul class="sectlevel2">
<li><a href="#_unix">Unix</a></li>
<li><a href="#_ms_windows">MS-Windows</a></li>
<li><a href="#_upgrading">Upgrading</a></li>
<li><a href="#_common_installation_issues">Common installation issues</a></li>
<li><a href="#_uninstalling_vim">Uninstalling Vim</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_about_the_manuals">About the manuals</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter introduces the manuals available with Vim.  Read this to know the
conditions under which the commands are explained.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Two manuals</p>
</li>
<li>
<p>Vim installed</p>
</li>
<li>
<p>Using the Vim tutor</p>
</li>
<li>
<p>Copyright</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_two_manuals">Two manuals</h3>
<div class="paragraph">
<p>The Vim documentation consists of two parts:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>The User manual</strong>
Task oriented explanations, from simple to complex.  Reads from start to
end like a book.</p>
</li>
<li>
<p><strong>The Reference manual</strong>
Precise description of how everything in Vim works.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The notation used in these manuals is explained here: |notation|</p>
</div>
<div class="sect3">
<h4 id="_jumping_around">JUMPING AROUND</h4>
<div class="paragraph">
<p>The text contains hyperlinks between the two parts, allowing you to quickly
jump between the description of an editing task and a precise explanation of
the commands and options used for it.  Use these two commands:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Press  CTRL-]  to jump to a subject under the cursor.</p>
</li>
<li>
<p>Press  CTRL-O  to jump back (repeat to go further back).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Many links are in vertical bars, like this: |bars|.  The bars themselves may
be hidden or invisible; see below.  An option name, like 'number', a command
in double quotes like ":write" and any other word can also be used as a link.
Try it out: Move the cursor to  CTRL-]  and press CTRL-] on it.</p>
</div>
<div class="paragraph">
<p>Other subjects can be found with the ":help" command; see |help.txt|.</p>
</div>
<div class="paragraph">
<p>The bars and stars are usually hidden with the |conceal| feature.  They also
use |hl-Ignore|, using the same color for the text as the background.  You can
make them visible with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set conceallevel=0
:hi link HelpBar Normal
:hi link HelpStar Normal</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_vim_installed">Vim installed</h3>
<div class="paragraph">
<p>Most of the manuals assume that Vim has been properly installed.  If you
didn&#8217;t do that yet, or if Vim doesn&#8217;t run properly (e.g., files can&#8217;t be found
or in the GUI the menus do not show up) first read the chapter on
installation: |usr_90.txt|.</p>
</div>
<div class="paragraph">
<p>The manuals often assume you are using Vim with Vi-compatibility switched
off.  For most commands this doesn&#8217;t matter, but sometimes it is important,
e.g., for multi-level undo.  An easy way to make sure you are using a nice
setup is to copy the example vimrc file.  By doing this inside Vim you don&#8217;t
have to check out where it is located.  How to do this depends on the system
you are using:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Unix:</p>
<div class="literalblock">
<div class="content">
<pre>:!cp -i $VIMRUNTIME/vimrc_example.vim ~/.vimrc</pre>
</div>
</div>
</li>
<li>
<p>MS-Windows:</p>
<div class="literalblock">
<div class="content">
<pre>:!copy $VIMRUNTIME/vimrc_example.vim $VIM/_vimrc</pre>
</div>
</div>
</li>
<li>
<p>Amiga:</p>
<div class="literalblock">
<div class="content">
<pre>:!copy $VIMRUNTIME/vimrc_example.vim $VIM/.vimrc</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the file already exists you probably want to keep it.</p>
</div>
<div class="paragraph">
<p>If you start Vim now, the 'compatible' option should be off.  You can check it
with this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set compatible?</pre>
</div>
</div>
<div class="paragraph">
<p>If it responds with "nocompatible" you are doing well.  If the response is
"compatible" you are in trouble.  You will have to find out why the option is
still set.  Perhaps the file you wrote above is not found.  Use this command
to find out:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:scriptnames</pre>
</div>
</div>
<div class="paragraph">
<p>If your file is not in the list, check its location and name.  If it is in the
list, there must be some other place where the 'compatible' option is switched
back on.</p>
</div>
<div class="paragraph">
<p>For more info see |vimrc| and |compatible-default|.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This manual is about using Vim in the normal way.  There is an
alternative called "evim" (easy Vim).  This is still Vim, but used in
a way that resembles a click-and-type editor like Notepad.  It always
stays in Insert mode, thus it feels very different.  It is not
explained in the user manual, since it should be mostly
self-explanatory.  See |evim-keys| for details.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_vim_tutor">Using the Vim tutor</h3>
<div class="paragraph">
<p>Instead of reading the text (boring!) you can use the vimtutor to learn your
first Vim commands.  This is a 30-minute tutorial that teaches the most basic
Vim functionality hands-on.</p>
</div>
<div class="paragraph">
<p>On Unix, if Vim has been properly installed, you can start it from the shell:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vimtutor</pre>
</div>
</div>
<div class="paragraph">
<p>On MS-Windows you can find it in the Program/Vim menu.  Or execute
vimtutor.bat in the $VIMRUNTIME directory.</p>
</div>
<div class="paragraph">
<p>This will make a copy of the tutor file, so that you can edit it without
the risk of damaging the original.</p>
</div>
<div class="paragraph">
<p>There are a few translated versions of the tutor.  To find out if yours is
available, use the two-letter language code.  For French:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vimtutor fr</pre>
</div>
</div>
<div class="paragraph">
<p>On Unix, if you prefer using the GUI version of Vim, use "gvimtutor" or
"vimtutor -g" instead of "vimtutor".</p>
</div>
<div class="paragraph">
<p>For OpenVMS, if Vim has been properly installed, you can start vimtutor from a
VMS prompt with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@VIM:vimtutor</pre>
</div>
</div>
<div class="paragraph">
<p>Optionally add the two-letter language code as above.</p>
</div>
<div class="paragraph">
<p>On other systems, you have to do a little work:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Copy the tutor file.  You can do this with Vim (it knows where to find it):</p>
<div class="literalblock">
<div class="content">
<pre>vim --clean -c 'e $VIMRUNTIME/tutor/tutor' -c 'w! TUTORCOPY' -c 'q'</pre>
</div>
</div>
<div class="paragraph">
<p>This will write the file "TUTORCOPY" in the current directory.  To use a
translated version of the tutor, append the two-letter language code to the
filename.  For French:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim --clean -c 'e $VIMRUNTIME/tutor/tutor.fr' -c 'w! TUTORCOPY' -c 'q'</pre>
</div>
</div>
</li>
<li>
<p>Edit the copied file with Vim:</p>
<div class="literalblock">
<div class="content">
<pre>vim --clean TUTORCOPY</pre>
</div>
</div>
<div class="paragraph">
<p>The --clean argument makes sure Vim is started with nice defaults.</p>
</div>
</li>
<li>
<p>Delete the copied file when you are finished with it:</p>
<div class="literalblock">
<div class="content">
<pre>del TUTORCOPY</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_copyright">Copyright</h3>
<div class="paragraph">
<p>The Vim user manual and reference manual are Copyright (c) 1988-2003 by Bram
Moolenaar.  This material may be distributed only subject to the terms and
conditions set forth in the Open Publication License, v1.0 or later.  The
latest version is presently available at:
             <a href="http://www.opencontent.org/openpub/" class="bare">http://www.opencontent.org/openpub/</a></p>
</div>
<div class="paragraph">
<p>People who contribute to the manuals must agree with the above copyright
notice.</p>
</div>
<div class="paragraph">
<p>Parts of the user manual come from the book "Vi IMproved - Vim" by Steve
Oualline (published by New Riders Publishing, ISBN: 0735710015).  The Open
Publication License applies to this book.  Only selected parts are included
and these have been modified (e.g., by removing the pictures, updating the
text for Vim 6.0 and later, fixing mistakes).  The omission of the |frombook|
tag does not mean that the text does not come from the book.</p>
</div>
<div class="paragraph">
<p>Many thanks to Steve Oualline and New Riders for creating this book and
publishing it under the OPL!  It has been a great help while writing the user
manual.  Not only by providing literal text, but also by setting the tone and
style.</p>
</div>
<div class="paragraph">
<p>If you make money through selling the manuals, you are strongly encouraged to
donate part of the profit to help AIDS victims in Uganda.  See |iccf|.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_first_steps_in_vim">The first steps in Vim</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter provides just enough information to edit a file with Vim.  Not
well or fast, but you can edit.  Take some time to practice with these
commands, they form the base for what follows.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Running Vim for the First Time</p>
</li>
<li>
<p>Inserting text</p>
</li>
<li>
<p>Moving around</p>
</li>
<li>
<p>Deleting characters</p>
</li>
<li>
<p>Undo and Redo</p>
</li>
<li>
<p>Other editing commands</p>
</li>
<li>
<p>Getting out</p>
</li>
<li>
<p>Finding help</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_running_vim_for_the_first_time">Running Vim for the First Time</h3>
<div class="paragraph">
<p>To start Vim, enter this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gvim file.txt</pre>
</div>
</div>
<div class="paragraph">
<p>In UNIX you can type this at any command prompt.  If you are running Microsoft
Windows, open a Command Prompt and enter the command.</p>
</div>
<div class="paragraph">
<p>In either case, Vim starts editing a file called file.txt.  Because this
is a new file, you get a blank window. This is what your screen will look
like:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+---------------------------------------+
|#                                      |
|~                                      |
|~                                      |
|~                                      |
|~                                      |
|"file.txt" [New file]                  |
+---------------------------------------+
        ('#" is the cursor position.)</pre>
</div>
</div>
<div class="paragraph">
<p>The tilde (\~) lines indicate lines not in the file.  In other words, when Vim
runs out of file to display, it displays tilde lines.  At the bottom of the
screen, a message line indicates the file is named file.txt and shows that you
are creating a new file.  The message information is temporary and other
information overwrites it.</p>
</div>
<div class="sect3">
<h4 id="_the_vim_command">THE VIM COMMAND</h4>
<div class="paragraph">
<p>The gvim command causes the editor to create a new window for editing.  If you
use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim file.txt</pre>
</div>
</div>
<div class="paragraph">
<p>the editing occurs inside your command window.  In other words, if you are
running inside an xterm, the editor uses your xterm window.  If you are using
an MS-Windows command prompt window, the editing occurs inside this window.
The text in the window will look the same for both versions, but with gvim you
have extra features, like a menu bar.  More about that later.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_inserting_text">Inserting text</h3>
<div class="paragraph">
<p>The Vim editor is a modal editor.  That means that the editor behaves
differently, depending on which mode you are in.  The two basic modes are
called Normal mode and Insert mode.  In Normal mode the characters you type
are commands.  In Insert mode the characters are inserted as text.</p>
</div>
<div class="paragraph">
<p>Since you have just started Vim it will be in Normal mode.  To start Insert
mode you type the "i" command (i for Insert).  Then you can enter
the text.  It will be inserted into the file.  Do not worry if you make
mistakes; you can correct them later.  To enter the following programmer&#8217;s
limerick, this is what you type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>iA very intelligent turtle
Found programming UNIX a hurdle</pre>
</div>
</div>
<div class="paragraph">
<p>After typing "turtle" you press the &lt;Enter&gt; key to start a new line.  Finally
you press the &lt;Esc&gt; key to stop Insert mode and go back to Normal mode.  You
now have two lines of text in your Vim window:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+---------------------------------------+
|A very intelligent turtle              |
|Found programming UNIX a hurdle        |
|~                                      |
|~                                      |
|                                       |
+---------------------------------------+</pre>
</div>
</div>
<div class="sect3">
<h4 id="_what_is_the_mode">WHAT IS THE MODE?</h4>
<div class="paragraph">
<p>To be able to see what mode you are in, type this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set showmode</pre>
</div>
</div>
<div class="paragraph">
<p>You will notice that when typing the colon Vim moves the cursor to the last
line of the window.  That&#8217;s where you type colon commands (commands that start
with a colon).  Finish this command by pressing the &lt;Enter&gt; key (all commands
that start with a colon are finished this way).</p>
</div>
<div class="paragraph">
<p>Now, if you type the "i" command Vim will display --INSERT-- at the bottom
of the window.  This indicates you are in Insert mode.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+---------------------------------------+
|A very intelligent turtle              |
|Found programming UNIX a hurdle        |
|~                                      |
|~                                      |
|-- INSERT --                           |
+---------------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>If you press &lt;Esc&gt; to go back to Normal mode the last line will be made blank.</p>
</div>
</div>
<div class="sect3">
<h4 id="_getting_out_of_trouble">GETTING OUT OF TROUBLE</h4>
<div class="paragraph">
<p>One of the problems for Vim novices is mode confusion, which is caused by
forgetting which mode you are in or by accidentally typing a command that
switches modes.  To get back to Normal mode, no matter what mode you are in,
press the &lt;Esc&gt; key.  Sometimes you have to press it twice.  If Vim beeps back
at you, you already are in Normal mode.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_moving_around">Moving around</h3>
<div class="paragraph">
<p>After you return to Normal mode, you can move around by using these keys:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>h   left                                                *hjkl*
j   down
k   up
l   right</pre>
</div>
</div>
<div class="paragraph">
<p>At first, it may appear that these commands were chosen at random.  After all,
who ever heard of using l for right?  But actually, there is a very good
reason for these choices: Moving the cursor is the most common thing you do in
an editor, and these keys are on the home row of your right hand.  In other
words, these commands are placed where you can type them the fastest
(especially when you type with ten fingers).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
You can also move the cursor by using the arrow keys.  If you do,
however, you greatly slow down your editing because to press the arrow keys,
you must move your hand from the text keys to the arrow keys. Considering that
you might be doing it hundreds of times an hour, this can take a significant
amount of time. Also, there are keyboards which do not have arrow keys, or
which locate them in unusual places; therefore, knowing the use of the hjkl
keys helps in those situations.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>One way to remember these commands is that h is on the left, l is on the
right and j points down.  In a picture:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    k
h     l
  j</pre>
</div>
</div>
<div class="paragraph">
<p>The best way to learn these commands is by using them.  Use the "i" command to
insert some more lines of text.  Then use the hjkl keys to move around and
insert a word somewhere.  Don&#8217;t forget to press &lt;Esc&gt; to go back to Normal
mode.  The |vimtutor| is also a nice way to learn by doing.</p>
</div>
<div class="paragraph">
<p>For Japanese users, Hiroshi Iwatani suggested using this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>                Komsomolsk
                    ^
                    |
   Huan Ho      &lt;--- ---&gt;  Los Angeles
(Yellow river)      |
                    v
                  Java</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_deleting_characters">Deleting characters</h3>
<div class="paragraph">
<p>To delete a character, move the cursor over it and type "x".  (This is a
throwback to the old days of the typewriter, when you deleted things by typing
xxxx over them.)  Move the cursor to the beginning of the first line, for
example, and type xxxxxxx (seven x&#8217;s) to delete "A very ".  The result should
look like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+---------------------------------------+
|intelligent turtle                     |
|Found programming UNIX a hurdle        |
|~                                      |
|~                                      |
|                                       |
+---------------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can insert new text, for example by typing:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>iA young &lt;Esc&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>This begins an insert (the i), inserts the words "A young", and then exits
insert mode (the final &lt;Esc&gt;).  The result:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+---------------------------------------+
|A young intelligent turtle             |
|Found programming UNIX a hurdle        |
|~                                      |
|~                                      |
|                                       |
+---------------------------------------+</pre>
</div>
</div>
<div class="sect3">
<h4 id="_deleting_a_line">DELETING A LINE</h4>
<div class="paragraph">
<p>To delete a whole line use the "dd" command.  The following line will
then move up to fill the gap:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+---------------------------------------+
|Found programming UNIX a hurdle        |
|~                                      |
|~                                      |
|~                                      |
|                                       |
+---------------------------------------+</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_deleting_a_line_break">DELETING A LINE BREAK</h4>
<div class="paragraph">
<p>In Vim you can join two lines together, which means that the line break
between them is deleted.  The "J" command does this.</p>
</div>
<div class="paragraph">
<p>Take these two lines:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A young intelligent
turtle</pre>
</div>
</div>
<div class="paragraph">
<p>Move the cursor to the first line and press "J":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A young intelligent turtle</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_undo_and_redo">Undo and Redo</h3>
<div class="paragraph">
<p>Suppose you delete too much.  Well, you can type it in again, but an easier
way exists.  The "u" command undoes the last edit.  Take a look at this in
action: After using "dd" to delete the first line, "u" brings it back.</p>
</div>
<div class="paragraph">
<p>Another one: Move the cursor to the A in the first line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A young intelligent turtle</pre>
</div>
</div>
<div class="paragraph">
<p>Now type xxxxxxx to delete "A young".  The result is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>intelligent turtle</pre>
</div>
</div>
<div class="paragraph">
<p>Type "u" to undo the last delete.  That delete removed the g, so the undo
restores the character.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>g intelligent turtle</pre>
</div>
</div>
<div class="paragraph">
<p>The next "u" command restores the next-to-last character deleted:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ng intelligent turtle</pre>
</div>
</div>
<div class="paragraph">
<p>The next "u" command gives you the u, and so on:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ung intelligent turtle
oung intelligent turtle
young intelligent turtle
 young intelligent turtle
A young intelligent turtle</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
If you type "u" twice, and the result is that you get the same text back,
you have Vim configured to work Vi compatible.  Look here to fix this:
|not-compatible|. This text assumes you work "The Vim Way". You might prefer to
use the good old Vi way, but you will have to watch out for small differences
in the text then.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_redo">REDO</h4>
<div class="paragraph">
<p>If you undo too many times, you can press CTRL-R (redo) to reverse the
preceding command.  In other words, it undoes the undo.  To see this in
action, press CTRL-R twice.  The character A and the space after it disappear:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>young intelligent turtle</pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s a special version of the undo command, the "U" (undo line) command.
The undo line command undoes all the changes made on the last line that was
edited.  Typing this command twice cancels the preceding "U".</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A very intelligent turtle
  xxxx                          Delete very</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>A intelligent turtle
              xxxxxx            Delete turtle</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>A intelligent
                                Restore line with "U"
A very intelligent turtle
                                Undo "U" with "u"
A intelligent</pre>
</div>
</div>
<div class="paragraph">
<p>The "U" command is a change by itself, which the "u" command undoes and CTRL-R
redoes.  This might be a bit confusing.  Don&#8217;t worry, with "u" and CTRL-R you
can go to any of the situations you had.  More about that in section |32.2|.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_other_editing_commands">Other editing commands</h3>
<div class="paragraph">
<p>Vim has a large number of commands to change the text.  See |Q_in| and below.
Here are a few often used ones.</p>
</div>
<div class="sect3">
<h4 id="_appending">APPENDING</h4>
<div class="paragraph">
<p>The "i" command inserts a character before the character under the cursor.
That works fine; but what happens if you want to add stuff to the end of the
line?  For that you need to insert text after the cursor.  This is done with
the "a" (append) command.</p>
</div>
<div class="paragraph">
<p>For example, to change the line</p>
</div>
<div class="literalblock">
<div class="content">
<pre>and that's not saying much for the turtle.</pre>
</div>
</div>
<div class="paragraph">
<p>to</p>
</div>
<div class="literalblock">
<div class="content">
<pre>and that's not saying much for the turtle!!!</pre>
</div>
</div>
<div class="paragraph">
<p>move the cursor over to the dot at the end of the line. Then type "x" to
delete the period.  The cursor is now positioned at the end of the line on the
e in turtle.  Now type</p>
</div>
<div class="literalblock">
<div class="content">
<pre>a!!!&lt;Esc&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>to append three exclamation points after the e in turtle:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>and that's not saying much for the turtle!!!</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_opening_up_a_new_line">OPENING UP A NEW LINE</h4>
<div class="paragraph">
<p>The "o" command creates a new, empty line below the cursor and puts Vim in
Insert mode.  Then you can type the text for the new line.</p>
</div>
<div class="paragraph">
<p>Suppose the cursor is somewhere in the first of these two lines:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A very intelligent turtle
Found programming UNIX a hurdle</pre>
</div>
</div>
<div class="paragraph">
<p>If you now use the "o" command and type new text:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>oThat liked using Vim&lt;Esc&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The result is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A very intelligent turtle
That liked using Vim
Found programming UNIX a hurdle</pre>
</div>
</div>
<div class="paragraph">
<p>The "O" command (uppercase) opens a line above the cursor.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_a_count">USING A COUNT</h4>
<div class="paragraph">
<p>Suppose you want to move up nine lines.  You can type "kkkkkkkkk" or you can
enter the command "9k".  In fact, you can precede many commands with a number.
Earlier in this chapter, for instance, you added three exclamation points to
the end of a line by typing "a!!!&lt;Esc&gt;".  Another way to do this is to use the
command "3a!&lt;Esc&gt;".  The count of 3 tells the command that follows to triple
its effect.  Similarly, to delete three characters, use the command "3x".  The
count always comes before the command it applies to.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_getting_out">Getting out</h3>
<div class="paragraph">
<p>To exit, use the "ZZ" command.  This command writes the file and exits.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Unlike many other editors, Vim does not automatically make a backup file.
If you type "ZZ", your changes are committed and there&#8217;s no turning back.  You
can configure the Vim editor to produce backup files; see |07.4|.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_discarding_changes">DISCARDING CHANGES</h4>
<div class="paragraph">
<p>Sometimes you will make a sequence of changes and suddenly realize you were
better off before you started.  Not to worry; Vim has a
quit-and-throw-things-away command.  It is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:q!</pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t forget to press &lt;Enter&gt; to finish the command.</p>
</div>
<div class="paragraph">
<p>For those of you interested in the details, the three parts of this command
are the colon (:), which enters Command-line mode; the q command, which tells
the editor to quit; and the override command modifier (!).</p>
</div>
<div class="paragraph">
<p>The override command modifier is needed because Vim is reluctant to throw
away changes.  If you were to just type ":q", Vim would display an error
message and refuse to exit:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E37: No write since last change (use ! to override)</pre>
</div>
</div>
<div class="paragraph">
<p>By specifying the override, you are in effect telling Vim, "I know that what
I&#8217;m doing looks stupid, but I really want to do this."</p>
</div>
<div class="paragraph">
<p>If you want to continue editing with Vim: The ":e!" command reloads the
original version of the file.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_finding_help">Finding help</h3>
<div class="paragraph">
<p>Everything you always wanted to know can be found in the Vim help files.
Don&#8217;t be afraid to ask!</p>
</div>
<div class="paragraph">
<p>If you know what you are looking for, it is usually easier to search for it
using the help system, instead of using Google.  Because the subjects follow
a certain style guide.</p>
</div>
<div class="paragraph">
<p>Also the help has the advantage of belonging to your particular Vim version.
You won&#8217;t see help for commands added later.  These would not work for you.</p>
</div>
<div class="paragraph">
<p>To get generic help use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help</pre>
</div>
</div>
<div class="paragraph">
<p>You could also use the first function key &lt;F1&gt;.  If your keyboard has a &lt;Help&gt;
key it might work as well.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t supply a subject, ":help" displays the general help window.
The creators of Vim did something very clever (or very lazy) with the help
system: They made the help window a normal editing window.  You can use all
the normal Vim commands to move through the help information.  Therefore h, j,
k, and l move left, down, up and right.</p>
</div>
<div class="paragraph">
<p>To get out of the help window, use the same command you use to get out of
the editor: "ZZ".  This will only close the help window, not exit Vim.</p>
</div>
<div class="paragraph">
<p>As you read the help text, you will notice some text enclosed in vertical bars
(for example, |help|).  This indicates a hyperlink.  If you position the
cursor anywhere between the bars and press CTRL-] (jump to tag), the help
system takes you to the indicated subject.  (For reasons not discussed here,
the Vim terminology for a hyperlink is tag.  So CTRL-] jumps to the location
of the tag given by the word under the cursor.)</p>
</div>
<div class="paragraph">
<p>After a few jumps, you might want to go back.  CTRL-T (pop tag) takes you
back to the preceding position.  CTRL-O (jump to older position) also works
nicely here.</p>
</div>
<div class="paragraph">
<p>At the top of the help screen, there is the notation <strong>help.txt</strong>.  This name
between "*" characters is used by the help system to define a tag (hyperlink
destination).</p>
</div>
<div class="paragraph">
<p>See |29.1| for details about using tags.</p>
</div>
<div class="paragraph">
<p>To get help on a given subject, use the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help {subject}</pre>
</div>
</div>
<div class="paragraph">
<p>To get help on the "x" command, for example, enter the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help x</pre>
</div>
</div>
<div class="paragraph">
<p>To find out how to delete text, use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help deleting</pre>
</div>
</div>
<div class="paragraph">
<p>To get a complete index of all Vim commands, use the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help index</pre>
</div>
</div>
<div class="paragraph">
<p>When you need to get help for a control character command (for example,
CTRL-A), you need to spell it with the prefix "CTRL-".</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help CTRL-A</pre>
</div>
</div>
<div class="paragraph">
<p>The Vim editor has many different modes.  By default, the help system displays
the normal-mode commands.  For example, the following command displays help
for the normal-mode CTRL-H command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help CTRL-H</pre>
</div>
</div>
<div class="paragraph">
<p>To identify other modes, use a mode prefix.  If you want the help for the
insert-mode version of a command, use "i_".  For CTRL-H this gives you the
following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help i_CTRL-H</pre>
</div>
</div>
<div class="paragraph">
<p>When you start the Vim editor, you can use several command-line arguments.
These all begin with a dash (-).  To find what the -t argument does, for
example, use the command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help -t</pre>
</div>
</div>
<div class="paragraph">
<p>The Vim editor has a number of options that enable you to configure and
customize the editor.  If you want help for an option, you need to enclose it
in single quotation marks.  To find out what the 'number' option does, for
example, use the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help 'number'</pre>
</div>
</div>
<div class="paragraph">
<p>The table with all mode prefixes can be found below: |help-summary|.</p>
</div>
<div class="paragraph">
<p>Special keys are enclosed in angle brackets.  To find help on the up-arrow key
in Insert mode, for instance, use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help i_&lt;Up&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>If you see an error message that you don&#8217;t understand, for example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E37: No write since last change (use ! to override)</pre>
</div>
</div>
<div class="paragraph">
<p>You can use the error ID at the start to find help about it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help E37</pre>
</div>
</div>
<div class="sect3">
<h4 id="_summary">Summary</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use Ctrl-D after typing a topic and let Vim show all available topics.
Or press Tab to complete:</p>
<div class="literalblock">
<div class="content">
<pre>:help some&lt;Tab&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>More information on how to use the help:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help helphelp</pre>
</div>
</div>
</li>
<li>
<p>Follow the links in bars to related help.  You can go from the detailed
help to the user documentation, which describes certain commands more from
a user perspective and less detailed.  E.g. after:</p>
<div class="literalblock">
<div class="content">
<pre>:help pattern.txt</pre>
</div>
</div>
<div class="paragraph">
<p>You can see the user guide topics |03.9| and |usr_27.txt| in the introduction.</p>
</div>
</li>
<li>
<p>Options are enclosed in single apostrophes.  To go to the help topic for the
list option:</p>
<div class="literalblock">
<div class="content">
<pre>:help 'list'</pre>
</div>
</div>
<div class="paragraph">
<p>If you only know you are looking for a certain option, you can also do:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help options.txt</pre>
</div>
</div>
<div class="paragraph">
<p>to open the help page which describes all option handling and then search using
regular expressions, e.g. textwidth. Certain options have their own namespace,
e.g.:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help cpo-&lt;letter&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>for the corresponding flag of the 'cpoptions' settings, substitute &lt;letter&gt; by
a specific flag, e.g.:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help cpo-;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>And for the guioption flags:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>:help go-&lt;letter&gt;</pre>
</div>
</div>
</li>
<li>
<p>Normal mode commands do not have a prefix. To go to the help page for the
"gt" command:</p>
<div class="literalblock">
<div class="content">
<pre>:help gt</pre>
</div>
</div>
</li>
<li>
<p>Insert mode commands start with i_.  Help for deleting a word:</p>
<div class="literalblock">
<div class="content">
<pre>:help i_CTRL-W</pre>
</div>
</div>
</li>
<li>
<p>Visual mode commands start with v_.  Help for jumping to the other side of
the Visual area:</p>
<div class="literalblock">
<div class="content">
<pre>:help v_o</pre>
</div>
</div>
</li>
<li>
<p>Command line editing and arguments start with c_.  Help for using the
command argument %:</p>
<div class="literalblock">
<div class="content">
<pre>:help c_%</pre>
</div>
</div>
</li>
<li>
<p>Ex-commands always start with ":", so to go to the ":s" command help:</p>
<div class="literalblock">
<div class="content">
<pre>:help :s</pre>
</div>
</div>
</li>
<li>
<p>Commands specifically for debugging start with "&gt;".  To go to the help
for the "cont" debug command:</p>
<div class="literalblock">
<div class="content">
<pre>:help &gt;cont</pre>
</div>
</div>
</li>
<li>
<p>Key combinations.  They usually start with a single letter indicating
the mode for which they can be used.  E.g.:</p>
<div class="literalblock">
<div class="content">
<pre>:help i_CTRL-X</pre>
</div>
</div>
<div class="paragraph">
<p>takes you to the family of CTRL-X commands for insert mode which can be used to
auto-complete different things.  Note, that certain keys will always be written
the same, e.g. Control will always be CTRL.</p>
</div>
<div class="paragraph">
<p>For normal mode commands there is no prefix and the topic is available at :h
CTRL-&lt;Letter&gt;. E.g.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help CTRL-W</pre>
</div>
</div>
<div class="paragraph">
<p>In contrast</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help c_CTRL-R</pre>
</div>
</div>
<div class="paragraph">
<p>will describe what the CTRL-R does when entering commands in the Command line
and</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help v_CTRL-A</pre>
</div>
</div>
<div class="paragraph">
<p>talks about incrementing numbers in visual mode and</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help g_CTRL-A</pre>
</div>
</div>
<div class="paragraph">
<p>talks about the "g&lt;C-A&gt;" command (e.g. you have to press "g" then &lt;CTRL-A&gt;).
Here the "g" stands for the normal command "g" which always expects a second
key before doing something similar to the commands starting with "z".</p>
</div>
</li>
<li>
<p>Regexp items always start with /.  So to get help for the "\+" quantifier
in Vim regexes:</p>
<div class="literalblock">
<div class="content">
<pre>:help /\+</pre>
</div>
</div>
<div class="paragraph">
<p>If you need to know everything about regular expressions, start reading at:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help pattern.txt</pre>
</div>
</div>
</li>
<li>
<p>Registers always start with "quote". To find out about the special ":"
register:</p>
<div class="literalblock">
<div class="content">
<pre>:help quote:</pre>
</div>
</div>
</li>
<li>
<p>Vim script is available at</p>
<div class="literalblock">
<div class="content">
<pre>:help eval.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Certain aspects of the language are available at :h expr-X where "X" is a
single letter. E.g.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help expr-!</pre>
</div>
</div>
<div class="paragraph">
<p>will take you to the topic describing the "!" (Not) operator for Vim script.</p>
</div>
<div class="paragraph">
<p>Also important is</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help function-list</pre>
</div>
</div>
<div class="paragraph">
<p>to find a short description of all functions available.  Help topics for Vim
script functions always include the "()", so:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help append()</pre>
</div>
</div>
<div class="paragraph">
<p>talks about the append Vim script function rather than how to append text in
the current buffer.</p>
</div>
</li>
<li>
<p>Mappings are talked about in the help page :h |map.txt|. Use &gt;</p>
<div class="literalblock">
<div class="content">
<pre>:help mapmode-i</pre>
</div>
</div>
<div class="paragraph">
<p>to find out about the |:imap| command.  Also use :map-topic to find out about
certain subtopics particular for mappings.  e.g:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help :map-local</pre>
</div>
</div>
<div class="paragraph">
<p>for buffer-local mappings or</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help map-bar</pre>
</div>
</div>
<div class="paragraph">
<p>for how the '|' is handled in mappings.</p>
</div>
</li>
<li>
<p>Command definitions are talked about :h command-topic, so use</p>
<div class="literalblock">
<div class="content">
<pre>:help command-bar</pre>
</div>
</div>
<div class="paragraph">
<p>to find out about the '!' argument for custom commands.</p>
</div>
</li>
<li>
<p>Window management commands always start with CTRL-W, so you find the
corresponding help at :h CTRL-W_letter.  E.g.</p>
<div class="literalblock">
<div class="content">
<pre>:help CTRL-W_p</pre>
</div>
</div>
<div class="paragraph">
<p>for moving the previous accessed window.  You can also access</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help windows.txt</pre>
</div>
</div>
<div class="paragraph">
<p>and read your way through if you are looking for window handling commands.</p>
</div>
</li>
<li>
<p>Use |:helpgrep| to search in all help pages (and also of any installed
plugins).  See |:helpgrep| for how to use it.</p>
<div class="paragraph">
<p>To search for a topic:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:helpgrep topic</pre>
</div>
</div>
<div class="paragraph">
<p>This takes you to the first match.  To go to the next one:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:cnext</pre>
</div>
</div>
<div class="paragraph">
<p>All matches are available in the quickfix window which can be opened with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:copen</pre>
</div>
</div>
<div class="paragraph">
<p>Move around to the match you like and press Enter to jump to that help.</p>
</div>
</li>
<li>
<p>The user manual.  This describes help topics for beginners in a rather
friendly way.  Start at |usr_toc.txt| to find the table of content (as you
might have guessed):</p>
<div class="literalblock">
<div class="content">
<pre>:help usr_toc.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Skim over the contents to find interesting topics. The "Digraphs" and "Entering
special characters" items are in chapter 24, so to go to that particular help
page:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help usr_24.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Also if you want to access a certain chapter in the help, the chapter number
can be accessed directly like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help 10.1</pre>
</div>
</div>
<div class="paragraph">
<p>which goes to chapter 10.1 in |usr_10.txt| and talks about recording macros.</p>
</div>
</li>
<li>
<p>Highlighting groups.  Always start with hl-groupname.  E.g.</p>
<div class="literalblock">
<div class="content">
<pre>:help hl-WarningMsg</pre>
</div>
</div>
<div class="paragraph">
<p>talks about the WarningMsg highlighting group.</p>
</div>
</li>
<li>
<p>Syntax highlighting is namespaced to :syn-topic.  E.g.</p>
<div class="literalblock">
<div class="content">
<pre>:help :syn-conceal</pre>
</div>
</div>
<div class="paragraph">
<p>talks about the conceal argument for the ":syn" command.</p>
</div>
</li>
<li>
<p>Quickfix commands usually start with :c while location list commands usually
start with :l</p>
</li>
<li>
<p>Autocommand events can be found by their name:</p>
<div class="literalblock">
<div class="content">
<pre>:help BufWinLeave</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>To see all possible events:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>:help autocommand-events</pre>
</div>
</div>
</li>
<li>
<p>Command-line switches always start with "-".  So for the help of the -f
command switch of Vim use:</p>
<div class="literalblock">
<div class="content">
<pre>:help -f</pre>
</div>
</div>
</li>
<li>
<p>Optional features always start with "+".  To find out about the
conceal feature use:</p>
<div class="literalblock">
<div class="content">
<pre>:help +conceal</pre>
</div>
</div>
</li>
<li>
<p>Documentation for included filetype specific functionality is usually
available in the form ft-&lt;filetype&gt;-&lt;functionality&gt;.  So</p>
<div class="literalblock">
<div class="content">
<pre>:help ft-c-syntax</pre>
</div>
</div>
<div class="paragraph">
<p>talks about the C syntax file and the option it provides.  Sometimes,
    additional sections for omni completion</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help ft-php-omni</pre>
</div>
</div>
<div class="paragraph">
<p>or filetype plugins</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help ft-tex-plugin</pre>
</div>
</div>
<div class="paragraph">
<p>are available.</p>
</div>
</li>
<li>
<p>Error and Warning codes can be looked up directly in the help.  So</p>
<div class="literalblock">
<div class="content">
<pre>:help E297</pre>
</div>
</div>
<div class="paragraph">
<p>takes you exactly to the description of the swap error message and</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help W10</pre>
</div>
</div>
<div class="paragraph">
<p>talks about the warning "Changing a readonly file".</p>
</div>
<div class="paragraph">
<p>Sometimes, however, those error codes are not described, but rather are
    listed at the Vim command that usually causes this.  So:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help E128</pre>
</div>
</div>
<div class="paragraph">
<p>takes you to the |:function| command</p>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_moving_around_2">Moving around</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before you can insert or delete text the cursor has to be moved to the right
place.  Vim has a large number of commands to position the cursor.  This
chapter shows you how to use the most important ones.  You can find a list of
these commands below |Q_lr|.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Word movement</p>
</li>
<li>
<p>Moving to the start or end of a line</p>
</li>
<li>
<p>Moving to a character</p>
</li>
<li>
<p>Matching a parenthesis</p>
</li>
<li>
<p>Moving to a specific line</p>
</li>
<li>
<p>Telling where you are</p>
</li>
<li>
<p>Scrolling around</p>
</li>
<li>
<p>Simple searches</p>
</li>
<li>
<p>Simple search patterns</p>
</li>
<li>
<p>Using marks</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_word_movement">Word movement</h3>
<div class="paragraph">
<p>To move the cursor forward one word, use the "w" command.  Like most Vim
commands, you can use a numeric prefix to move past multiple words.  For
example, "3w" moves three words.  This figure shows how it works:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>This is a line with example text
  ---&gt;--&gt;-&gt;-----------------&gt;
   w  w  w    3w</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that "w" moves to the start of the next word if it already is at the
start of a word.</p>
</div>
<div class="paragraph">
<p>The "b" command moves backward to the start of the previous word:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>This is a line with example text
&lt;----&lt;--&lt;-&lt;---------&lt;---
   b   b b    2b      b</pre>
</div>
</div>
<div class="paragraph">
<p>There is also the "e" command that moves to the next end of a word and "ge",
which moves to the previous end of a word:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>This is a line with example text
   &lt;-   &lt;--- -----&gt;   ----&gt;
   ge    ge     e       e</pre>
</div>
</div>
<div class="paragraph">
<p>If you are at the last word of a line, the "w" command will take you to the
first word in the next line.  Thus you can use this to move through a
paragraph, much faster than using "l".  "b" does the same in the other
direction.</p>
</div>
<div class="paragraph">
<p>A word ends at a non-word character, such as a ".", "-" or ")".  To change
what Vim considers to be a word, see the 'iskeyword' option.  If you try this
out in the help directly, 'iskeyword' needs to be reset for the examples to
work:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set iskeyword&amp;</pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to move by white-space separated WORDs.  This is not a
word in the normal sense, that&#8217;s why the uppercase is used.  The commands for
moving by WORDs are also uppercase, as this figure shows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>       ge      b          w                             e
       &lt;-     &lt;-         ---&gt;                          ---&gt;
This is-a line, with special/separated/words (and some more).
   &lt;----- &lt;-----         --------------------&gt;         -----&gt;
     gE      B                   W                       E</pre>
</div>
</div>
<div class="paragraph">
<p>With this mix of lowercase and uppercase commands, you can quickly move
forward and backward through a paragraph.</p>
</div>
</div>
<div class="sect2">
<h3 id="_moving_to_the_start_or_end_of_a_line">Moving to the start or end of a line</h3>
<div class="paragraph">
<p>The "$" command moves the cursor to the end of a line.  If your keyboard has
an &lt;End&gt; key it will do the same thing.</p>
</div>
<div class="paragraph">
<p>The "^" command moves to the first non-blank character of the line.  The "0"
command (zero) moves to the very first character of the line, and the &lt;Home&gt;
key does the same thing.  In a picture:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>          ^
     &lt;------------
.....This is a line with example text
&lt;-----------------   ---------------&gt;
        0                  $</pre>
</div>
</div>
<div class="paragraph">
<p>(the "&#8230;&#8203;.." indicates blanks here)</p>
</div>
<div class="paragraph">
<p>The "$" command takes a count, like most movement commands.  But moving to
the end of the line several times doesn&#8217;t make sense.  Therefore it causes the
editor to move to the end of another line.  For example, "1$" moves you to
the end of the first line (the one you&#8217;re on), "2$" to the end of the next
line, and so on.</p>
</div>
<div class="paragraph">
<p>The "0" command doesn&#8217;t take a count argument, because the "0" would be
part of the count.  Unexpectedly, using a count with "^" doesn&#8217;t have any
effect.</p>
</div>
</div>
<div class="sect2">
<h3 id="_moving_to_a_character">Moving to a character</h3>
<div class="paragraph">
<p>One of the most useful movement commands is the single-character search
command.  The command "fx" searches forward in the line for the single
character x.  Hint: "f" stands for "Find".</p>
</div>
<div class="paragraph">
<p>For example, you are at the beginning of the following line.  Suppose you
want to go to the h of human.  Just execute the command "fh" and the cursor
will be positioned over the h:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>To err is human.  To really foul up you need a computer.
----------&gt;---------------&gt;
    fh           fy</pre>
</div>
</div>
<div class="paragraph">
<p>This also shows that the command "fy" moves to the end of the word really.</p>
</div>
<div class="paragraph">
<p>You can specify a count; therefore, you can go to the "l" of "foul" with
"3fl":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>To err is human.  To really foul up you need a computer.
          ---------------------&gt;
                   3fl</pre>
</div>
</div>
<div class="paragraph">
<p>The "F" command searches to the left:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>To err is human.  To really foul up you need a computer.
          &lt;---------------------
                    Fh</pre>
</div>
</div>
<div class="paragraph">
<p>The "tx" command works like the "fx" command, except it stops one character
before the searched character.  Hint: "t" stands for "To".  The backward
version of this command is "Tx".</p>
</div>
<div class="literalblock">
<div class="content">
<pre>To err is human.  To really foul up you need a computer.
           &lt;------------  -------------&gt;
                Th              tn</pre>
</div>
</div>
<div class="paragraph">
<p>These four commands can be repeated with ";".  "," repeats in the other
direction.  The cursor is never moved to another line.  Not even when the
sentence continues.</p>
</div>
<div class="paragraph">
<p>Sometimes you will start a search, only to realize that you have typed the
wrong command.  You type "f" to search backward, for example, only to realize
that you really meant "F".  To abort a search, press &lt;Esc&gt;.  So "f&lt;Esc&gt;" is an
aborted forward search and doesn&#8217;t do anything.  Note: &lt;Esc&gt; cancels most
operations, not just searches.</p>
</div>
</div>
<div class="sect2">
<h3 id="_matching_a_parenthesis">Matching a parenthesis</h3>
<div class="paragraph">
<p>When writing a program you often end up with nested () constructs.  Then the
"%" command is very handy: It moves to the matching paren.  If the cursor is
on a "(" it will move to the matching ")".  If it&#8217;s on a ")" it will move to
the matching "(".</p>
</div>
<div class="literalblock">
<div class="content">
<pre>            %
         &lt;-----&gt;
if (a == (b * c) / d)
   &lt;----------------&gt;
            %</pre>
</div>
</div>
<div class="paragraph">
<p>This also works for [] and {} pairs.  (This can be defined with the
'matchpairs' option.)</p>
</div>
<div class="paragraph">
<p>When the cursor is not on a useful character, "%" will search forward to find
one.  Thus if the cursor is at the start of the line of the previous example,
"%" will search forward and find the first "(".  Then it moves to its match:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if (a == (b * c) / d)
---+----------------&gt;
           %</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_moving_to_a_specific_line">Moving to a specific line</h3>
<div class="paragraph">
<p>If you are a C or C++ programmer, you are familiar with error messages such as
the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>prog.c:33: j   undeclared (first use in this function)</pre>
</div>
</div>
<div class="paragraph">
<p>This tells you that you might want to fix something on line 33.  So how do you
find line 33?  One way is to do "9999k" to go to the top of the file and "32j"
to go down thirty-two lines.  It is not a good way, but it works.  A much
better way of doing things is to use the "G" command.  With a count, this
command positions you at the given line number.  For example, "33G" puts you
on line 33.  (For a better way of going through a compiler&#8217;s error list, see
|usr_30.txt|, for information on the :make command.)</p>
</div>
<div class="paragraph">
<p>With no argument, "G" positions you at the end of the file.  A quick way to
go to the start of a file use "gg".  "1G" will do the same, but is a tiny bit
more typing.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    |   first line of a file   ^
    |   text text text text    |
    |   text text text text    |  gg
7G  |   text text text text    |
    |   text text text text
    |   text text text text
    V   text text text text    |
        text text text text    |  G
        text text text text    |
        last line of a file    V</pre>
</div>
</div>
<div class="paragraph">
<p>Another way to move to a line is using the "%" command with a count.  For
example "50%" moves you to halfway the file.  "90%" goes to near the end.</p>
</div>
<div class="paragraph">
<p>The previous assumes that you want to move to a line in the file, no matter if
it&#8217;s currently visible or not.  What if you want to move to one of the lines
you can see?  This figure shows the three commands you can use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        +---------------------------+
H --&gt;   | text sample text          |
        | sample text               |
        | text sample text          |
        | sample text               |
M --&gt;   | text sample text          |
        | sample text               |
        | text sample text          |
        | sample text               |
L --&gt;   | text sample text          |
        +---------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>Hints: "H" stands for Home, "M" for Middle and "L" for Last.  Alternatively,
"H" for high, "M" for Middle and "L" for low.</p>
</div>
</div>
<div class="sect2">
<h3 id="_telling_where_you_are">Telling where you are</h3>
<div class="paragraph">
<p>To see where you are in a file, there are three ways:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use the CTRL-G command.  You get a message like this (assuming the 'ruler'
option is off):</p>
<div class="literalblock">
<div class="content">
<pre>"usr_03.txt" line 233 of 650 --35%-- col 45-52</pre>
</div>
</div>
<div class="paragraph">
<p>This shows the name of the file you are editing, the line number where the
cursor is, the total number of lines, the percentage of the way through
the file and the column of the cursor.</p>
</div>
<div class="paragraph">
<p>Sometimes you will see a split column number.  For example, "col 2-9". This
indicates that the cursor is positioned on the second character, but because
character one is a tab, occupying eight spaces worth of columns, the screen
column is 9.</p>
</div>
</li>
<li>
<p>Set the 'number' option.  This will display a line number in front of
every line:</p>
<div class="literalblock">
<div class="content">
<pre>:set number</pre>
</div>
</div>
<div class="paragraph">
<p>To switch this off again:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set nonumber</pre>
</div>
</div>
<div class="paragraph">
<p>Since 'number' is a boolean option, prepending "no" to its name has the effect
of switching it off.  A boolean option has only these two values, it is either
on or off.</p>
</div>
<div class="paragraph">
<p>Vim has many options.  Besides the boolean ones there are options with a
numerical value and string options.  You will see examples of this where they
are used.</p>
</div>
</li>
<li>
<p>Set the 'ruler' option.  This will display the cursor position in the
lower right corner of the Vim window:</p>
<div class="literalblock">
<div class="content">
<pre>:set ruler</pre>
</div>
</div>
<div class="paragraph">
<p>Using the 'ruler' option has the advantage that it doesn&#8217;t take much room,
thus there is more space for your text.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_scrolling_around">Scrolling around</h3>
<div class="paragraph">
<p>The CTRL-U command scrolls down half a screen of text.  Think of looking
through a viewing window at the text and moving this window up by half the
height of the window.  Thus the window moves up over the text, which is
backward in the file.  Don&#8217;t worry if you have a little trouble remembering
which end is up.  Most users have the same problem.</p>
</div>
<div class="paragraph">
<p>The CTRL-D command moves the viewing window down half a screen in the file,
thus scrolls the text up half a screen.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>                               +----------------+
                               | some text      |
                               | some text      |
                               | some text      |
+---------------+              | some text      |
| some text     |  CTRL-U  --&gt; |                |
|               |              | 123456         |
| 123456        |              +----------------+
| 7890          |
|               |              +----------------+
| example       |  CTRL-D --&gt;  | 7890           |
+---------------+              |                |
                               | example        |
                               | example        |
                               | example        |
                               | example        |
                               +----------------+</pre>
</div>
</div>
<div class="paragraph">
<p>To scroll one line at a time use CTRL-E (scroll up) and CTRL-Y (scroll down).
Think of CTRL-E to give you one line Extra.  (If you use MS-Windows compatible
key mappings CTRL-Y will redo a change instead of scroll.)</p>
</div>
<div class="paragraph">
<p>To scroll forward by a whole screen (except for two lines) use CTRL-F.  To
scroll backwards, use CTRL-B.  These should be easy to remember: F for
Forwards and B for Backwards.</p>
</div>
<div class="paragraph">
<p>A common issue is that after moving down many lines with "j" your cursor is at
the bottom of the screen.  You would like to see the context of the line with
the cursor.  That&#8217;s done with the "zz" command.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+------------------+             +------------------+
| earlier text     |             | earlier text     |
| earlier text     |             | earlier text     |
| earlier text     |             | earlier text     |
| earlier text     |   zz  --&gt;   | line with cursor |
| earlier text     |             | later text       |
| earlier text     |             | later text       |
| line with cursor |             | later text       |
+------------------+             +------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>The "zt" command puts the cursor line at the top, "zb" at the bottom.  There
are a few more scrolling commands, see |Q_sc|.  To always keep a few lines of
context around the cursor, use the 'scrolloff' option.</p>
</div>
</div>
<div class="sect2">
<h3 id="_simple_searches">Simple searches</h3>
<div class="paragraph">
<p>To search for a string, use the "/string" command.  To find the word include,
for example, use the command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/include</pre>
</div>
</div>
<div class="paragraph">
<p>You will notice that when you type the "/" the cursor jumps to the last line
of the Vim window, like with colon commands.  That is where you type the word.
You can press the backspace key (backarrow or &lt;BS&gt;) to make corrections.  Use
the &lt;Left&gt; and &lt;Right&gt; cursor keys when necessary.</p>
</div>
<div class="paragraph">
<p>Pressing &lt;Enter&gt; executes the command.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The characters .*[]^%/\?~$ have special meanings.  If you want to use
them in a search you must put a \ in front of them.  See below.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To find the next occurrence of the same string use the "n" command.  Use this
to find the first #include after the cursor:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/#include</pre>
</div>
</div>
<div class="paragraph">
<p>And then type "n" several times.  You will move to each #include in the text.
You can also use a count if you know which match you want.  Thus "3n" finds
the third match.  You can also use a count with "/": "4/the" goes to the
fourth match of "the".</p>
</div>
<div class="paragraph">
<p>The "?" command works like "/" but searches backwards:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>?word</pre>
</div>
</div>
<div class="paragraph">
<p>The "N" command repeats the last search the opposite direction.  Thus using
"N" after a "/" command searches backwards, using "N" after "?" searches
forwards.</p>
</div>
<div class="sect3">
<h4 id="_ignoring_case">IGNORING CASE</h4>
<div class="paragraph">
<p>Normally you have to type exactly what you want to find.  If you don&#8217;t care
about upper or lowercase in a word, set the 'ignorecase' option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set ignorecase</pre>
</div>
</div>
<div class="paragraph">
<p>If you now search for "word", it will also match "Word" and "WORD".  To match
case again:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set noignorecase</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_history">HISTORY</h4>
<div class="paragraph">
<p>Suppose you do three searches:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/one
/two
/three</pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s start searching by typing a simple "/" without pressing &lt;Enter&gt;.  If
you press &lt;Up&gt; (the cursor key), Vim puts "/three" on the command line.
Pressing &lt;Enter&gt; at this point searches for three.  If you do not press
&lt;Enter&gt;, but press &lt;Up&gt; instead, Vim changes the prompt to "/two".  Another
press of &lt;Up&gt; moves you to "/one".</p>
</div>
<div class="paragraph">
<p>You can also use the &lt;Down&gt; cursor key to move through the history of
search commands in the other direction.</p>
</div>
<div class="paragraph">
<p>If you know what a previously used pattern starts with, and you want to use it
again, type that character before pressing &lt;Up&gt;.  With the previous example,
you can type "/o&lt;Up&gt;" and Vim will put "/one" on the command line.</p>
</div>
<div class="paragraph">
<p>The commands starting with ":" also have a history.  That allows you to recall
a previous command and execute it again.  These two histories are separate.</p>
</div>
</div>
<div class="sect3">
<h4 id="_searching_for_a_word_in_the_text">SEARCHING FOR A WORD IN THE TEXT</h4>
<div class="paragraph">
<p>Suppose you see the word "TheLongFunctionName" in the text and you want to
find the next occurrence of it.  You could type "/TheLongFunctionName", but
that&#8217;s a lot of typing.  And when you make a mistake Vim won&#8217;t find it.</p>
</div>
<div class="paragraph">
<p>There is an easier way: Position the cursor on the word and use the "*"
command.  Vim will grab the word under the cursor and use it as the search
string.</p>
</div>
<div class="paragraph">
<p>The "#" command does the same in the other direction.  You can prepend a
count: "3*" searches for the third occurrence of the word under the cursor.</p>
</div>
</div>
<div class="sect3">
<h4 id="_searching_for_whole_words">SEARCHING FOR WHOLE WORDS</h4>
<div class="paragraph">
<p>If you type "/the" it will also match "there".  To only find words that end
in "the" use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/the\&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The "\&gt;" item is a special marker that only matches at the end of a word.
Similarly "\&lt;" only matches at the beginning of a word.  Thus to search for
the word "the" only:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/\&lt;the\&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>This does not match "there" or "soothe".  Notice that the "<strong>" and "<mark>" commands
use these start-of-word and end-of-word markers to only find whole words (you
can use "g</strong>" and "g</mark>" to match partial words).</p>
</div>
</div>
<div class="sect3">
<h4 id="_highlighting_matches">HIGHLIGHTING MATCHES</h4>
<div class="paragraph">
<p>While editing a program you see a variable called "nr".  You want to check
where it&#8217;s used.  You could move the cursor to "nr" and use the "*" command
and press "n" to go along all the matches.</p>
</div>
<div class="paragraph">
<p>There is another way.  Type this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set hlsearch</pre>
</div>
</div>
<div class="paragraph">
<p>If you now search for "nr", Vim will highlight all matches.  That is a very
good way to see where the variable is used, without the need to type commands.</p>
</div>
<div class="paragraph">
<p>To switch this off:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set nohlsearch</pre>
</div>
</div>
<div class="paragraph">
<p>Then you need to switch it on again if you want to use it for the next search
command.  If you only want to remove the highlighting, use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:nohlsearch</pre>
</div>
</div>
<div class="paragraph">
<p>This doesn&#8217;t reset the option.  Instead, it disables the highlighting.  As
soon as you execute a search command, the highlighting will be used again.
Also for the "n" and "N" commands.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tuning_searches">TUNING SEARCHES</h4>
<div class="paragraph">
<p>There are a few options that change how searching works.  These are the
essential ones:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set incsearch</pre>
</div>
</div>
<div class="paragraph">
<p>This makes Vim display the match for the string while you are still typing it.
Use this to check if the right match will be found.  Then press &lt;Enter&gt; to
really jump to that location.  Or type more to change the search string.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set nowrapscan</pre>
</div>
</div>
<div class="paragraph">
<p>This stops the search at the end of the file.  Or, when you are searching
backwards, it stops the search at the start of the file.  The 'wrapscan'
option is on by default, thus searching wraps around the end of the file.</p>
</div>
</div>
<div class="sect3">
<h4 id="_intermezzo">INTERMEZZO</h4>
<div class="paragraph">
<p>If you like one of the options mentioned before, and set it each time you use
Vim, you can put the command in your Vim startup file.</p>
</div>
<div class="paragraph">
<p>Edit the file, as mentioned at |not-compatible|.  Or use this command to
find out where it is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:scriptnames</pre>
</div>
</div>
<div class="paragraph">
<p>Edit the file, for example with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit ~/.vimrc</pre>
</div>
</div>
<div class="paragraph">
<p>Then add a line with the command to set the option, just like you typed it in
Vim.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Go:set hlsearch&lt;Esc&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>"G" moves to the end of the file.  "o" starts a new line, where you type the
":set" command.  You end insert mode with &lt;Esc&gt;.  Then write and close the
file:</p>
</div>
</div>
<div class="sect3">
<h4 id="_zz">ZZ</h4>
<div class="paragraph">
<p>If you now start Vim again, the 'hlsearch' option will already be set.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_simple_search_patterns">Simple search patterns</h3>
<div class="paragraph">
<p>The Vim editor uses regular expressions to specify what to search for.
Regular expressions are an extremely powerful and compact way to specify a
search pattern.  Unfortunately, this power comes at a price, because regular
expressions are a bit tricky to specify.</p>
</div>
<div class="paragraph">
<p>In this section we mention only a few essential ones.  More about search
patterns and commands can be found in chapter 27 |usr_27.txt|.  You can find
the full explanation here: |pattern|.</p>
</div>
<div class="sect3">
<h4 id="_beginning_and_end_of_a_line">BEGINNING AND END OF A LINE</h4>
<div class="paragraph">
<p>The ^ character matches the beginning of a line.  On an English-US keyboard
you find it above the 6.  The pattern "include" matches the word include
anywhere on the line.  But the pattern "^include" matches the word include
only if it is at the beginning of a line.</p>
</div>
<div class="paragraph">
<p>The $ character matches the end of a line.  Therefore, "was$" matches the
word was only if it is at the end of a line.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s mark the places where "/the" matches in this example line with "x"s:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>the solder holding one of the chips melted and the
xxx                       xxx                  xxx</pre>
</div>
</div>
<div class="paragraph">
<p>Using "/the$" we find this match:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>the solder holding one of the chips melted and the
                                               xxx</pre>
</div>
</div>
<div class="paragraph">
<p>And with "/^the" we find this one:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>the solder holding one of the chips melted and the
xxx</pre>
</div>
</div>
<div class="paragraph">
<p>You can try searching with "/^the$"; it will only match a single line
consisting entirely of "the".  White space does matter here, thus if a line
contains a space after the word, like "the ", the pattern will not match.</p>
</div>
</div>
<div class="sect3">
<h4 id="_matching_any_single_character">MATCHING ANY SINGLE CHARACTER</h4>
<div class="paragraph">
<p>The . (dot) character matches any existing character.  For example, the
pattern "c.m" matches a string whose first character is a c, whose second
character is anything, and whose third character is m.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>We use a computer that became the cummin winter.
         xxx             xxx      xxx</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_matching_special_characters">MATCHING SPECIAL CHARACTERS</h4>
<div class="paragraph">
<p>If you really want to match a dot, you must avoid its special meaning by
putting a backslash before it.</p>
</div>
<div class="paragraph">
<p>If you search for "ter.", you will find these matches:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>We use a computer that became the cummin winter.
              xxxx                          xxxx</pre>
</div>
</div>
<div class="paragraph">
<p>Searching for "ter\." only finds the second match.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_marks">Using marks</h3>
<div class="paragraph">
<p>When you make a jump to a position with the "G" command, Vim remembers the
position from before this jump.  This position is called a mark.  To go back
where you came from, use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>``</pre>
</div>
</div>
<div class="paragraph">
<p>This ` is a backtick or open single-quote character.</p>
</div>
<div class="paragraph">
<p>If you use the same command a second time you will jump back again.  That&#8217;s
because the "`" command is a jump itself, and the position from before this
jump is remembered.</p>
</div>
<div class="paragraph">
<p>Generally, every time you do a command that can move the cursor further than
within the same line, this is called a jump.  This includes the search
commands "/" and "n" (it doesn&#8217;t matter how far away the match is).  But not
the character searches with "fx" and "tx" or the word movements "w" and "e".</p>
</div>
<div class="paragraph">
<p>Also, "j" and "k" are not considered to be a jump, even when you use a
count to make them move the cursor quite a long way away.</p>
</div>
<div class="paragraph">
<p>The "``" command jumps back and forth, between two points.  The CTRL-O command
jumps to older positions (Hint: O for older).  CTRL-I then jumps back to newer
positions (Hint: for many common keyboard layouts, I is just next to O).
Consider this sequence of commands:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>33G
/^The
CTRL-O</pre>
</div>
</div>
<div class="paragraph">
<p>You first jump to line 33, then search for a line that starts with "The".
Then with CTRL-O you jump back to line 33.  Another CTRL-O takes you back to
where you started.  If you now use CTRL-I you jump to line 33 again.  And
to the match for "The" with another CTRL-I.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>      |  example text   ^             |
 33G  |  example text   |  CTRL-O     | CTRL-I
      |  example text   |             |
      V  line 33 text   ^             V
      |  example text   |             |
/^The |  example text   |  CTRL-O     | CTRL-I
      V  There you are  |             V
         example text</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
CTRL-I is the same as &lt;Tab&gt;.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The ":jumps" command gives a list of positions you jumped to.  The entry which
you used last is marked with a "&gt;".</p>
</div>
<div class="sect3">
<h4 id="_named_marks">NAMED MARKS</h4>
<div class="paragraph">
<p>Vim enables you to place your own marks in the text.  The command "ma" marks
the place under the cursor as mark a.  You can place 26 marks (a through z) in
your text.  You can&#8217;t see them, it&#8217;s just a position that Vim remembers.</p>
</div>
<div class="paragraph">
<p>To go to a mark, use the command `{mark}, where {mark} is the mark letter.
Thus to move to the a mark:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`a</pre>
</div>
</div>
<div class="paragraph">
<p>The command "'mark" (single quotation mark, or apostrophe) moves you to the
beginning of the line containing the mark.  This differs from the "`mark"
command, which also moves you to the marked column.</p>
</div>
<div class="paragraph">
<p>The marks can be very useful when working on two related parts in a file.
Suppose you have some text near the start of the file you need to look at,
while working on some text near the end of the file.</p>
</div>
<div class="paragraph">
<p>Move to the text at the start and place the s (start) mark there:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ms</pre>
</div>
</div>
<div class="paragraph">
<p>Then move to the text you want to work on and put the e (end) mark there:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>me</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can move around, and when you want to look at the start of the file,
you use this to jump there:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>'s</pre>
</div>
</div>
<div class="paragraph">
<p>Then you can use '' to jump back to where you were, or 'e to jump to the text
you were working on at the end.</p>
</div>
<div class="paragraph">
<p>There is nothing special about using s for start and e for end, they are
just easy to remember.</p>
</div>
<div class="paragraph">
<p>You can use this command to get a list of marks:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:marks</pre>
</div>
</div>
<div class="paragraph">
<p>You will notice a few special marks.  These include:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">'</dt>
<dd>
<p>The cursor position before doing a jump</p>
</dd>
<dt class="hdlist1">"</dt>
<dd>
<p>The cursor position when last editing the file</p>
</dd>
<dt class="hdlist1">[</dt>
<dd>
<p>Start of the last change</p>
</dd>
<dt class="hdlist1">]</dt>
<dd>
<p>End of the last change</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Next chapter: |usr_04.txt|  Making small changes</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_making_small_changes">Making small changes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter shows you several ways of making corrections and moving text
around.  It teaches you the three basic ways to change text: operator-motion,
Visual mode and text objects.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Operators and motions</p>
</li>
<li>
<p>Changing text</p>
</li>
<li>
<p>Repeating a change</p>
</li>
<li>
<p>Visual mode</p>
</li>
<li>
<p>Moving text</p>
</li>
<li>
<p>Copying text</p>
</li>
<li>
<p>Using the clipboard</p>
</li>
<li>
<p>Text objects</p>
</li>
<li>
<p>Replace mode</p>
</li>
<li>
<p>Conclusion</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_operators_and_motions">Operators and motions</h3>
<div class="paragraph">
<p>In chapter 2 you learned the "x" command to delete a single character.  And
using a count: "4x" deletes four characters.
   The "dw" command deletes a word.  You may recognize the "w" command as the
move word command.  In fact, the "d" command may be followed by any motion
command, and it deletes from the current location to the place where the
cursor winds up.
   The "4w" command, for example, moves the cursor over four words.  The "d4w"
command deletes four words.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>To err is human. To really foul up you need a computer.
                 ------------------&gt;
                         d4w</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>To err is human. you need a computer.</pre>
</div>
</div>
<div class="paragraph">
<p>Vim only deletes up to the position where the motion takes the cursor.  That&#8217;s
because Vim knows that you probably don&#8217;t want to delete the first character
of a word.  If you use the "e" command to move to the end of a word, Vim
guesses that you do want to include that last character:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>To err is human. you need a computer.
                --------&gt;
                   d2e</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>To err is human. a computer.</pre>
</div>
</div>
<div class="paragraph">
<p>Whether the character under the cursor is included depends on the command you
used to move to that character.  The reference manual calls this "exclusive"
when the character isn&#8217;t included and "inclusive" when it is.</p>
</div>
<div class="paragraph">
<p>The "$" command moves to the end of a line.  The "d$" command deletes from the
cursor to the end of the line.  This is an inclusive motion, thus the last
character of the line is included in the delete operation:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>To err is human. a computer.
               ------------&gt;
                    d$</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>To err is human</pre>
</div>
</div>
<div class="paragraph">
<p>There is a pattern here: operator-motion.  You first type an operator command.
For example, "d" is the delete operator.  Then you type a motion command like
"4l" or "w".  This way you can operate on any text you can move over.</p>
</div>
</div>
<div class="sect2">
<h3 id="_changing_text">Changing text</h3>
<div class="paragraph">
<p>Another operator is "c", change.  It acts just like the "d" operator, except
it leaves you in Insert mode.  For example, "cw" changes a word.  Or more
specifically, it deletes a word and then puts you in Insert mode.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>To err is human
   -------&gt;
     c2wbe&lt;Esc&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>To be human</pre>
</div>
</div>
<div class="paragraph">
<p>This "c2wbe&lt;Esc&gt;" contains these bits:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>c       the change operator
2w      move two words (they are deleted and Insert mode started)
be      insert this text
&lt;Esc&gt;   back to Normal mode</pre>
</div>
</div>
<div class="paragraph">
<p>You will have noticed something strange: The space before "human" isn&#8217;t
deleted.  There is a saying that for every problem there is an answer that is
simple, clear, and wrong.  That is the case with the example used here for the
"cw" command.  The c operator works just like the d operator, with one
exception: "cw".  It actually works like "ce", change to end of word.  Thus
the space after the word isn&#8217;t included.  This is an exception that dates back
to the old Vi.  Since many people are used to it now, the inconsistency has
remained in Vim.</p>
</div>
<div class="sect3">
<h4 id="_more_changes">MORE CHANGES</h4>
<div class="paragraph">
<p>Like "dd" deletes a whole line, "cc" changes a whole line.  It keeps the
existing indent (leading white space) though.</p>
</div>
<div class="paragraph">
<p>Just like "d$" deletes until the end of the line, "c$" changes until the end
of the line.  It&#8217;s like doing "d$" to delete the text and then "a" to start
Insert mode and append new text.</p>
</div>
</div>
<div class="sect3">
<h4 id="_shortcuts">SHORTCUTS</h4>
<div class="paragraph">
<p>Some operator-motion commands are used so often that they have been given a
single-letter command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>x  stands for  dl  (delete character under the cursor)
X  stands for  dh  (delete character left of the cursor)
D  stands for  d$  (delete to end of the line)
C  stands for  c$  (change to end of the line)
s  stands for  cl  (change one character)
S  stands for  cc  (change a whole line)</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_where_to_put_the_count">WHERE TO PUT THE COUNT</h4>
<div class="paragraph">
<p>The commands "3dw" and "d3w" delete three words.  If you want to get really
picky about things, the first command, "3dw", deletes one word three times;
the command "d3w" deletes three words once.  This is a difference without a
distinction.  You can actually put in two counts, however.  For example,
"3d2w" deletes two words, repeated three times, for a total of six words.</p>
</div>
</div>
<div class="sect3">
<h4 id="_replacing_with_one_character">REPLACING WITH ONE CHARACTER</h4>
<div class="paragraph">
<p>The "r" command is not an operator.  It waits for you to type a character, and
will replace the character under the cursor with it.  You could do the same
with "cl" or with the "s" command, but with "r" you don&#8217;t have to press &lt;Esc&gt;
to get back out of insert mode.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>there is somerhing grong here
rT           rt    rw</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>There is something wrong here</pre>
</div>
</div>
<div class="paragraph">
<p>Using a count with "r" causes that many characters to be replaced with the
same character.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>There is something wrong here
                   5rx</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>There is something xxxxx here</pre>
</div>
</div>
<div class="paragraph">
<p>To replace a character with a line break use "r&lt;Enter&gt;".  This deletes one
character and inserts a line break.  Using a count here only applies to the
number of characters deleted: "4r&lt;Enter&gt;" replaces four characters with one
line break.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_repeating_a_change">Repeating a change</h3>
<div class="paragraph">
<p>The "." command is one of the most simple yet powerful commands in Vim.  It
repeats the last change.  For instance, suppose you are editing an HTML file
and want to delete all the &lt;B&gt; tags.  You position the cursor on the first &lt;
and delete the &lt;B&gt; with the command "df&gt;".  You then go to the &lt; of the next
&lt;/B&gt; and delete it using the "." command.  The "." command executes the last
change command (in this case, "df&gt;").  To delete another tag, position the
cursor on the &lt; and use the "." command.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>                      To &lt;B&gt;generate&lt;/B&gt; a table of &lt;B&gt;contents
f&lt;   find first &lt;     ---&gt;
df&gt;  delete to &gt;         --&gt;
f&lt;   find next &lt;           ---------&gt;
.    repeat df&gt;                     ---&gt;
f&lt;   find next &lt;                       -------------&gt;
.    repeat df&gt;                                     --&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The "." command works for all changes you make, except for "u" (undo), CTRL-R
(redo) and commands that start with a colon (:).</p>
</div>
<div class="paragraph">
<p>Another example: You want to change the word "four" to "five".  It appears
several times in your text.  You can do this quickly with this sequence of
commands:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/four&lt;Enter&gt;    find the first string "four"
cwfive&lt;Esc&gt;     change the word to "five"
n               find the next "four"
.               repeat the change to "five"
n               find the next "four"
.               repeat the change
                etc.</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_visual_mode">Visual mode</h3>
<div class="paragraph">
<p>To delete simple items the operator-motion changes work quite well.  But often
it&#8217;s not so easy to decide which command will move over the text you want to
change.  Then you can use Visual mode.</p>
</div>
<div class="paragraph">
<p>You start Visual mode by pressing "v".  You move the cursor over the text you
want to work on.  While you do this, the text is highlighted.  Finally type
the operator command.
   For example, to delete from the middle of one word to the middle of another
word:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>This is an examination sample of visual mode
               ----------&gt;
                 velllld</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>This is an example of visual mode</pre>
</div>
</div>
<div class="paragraph">
<p>When doing this you don&#8217;t really have to count how many times you have to
press "l" to end up in the right position.  You can immediately see what text
will be deleted when you press "d".</p>
</div>
<div class="paragraph">
<p>If at any time you decide you don&#8217;t want to do anything with the highlighted
text, just press &lt;Esc&gt; and Visual mode will stop without doing anything.</p>
</div>
<div class="sect3">
<h4 id="_selecting_lines">SELECTING LINES</h4>
<div class="paragraph">
<p>If you want to work on whole lines, use "V" to start Visual mode.  You will
see right away that the whole line is highlighted, without moving around.
When you move left or right nothing changes.  When you move up or down the
selection is extended whole lines at a time.
   For example, select three lines with "Vjj":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>                  +------------------------+
                  | text more text         |
               &gt;&gt; | more text more text    | |
selected lines &gt;&gt; | text text text         | | Vjj
               &gt;&gt; | text more              | V
                  | more text more         |
                  +------------------------+</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_selecting_blocks">SELECTING BLOCKS</h4>
<div class="paragraph">
<p>If you want to work on a rectangular block of characters, use CTRL-V to start
Visual mode.  This is very useful when working on tables.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>name            Q1      Q2      Q3
pierre          123     455     234
john            0       90      39
steve           392     63      334</pre>
</div>
</div>
<div class="paragraph">
<p>To delete the middle "Q2" column, move the cursor to the "Q" of "Q2".  Press
CTRL-V to start blockwise Visual mode.  Now move the cursor three lines down
with "3j" and to the next word with "w".  You can see the first character of
the last column is included.  To exclude it, use "h".  Now press "d" and the
middle column is gone.</p>
</div>
</div>
<div class="sect3">
<h4 id="_going_to_the_other_side">GOING TO THE OTHER SIDE</h4>
<div class="paragraph">
<p>If you have selected some text in Visual mode, and discover that you need to
change the other end of the selection, use the "o" command (Hint: o for other
end).  The cursor will go to the other end, and you can move the cursor to
change where the selection starts.  Pressing "o" again brings you back to the
other end.</p>
</div>
<div class="paragraph">
<p>When using blockwise selection, you have four corners.  "o" only takes you to
one of the other corners, diagonally.  Use "O" to move to the other corner in
the same line.</p>
</div>
<div class="paragraph">
<p>Note that "o" and "O" in Visual mode work very differently from Normal mode,
where they open a new line below or above the cursor.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_moving_text">Moving text</h3>
<div class="paragraph">
<p>When you delete something with "d", "x", or another command, the text is
saved.  You can paste it back by using the "p" command.  (The Vim name for
this is put).
   Take a look at how this works.  First you will delete an entire line, by
putting the cursor on the line you want to delete and typing "dd".  Now you
move the cursor to where you want to put the line and use the "p" (put)
command.  The line is inserted on the line below the cursor.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>a line          a line        a line
line 2    dd    line 3    p   line 3
line 3                        line 2</pre>
</div>
</div>
<div class="paragraph">
<p>Because you deleted an entire line, the "p" command placed the text line below
the cursor.  If you delete part of a line (a word, for instance), the "p"
command puts it just after the cursor.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Some more boring try text to out commands.
                 ----&gt;
                  dw</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Some more boring text to out commands.
                 -------&gt;
                    welp</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Some more boring text to try out commands.</pre>
</div>
</div>
<div class="sect3">
<h4 id="_more_on_putting">MORE ON PUTTING</h4>
<div class="paragraph">
<p>The "P" command puts text like "p", but before the cursor.  When you deleted a
whole line with "dd", "P" will put it back above the cursor.  When you deleted
a word with "dw", "P" will put it back just before the cursor.</p>
</div>
<div class="paragraph">
<p>You can repeat putting as many times as you like.  The same text will be used.</p>
</div>
<div class="paragraph">
<p>You can use a count with "p" and "P".  The text will be repeated as many times
as specified with the count.  Thus "dd" and then "3p" puts three copies of the
same deleted line.</p>
</div>
</div>
<div class="sect3">
<h4 id="_swapping_two_characters">SWAPPING TWO CHARACTERS</h4>
<div class="paragraph">
<p>Frequently when you are typing, your fingers get ahead of your brain (or the
other way around?).  The result is a typo such as "teh" for "the".  Vim
makes it easy to correct such problems.  Just put the cursor on the e of "teh"
and execute the command "xp".  This works as follows: "x" deletes the
character e and places it in a register.  "p" puts the text after the cursor,
which is after the h.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>teh     th     the
 x       p</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_copying_text">Copying text</h3>
<div class="paragraph">
<p>To copy text from one place to another, you could delete it, use "u" to undo
the deletion and then "p" to put it somewhere else.  There is an easier way:
yanking.  The "y" operator copies text into a register.  Then a "p" command
can be used to put it.
   Yanking is just a Vim name for copying.  The "c" letter was already used
for the change operator, and "y" was still available.  Calling this
operator "yank" made it easier to remember to use the "y" key.</p>
</div>
<div class="paragraph">
<p>Since "y" is an operator, you use "yw" to yank a word.  A count is possible as
usual.  To yank two words use "y2w".  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>let sqr = LongVariable *
         --------------&gt;
               y2w</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>let sqr = LongVariable *
                       p</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>let sqr = LongVariable * LongVariable</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that "yw" includes the white space after a word.  If you don&#8217;t want
this, use "ye".</p>
</div>
<div class="paragraph">
<p>The "yy" command yanks a whole line, just like "dd" deletes a whole line.
Unexpectedly, while "D" deletes from the cursor to the end of the line, "Y"
works like "yy", it yanks the whole line.  Watch out for this inconsistency!
Use "y$" to yank to the end of the line.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>a text line   yy        a text line            a text line
line 2                  line 2          p      line 2
last line               last line              a text line
                                               last line</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_clipboard">Using the clipboard</h3>
<div class="paragraph">
<p>If you are using the GUI version of Vim (gvim), you can find the "Copy" item
in the "Edit" menu.  First select some text with Visual mode, then use the
Edit/Copy menu item.  The selected text is now copied to the clipboard.  You
can paste the text in other programs.  In Vim itself too.</p>
</div>
<div class="paragraph">
<p>If you have copied text to the clipboard in another application, you can paste
it in Vim with the Edit/Paste menu item.  This works in Normal mode and Insert
mode.  In Visual mode the selected text is replaced with the pasted text.</p>
</div>
<div class="paragraph">
<p>The "Cut" menu item deletes the text before it&#8217;s put on the clipboard.  The
"Copy", "Cut" and "Paste" items are also available in the popup menu (only
when there is a popup menu, of course).  If your Vim has a toolbar, you can
also find these items there.</p>
</div>
<div class="paragraph">
<p>If you are not using the GUI, or if you don&#8217;t like using a menu, you have to
use another way.  You use the normal "y" (yank) and "p" (put) commands, but
prepend "* (double-quote star) before it.  To copy a line to the clipboard:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"*yy</pre>
</div>
</div>
<div class="paragraph">
<p>To put text from the clipboard back into the text:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"*p</pre>
</div>
</div>
<div class="paragraph">
<p>This only works on versions of Vim that include clipboard support.  More about
the clipboard can be found in section |09.3| and here: |clipboard|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_text_objects">Text objects</h3>
<div class="paragraph">
<p>If the cursor is in the middle of a word and you want to delete that word, you
need to move back to its start before you can do "dw".  There is a simpler way
to do this: "daw".</p>
</div>
<div class="literalblock">
<div class="content">
<pre>this is some example text.
               daw</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>this is some text.</pre>
</div>
</div>
<div class="paragraph">
<p>The "d" of "daw" is the delete operator.  "aw" is a text object.  Hint: "aw"
stands for "A Word".  Thus "daw" is "Delete A Word".  To be precise, the white
space after the word is also deleted (or the white space before the word if at
the end of the line).</p>
</div>
<div class="paragraph">
<p>Using text objects is the third way to make changes in Vim.  We already had
operator-motion and Visual mode.  Now we add operator-text object.
   It is very similar to operator-motion, but instead of operating on the text
between the cursor position before and after a movement command, the text
object is used as a whole.  It doesn&#8217;t matter where in the object the cursor
was.</p>
</div>
<div class="paragraph">
<p>To change a whole sentence use "cis".  Take this text:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Hello there.  This
is an example.  Just
some text.</pre>
</div>
</div>
<div class="paragraph">
<p>Move to the start of the second line, on "is an".  Now use "cis":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Hello there.    Just
some text.</pre>
</div>
</div>
<div class="paragraph">
<p>The cursor is in between the blanks in the first line.  Now you type the new
sentence "Another line.":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Hello there.  Another line.  Just
some text.</pre>
</div>
</div>
<div class="paragraph">
<p>"cis" consists of the "c" (change) operator and the "is" text object.  This
stands for "Inner Sentence".  There is also the "as" ("A Sentence") object.
The difference is that "as" includes the white space after the sentence and
"is" doesn&#8217;t.  If you would delete a sentence, you want to delete the white
space at the same time, thus use "das".  If you want to type new text the
white space can remain, thus you use "cis".</p>
</div>
<div class="paragraph">
<p>You can also use text objects in Visual mode.  It will include the text object
in the Visual selection.  Visual mode continues, thus you can do this several
times.  For example, start Visual mode with "v" and select a sentence with
"as".  Now you can repeat "as" to include more sentences.  Finally you use an
operator to do something with the selected sentences.</p>
</div>
<div class="paragraph">
<p>You can find a long list of text objects here: |text-objects|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_replace_mode">Replace mode</h3>
<div class="paragraph">
<p>The "R" command causes Vim to enter replace mode.  In this mode, each
character you type replaces the one under the cursor.  This continues until
you type &lt;Esc&gt;.
   In this example you start Replace mode on the first "t" of "text":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>This is text.
        Rinteresting.&lt;Esc&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>This is interesting.</pre>
</div>
</div>
<div class="paragraph">
<p>You may have noticed that this command replaced 5 characters in the line with
twelve others.  The "R" command automatically extends the line if it runs out
of characters to replace.  It will not continue on the next line.</p>
</div>
<div class="paragraph">
<p>You can switch between Insert mode and Replace mode with the &lt;Insert&gt; key.</p>
</div>
<div class="paragraph">
<p>When you use &lt;BS&gt; (backspace) to make correction, you will notice that the
old text is put back.  Thus it works like an undo command for the last typed
character.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion">Conclusion</h3>
<div class="paragraph">
<p>The operators, movement commands and text objects give you the possibility to
make lots of combinations.  Now that you know how they work, you can use N
operators with M movement commands to make N * M commands!</p>
</div>
<div class="paragraph">
<p>You can find a list of operators here: |operator|.</p>
</div>
<div class="paragraph">
<p>For example, there are many other ways to delete pieces of text.  Here are a
few common ones:</p>
</div>
<div class="paragraph">
<p>x       delete character under the cursor (short for "dl")
X       delete character before the cursor (short for "dh")
D       delete from cursor to end of line (short for "d$")
dw      delete from cursor to next start of word
db      delete from cursor to previous start of word
diw     delete word under the cursor (excluding white space)
daw     delete word under the cursor (including white space)
dG      delete until the end of the file
dgg     delete until the start of the file</p>
</div>
<div class="paragraph">
<p>If you use "c" instead of "d" they become change commands.  And with "y" you
yank the text.  And so forth.</p>
</div>
<div class="paragraph">
<p>There are a few common commands to make changes that didn&#8217;t fit somewhere
else:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>~       Change case of the character under the cursor, and move the
        cursor to the next character.  This is not an operator (unless
        'tildeop' is set), thus you can't use it with a motion
        command.  It does work in Visual mode, where it changes case
        for all the selected text.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>I       Start Insert mode after moving the cursor to the first
        non-blank in the line.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>A       Start Insert mode after moving the cursor to the end of the
        line.</pre>
</div>
</div>
<div class="paragraph">
<p>Next chapter: |usr_05.txt|  Set your settings</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_set_your_settings">Set your settings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vim can be tuned to work like you want it to.  This chapter shows you how to
make Vim start with options set to different values.  Add plugins to extend
Vim&#8217;s capabilities.  Or define your own macros.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The vimrc file</p>
</li>
<li>
<p>The example vimrc file explained
|05.3|  The defaults.vim file explained</p>
</li>
<li>
<p>Simple mappings</p>
</li>
<li>
<p>Adding a package</p>
</li>
<li>
<p>Adding a plugin</p>
</li>
<li>
<p>Adding a help file</p>
</li>
<li>
<p>The option window</p>
</li>
<li>
<p>Often used options</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_the_vimrc_file">The vimrc file</h3>
<div class="paragraph">
<p>You probably got tired of typing commands that you use very often.  To start
Vim with all your favorite option settings and mappings, you write them in
what is called the vimrc file.  Vim executes the commands in this file when it
starts up.</p>
</div>
<div class="paragraph">
<p>If you already have a vimrc file (e.g., when your sysadmin has one setup for
you), you can edit it this way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit $MYVIMRC</pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t have a vimrc file yet, see |vimrc| to find out where you can
create a vimrc file.  Also, the ":version" command mentions the name of the
"user vimrc file" Vim looks for.</p>
</div>
<div class="paragraph">
<p>For Unix and Macintosh this file is always used and is recommended:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>~/.vimrc</pre>
</div>
</div>
<div class="paragraph">
<p>For MS-Windows you can use one of these:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$HOME/_vimrc
$VIM/_vimrc</pre>
</div>
</div>
<div class="paragraph">
<p>If you are creating the vimrc file for the first time, it is recommended to
put this line at the top:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>source $VIMRUNTIME/defaults.vim</pre>
</div>
</div>
<div class="paragraph">
<p>This initializes Vim for new users (as opposed to traditional Vi users). See
|defaults.vim| for the details.</p>
</div>
<div class="paragraph">
<p>The vimrc file can contain all the commands that you type after a colon.  The
most simple ones are for setting options.  For example, if you want Vim to
always start with the 'incsearch' option on, add this line your vimrc file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set incsearch</pre>
</div>
</div>
<div class="paragraph">
<p>For this new line to take effect you need to exit Vim and start it again.
Later you will learn how to do this without exiting Vim.</p>
</div>
<div class="paragraph">
<p>This chapter only explains the most basic items.  For more information on how
to write a Vim script file: |usr_41.txt|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_example_vimrc_file_explained">The example vimrc file explained</h3>
<div class="paragraph">
<p>In the first chapter was explained how the example vimrc (included in the
Vim distribution) file can be used to make Vim startup in not-compatible mode
(see |not-compatible|).  The file can be found here:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$VIMRUNTIME/vimrc_example.vim</pre>
</div>
</div>
<div class="paragraph">
<p>In this section we will explain the various commands used in this file.  This
will give you hints about how to set up your own preferences.  Not everything
will be explained though.  Use the ":help" command to find out more.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>" Get the defaults that most users want.
source $VIMRUNTIME/defaults.vim</pre>
</div>
</div>
<div class="paragraph">
<p>This loads the "defaults.vim" file in the $VIMRUNTIME directory.  This sets up
Vim for how most users like it.  If you are one of the few that don&#8217;t, then
comment out this line.  The commands are explained below:
|defaults.vim-explained|</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if has("vms")
  set nobackup
else
  set backup
  if has('persistent_undo')
    set undofile
  endif
endif</pre>
</div>
</div>
<div class="paragraph">
<p>This tells Vim to keep a backup copy of a file when overwriting it.  But not
on the VMS system, since it keeps old versions of files already.  The backup
file will have the same name as the original file with "~" added.  See |07.4|</p>
</div>
<div class="paragraph">
<p>This also sets the 'undofile' option, if available.  This will store the
multi-level undo information in a file.  The result is that when you change a
file, exit Vim, and then edit the file again, you can undo the changes made
previously.  It&#8217;s a very powerful and useful feature, at the cost of storing a
file.  For more information see |undo-persistence|.</p>
</div>
<div class="paragraph">
<p>The "if" command is very useful to set options
only when some condition is met.  More about that in |usr_41.txt|.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if &amp;t_Co &gt; 2 || has("gui_running")
  set hlsearch
endif</pre>
</div>
</div>
<div class="paragraph">
<p>This switches on the 'hlsearch' option, telling Vim to highlight matches with
the last used search pattern.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>augroup vimrcEx
  au!
  autocmd FileType text setlocal textwidth=78
augroup END</pre>
</div>
</div>
<div class="paragraph">
<p>This makes Vim break text to avoid lines getting longer than 78 characters.
But only for files that have been detected to be plain text.  There are
actually two parts here.  "autocmd FileType text" is an autocommand.  This
defines that when the file type is set to "text" the following command is
automatically executed.  "setlocal textwidth=78" sets the 'textwidth' option
to 78, but only locally in one file.</p>
</div>
<div class="paragraph">
<p>The wrapper with "augroup vimrcEx" and "augroup END" makes it possible to
delete the autocommand with the "au!" command.  See |:augroup|.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if has('syntax') &amp;&amp; has('eval')
  packadd! matchit
endif</pre>
</div>
</div>
<div class="paragraph">
<p>This loads the "matchit" plugin if the required features are available.
It makes the |%| command more powerful.  This is explained at
|matchit-install|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_defaults_vim_file_explained">The defaults.vim file explained</h3>
<div class="paragraph">
<p>The |defaults.vim| file is loaded when the user has no vimrc file.  When you
create a new vimrc file, add this line near the top to keep using it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>source $VIMRUNTIME/defaults.vim</pre>
</div>
</div>
<div class="paragraph">
<p>Or use the vimrc_example.vim file, as explained above.</p>
</div>
<div class="paragraph">
<p>The following explains what defaults.vim is doing.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if exists('skip_defaults_vim')
  finish
endif</pre>
</div>
</div>
<div class="paragraph">
<p>Loading defaults.vim can be disabled with this command:
        let skip_defaults_vim = 1
This has to be done in the system vimrc file.  See |system-vimrc|.  If you
have a user vimrc this is not needed, since defaults.vim will not be loaded
automatically.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set nocompatible</pre>
</div>
</div>
<div class="paragraph">
<p>As mentioned in the first chapter, these manuals explain Vim working in an
improved way, thus not completely Vi compatible.  Setting the 'compatible'
option off, thus 'nocompatible' takes care of this.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set backspace=indent,eol,start</pre>
</div>
</div>
<div class="paragraph">
<p>This specifies where in Insert mode the &lt;BS&gt; is allowed to delete the
character in front of the cursor.  The three items, separated by commas, tell
Vim to delete the white space at the start of the line, a line break and the
character before where Insert mode started.  See 'backspace'.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set history=200</pre>
</div>
</div>
<div class="paragraph">
<p>Keep 200 commands and 200 search patterns in the history.  Use another number
if you want to remember fewer or more lines.  See 'history'.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set ruler</pre>
</div>
</div>
<div class="paragraph">
<p>Always display the current cursor position in the lower right corner of the
Vim window.  See 'ruler'.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set showcmd</pre>
</div>
</div>
<div class="paragraph">
<p>Display an incomplete command in the lower right corner of the Vim window,
left of the ruler.  For example, when you type "2f", Vim is waiting for you to
type the character to find and "2f" is displayed.  When you press "w" next,
the "2fw" command is executed and the displayed "2f" is removed.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+-------------------------------------------------+
|text in the Vim window                           |
|~                                                |
|~                                                |
|-- VISUAL --                   2f     43,8   17% |
+-------------------------------------------------+
 ^^^^^^^^^^^                  ^^^^^^^^ ^^^^^^^^^^
  'showmode'                 'showcmd'  'ruler'</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>set wildmenu</pre>
</div>
</div>
<div class="paragraph">
<p>Display completion matches in a status line.  That is when you type &lt;Tab&gt; and
there is more than one match.  See 'wildmenu'.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set ttimeout
set ttimeoutlen=100</pre>
</div>
</div>
<div class="paragraph">
<p>This makes typing Esc take effect more quickly.  Normally Vim waits a second
to see if the Esc is the start of an escape sequence.  If you have a very slow
remote connection, increase the number.  See 'ttimeout'.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set display=truncate</pre>
</div>
</div>
<div class="paragraph">
<p>Show @@@ in the last line if it is truncated, instead of hiding the whole
line.  See 'display'.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set incsearch</pre>
</div>
</div>
<div class="paragraph">
<p>Display the match for a search pattern when halfway typing it.  See
'incsearch'.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set nrformats-=octal</pre>
</div>
</div>
<div class="paragraph">
<p>Do not recognize numbers starting with a zero as octal.  See 'nrformats'.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>map Q gq</pre>
</div>
</div>
<div class="paragraph">
<p>This defines a key mapping.  More about that in the next section.  This
defines the "Q" command to do formatting with the "gq" operator.  This is how
it worked before Vim 5.0.  Otherwise the "Q" command starts Ex mode, but you
will not need it.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>inoremap &lt;C-U&gt; &lt;C-G&gt;u&lt;C-U&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>CTRL-U in insert mode deletes all entered text in the current line.  Use
CTRL-G u to first break undo, so that you can undo CTRL-U after inserting a
line break.  Revert with ":iunmap &lt;C-U&gt;".</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if has('mouse')
  set mouse=a
endif</pre>
</div>
</div>
<div class="paragraph">
<p>Enable using the mouse if available.  See 'mouse'.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vnoremap _g y:exe "grep /" . escape(@", '\\/') . "/ *.c *.h"&lt;CR&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>This mapping yanks the visually selected text and searches for it in C files.
You can see that a mapping can be used to do quite complicated things.  Still,
it is just a sequence of commands that are executed like you typed them.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>syntax on</pre>
</div>
</div>
<div class="paragraph">
<p>Enable highlighting files in color.  See |syntax|.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>filetype plugin indent on</pre>
</div>
</div>
<div class="paragraph">
<p>This switches on three very clever mechanisms:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Filetype detection.
Whenever you start editing a file, Vim will try to figure out what kind of
file this is.  When you edit "main.c", Vim will see the ".c" extension and
recognize this as a "c" filetype.  When you edit a file that starts with
"#!/bin/sh", Vim will recognize it as a "sh" filetype.
The filetype detection is used for syntax highlighting and the other two
items below.
See |filetypes|.</p>
</li>
<li>
<p>Using filetype plugin files
Many different filetypes are edited with different options.  For example,
when you edit a "c" file, it&#8217;s very useful to set the 'cindent' option to
automatically indent the lines.  These commonly useful option settings are
included with Vim in filetype plugins.  You can also add your own, see
|write-filetype-plugin|.</p>
</li>
<li>
<p>Using indent files
When editing programs, the indent of a line can often be computed
automatically.  Vim comes with these indent rules for a number of
filetypes.  See |:filetype-indent-on| and 'indentexpr'.</p>
<div class="literalblock">
<div class="content">
<pre>autocmd BufReadPost *
  \ if line("'\"") &gt;= 1 &amp;&amp; line("'\"") &lt;= line("$") &amp;&amp; &amp;ft !~# 'commit'
  \ |   exe "normal! g`\""
  \ | endif</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Another autocommand.  This time it is used after reading any file.  The
complicated stuff after it checks if the '" mark is defined, and jumps to it
if so.  The backslash at the start of a line is used to continue the command
from the previous line.  That avoids a line getting very long.
See |line-continuation|.  This only works in a Vim script file, not when
typing commands at the command-line.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
          \ | wincmd p | diffthis</pre>
</div>
</div>
<div class="paragraph">
<p>This adds the ":DiffOrig" command.  Use this in a modified buffer to see the
differences with the file it was loaded from.  See |diff| and |:DiffOrig|.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set nolangremap</pre>
</div>
</div>
<div class="paragraph">
<p>Prevent that the langmap option applies to characters that result from a
mapping.  If set (default), this may break plugins (but it&#8217;s backward
compatible).  See 'langremap'.</p>
</div>
</div>
<div class="sect2">
<h3 id="_simple_mappings">Simple mappings</h3>
<div class="paragraph">
<p>A mapping enables you to bind a set of Vim commands to a single key.  Suppose,
for example, that you need to surround certain words with curly braces.  In
other words, you need to change a word such as "amount" into "{amount}".  With
the :map command, you can tell Vim that the F5 key does this job.  The command
is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map &lt;F5&gt; i{&lt;Esc&gt;ea}&lt;Esc&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
When entering this command, you must enter &lt;F5&gt; by typing four
characters.  Similarly, &lt;Esc&gt; is not entered by pressing the &lt;Esc&gt;
key, but by typing five characters.  Watch out for this difference
when reading the manual!</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s break this down:
    &lt;F5&gt;        The F5 function key.  This is the trigger key that causes the
                command to be executed as the key is pressed.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>i{&lt;Esc&gt;     Insert the { character.  The &lt;Esc&gt; key ends Insert mode.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>e           Move to the end of the word.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>a}&lt;Esc&gt;     Append the } to the word.</pre>
</div>
</div>
<div class="paragraph">
<p>After you execute the ":map" command, all you have to do to put {} around a
word is to put the cursor on the first character and press F5.</p>
</div>
<div class="paragraph">
<p>In this example, the trigger is a single key; it can be any string.  But when
you use an existing Vim command, that command will no longer be available.
You better avoid that.
   One key that can be used with mappings is the backslash.  Since you
probably want to define more than one mapping, add another character.  You
could map "\p" to add parentheses around a word, and "\c" to add curly braces,
for example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map \p i(&lt;Esc&gt;ea)&lt;Esc&gt;
:map \c i{&lt;Esc&gt;ea}&lt;Esc&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>You need to type the \ and the p quickly after another, so that Vim knows they
belong together.</p>
</div>
<div class="paragraph">
<p>The ":map" command (with no arguments) lists your current mappings.  At
least the ones for Normal mode.  More about mappings in section |40.1|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_a_package">Adding a package</h3>
<div class="paragraph">
<p>A package is a set of files that you can add to Vim.  There are two kinds of
packages: optional and automatically loaded on startup.</p>
</div>
<div class="paragraph">
<p>The Vim distribution comes with a few packages that you can optionally use.
For example, the matchit plugin.  This plugin makes the "%" command jump to
matching HTML tags, if/else/endif in Vim scripts, etc.  Very useful, although
it&#8217;s not backwards compatible (that&#8217;s why it is not enabled by default).</p>
</div>
<div class="paragraph">
<p>To start using the matchit plugin, add one line to your vimrc file:
        packadd! matchit</p>
</div>
<div class="paragraph">
<p>That&#8217;s all!  After restarting Vim you can find help about this plugin:
        :help matchit</p>
</div>
<div class="paragraph">
<p>This works, because when <code>:packadd</code> loaded the plugin it also added the
package directory in 'runtimepath', so that the help file can be found.</p>
</div>
<div class="paragraph">
<p>You can find packages on the Internet in various places.  It usually comes as
an archive or as a repository.  For an archive you can follow these steps:
        1. create the package directory:
                mkdir -p ~/.vim/pack/fancy
&lt;          "fancy" can be any name of your liking.  Use one that describes the
           package.
        2. unpack the archive in that directory.  This assumes the top
           directory in the archive is "start":
                cd ~/.vim/pack/fancy
                unzip /tmp/fancy.zip
&lt;          If the archive layout is different make sure that you end up with a
           path like this:
                ~/.vim/pack/fancy/start/fancytext/plugin/fancy.vim
           Here "fancytext" is the name of the package, it can be anything
           else.</p>
</div>
<div class="paragraph">
<p>More information about packages can be found here: |packages|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_a_plugin">Adding a plugin</h3>
<div class="paragraph">
<p>Vim&#8217;s functionality can be extended by adding plugins.  A plugin is nothing
more than a Vim script file that is loaded automatically when Vim starts.  You
can add a plugin very easily by dropping it in your plugin directory.
{not available when Vim was compiled without the |+eval| feature}</p>
</div>
<div class="paragraph">
<p>There are two types of plugins:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  global plugin: Used for all kinds of files
filetype plugin: Only used for a specific type of file</pre>
</div>
</div>
<div class="paragraph">
<p>The global plugins will be discussed first, then the filetype ones
|add-filetype-plugin|.</p>
</div>
<div class="paragraph">
<p>GLOBAL PLUGINS                                          <strong>standard-plugin</strong></p>
</div>
<div class="paragraph">
<p>When you start Vim, it will automatically load a number of global plugins.
You don&#8217;t have to do anything for this.  They add functionality that most
people will want to use, but which was implemented as a Vim script instead of
being compiled into Vim.  You can find them listed in the help index
|standard-plugin-list|.  Also see |load-plugins|.</p>
</div>
<div class="paragraph">
<p>You can add a global plugin to add functionality that will always be present
when you use Vim.  There are only two steps for adding a global plugin:
1. Get a copy of the plugin.
2. Drop it in the right directory.</p>
</div>
<div class="sect3">
<h4 id="_getting_a_global_plugin">GETTING A GLOBAL PLUGIN</h4>
<div class="paragraph">
<p>Where can you find plugins?
- Some are always loaded, you can see them in the directory $VIMRUNTIME/plugin.
- Some come with Vim.  You can find them in the directory $VIMRUNTIME/macros
  and its sub-directories and under $VIM/vimfiles/pack/dist/opt/.
- Download from the net.  There is a large collection on <a href="http://www.vim.org" class="bare">http://www.vim.org</a>.
- They are sometimes posted in a Vim |maillist|.
- You could write one yourself, see |write-plugin|.</p>
</div>
<div class="paragraph">
<p>Some plugins come as a vimball archive, see |vimball|.
Some plugins can be updated automatically, see |getscript|.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_a_global_plugin">USING A GLOBAL PLUGIN</h4>
<div class="paragraph">
<p>First read the text in the plugin itself to check for any special conditions.
Then copy the file to your plugin directory:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>system          plugin directory
Unix            ~/.vim/plugin/
PC              $HOME/vimfiles/plugin or $VIM/vimfiles/plugin
Amiga           s:vimfiles/plugin
Macintosh       $VIM:vimfiles:plugin
Mac OS X        ~/.vim/plugin/</pre>
</div>
</div>
<div class="paragraph">
<p>Example for Unix (assuming you didn&#8217;t have a plugin directory yet):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mkdir ~/.vim
mkdir ~/.vim/plugin
cp /tmp/yourplugin.vim ~/.vim/plugin</pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s all!  Now you can use the commands defined in this plugin.</p>
</div>
<div class="paragraph">
<p>Instead of putting plugins directly into the plugin/ directory, you may
better organize them by putting them into subdirectories under plugin/.
As an example, consider using "~/.vim/plugin/perl/*.vim" for all your Perl
plugins.</p>
</div>
<div class="paragraph">
<p>FILETYPE PLUGINS                        <strong>add-filetype-plugin</strong> <strong>ftplugins</strong></p>
</div>
<div class="paragraph">
<p>The Vim distribution comes with a set of plugins for different filetypes that
you can start using with this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:filetype plugin on</pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s all!  See |vimrc-filetype|.</p>
</div>
<div class="paragraph">
<p>If you are missing a plugin for a filetype you are using, or you found a
better one, you can add it.  There are two steps for adding a filetype plugin:
1. Get a copy of the plugin.
2. Drop it in the right directory.</p>
</div>
</div>
<div class="sect3">
<h4 id="_getting_a_filetype_plugin">GETTING A FILETYPE PLUGIN</h4>
<div class="paragraph">
<p>You can find them in the same places as the global plugins.  Watch out if the
type of file is mentioned, then you know if the plugin is a global or a
filetype one.  The scripts in $VIMRUNTIME/macros are global ones, the filetype
plugins are in $VIMRUNTIME/ftplugin.</p>
</div>
<div class="paragraph">
<p>USING A FILETYPE PLUGIN                                 <strong>ftplugin-name</strong></p>
</div>
<div class="paragraph">
<p>You can add a filetype plugin by dropping it in the right directory.  The
name of this directory is in the same directory mentioned above for global
plugins, but the last part is "ftplugin".  Suppose you have found a plugin for
the "stuff" filetype, and you are on Unix.  Then you can move this file to the
ftplugin directory:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mv thefile ~/.vim/ftplugin/stuff.vim</pre>
</div>
</div>
<div class="paragraph">
<p>If that file already exists you already have a plugin for "stuff".  You might
want to check if the existing plugin doesn&#8217;t conflict with the one you are
adding.  If it&#8217;s OK, you can give the new one another name:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mv thefile ~/.vim/ftplugin/stuff_too.vim</pre>
</div>
</div>
<div class="paragraph">
<p>The underscore is used to separate the name of the filetype from the rest,
which can be anything.  If you use "otherstuff.vim" it wouldn&#8217;t work, it would
be loaded for the "otherstuff" filetype.</p>
</div>
<div class="paragraph">
<p>On MS-DOS like filesystems you cannot use long filenames.  You would run into
trouble if you add a second plugin and the filetype has more than six
characters.  You can use an extra directory to get around this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mkdir $VIM/vimfiles/ftplugin/fortran
copy thefile $VIM/vimfiles/ftplugin/fortran/too.vim</pre>
</div>
</div>
<div class="paragraph">
<p>The generic names for the filetype plugins are:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ftplugin/&lt;filetype&gt;.vim
ftplugin/&lt;filetype&gt;_&lt;name&gt;.vim
ftplugin/&lt;filetype&gt;/&lt;name&gt;.vim</pre>
</div>
</div>
<div class="paragraph">
<p>Here "&lt;name&gt;" can be any name that you prefer.
Examples for the "stuff" filetype on Unix:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>~/.vim/ftplugin/stuff.vim
~/.vim/ftplugin/stuff_def.vim
~/.vim/ftplugin/stuff/header.vim</pre>
</div>
</div>
<div class="paragraph">
<p>The &lt;filetype&gt; part is the name of the filetype the plugin is to be used for.
Only files of this filetype will use the settings from the plugin.  The &lt;name&gt;
part of the plugin file doesn&#8217;t matter, you can use it to have several plugins
for the same filetype.  Note that it must end in ".vim".</p>
</div>
<div class="paragraph">
<p>Further reading:
|filetype-plugins|      Documentation for the filetype plugins and information
                        about how to avoid that mappings cause problems.
|load-plugins|          When the global plugins are loaded during startup.
|ftplugin-overrule|     Overruling the settings from a global plugin.
|write-plugin|          How to write a plugin script.
|plugin-details|        For more information about using plugins or when your
                        plugin doesn&#8217;t work.
|new-filetype|          How to detect a new file type.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_adding_a_help_file">Adding a help file</h3>
<div class="paragraph">
<p>If you are lucky, the plugin you installed also comes with a help file.  We
will explain how to install the help file, so that you can easily find help
for your new plugin.
   Let us use the "doit.vim" plugin as an example.  This plugin comes with
documentation: "doit.txt".  Let&#8217;s first copy the plugin to the right
directory.  This time we will do it from inside Vim.  (You may skip some of
the "mkdir" commands if you already have the directory.) &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:!mkdir ~/.vim
:!mkdir ~/.vim/plugin
:!cp /tmp/doit.vim ~/.vim/plugin</pre>
</div>
</div>
<div class="paragraph">
<p>The "cp" command is for Unix, on MS-Windows you can use "copy".</p>
</div>
<div class="paragraph">
<p>Now create a "doc" directory in one of the directories in 'runtimepath'. &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:!mkdir ~/.vim/doc</pre>
</div>
</div>
<div class="paragraph">
<p>Copy the help file to the "doc" directory. &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:!cp /tmp/doit.txt ~/.vim/doc</pre>
</div>
</div>
<div class="paragraph">
<p>Now comes the trick, which allows you to jump to the subjects in the new help
file: Generate the local tags file with the |:helptags| command. &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:helptags ~/.vim/doc</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can use the &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help doit</pre>
</div>
</div>
<div class="paragraph">
<p>command to find help for "doit" in the help file you just added.  You can see
an entry for the local help file when you do:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help local-additions</pre>
</div>
</div>
<div class="paragraph">
<p>The title lines from the local help files are automagically added to this
section.  There you can see which local help files have been added and jump to
them through the tag.</p>
</div>
<div class="paragraph">
<p>For writing a local help file, see |write-local-help|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_option_window">The option window</h3>
<div class="paragraph">
<p>If you are looking for an option that does what you want, you can search in
the help files here: |options|.  Another way is by using this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:options</pre>
</div>
</div>
<div class="paragraph">
<p>This opens a new window, with a list of options with a one-line explanation.
The options are grouped by subject.  Move the cursor to a subject and press
&lt;Enter&gt; to jump there.  Press &lt;Enter&gt; again to jump back.  Or use CTRL-O.</p>
</div>
<div class="paragraph">
<p>You can change the value of an option.  For example, move to the "displaying
text" subject.  Then move the cursor down to this line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set wrap        nowrap</pre>
</div>
</div>
<div class="paragraph">
<p>When you hit &lt;Enter&gt;, the line will change to:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set nowrap      wrap</pre>
</div>
</div>
<div class="paragraph">
<p>The option has now been switched off.</p>
</div>
<div class="paragraph">
<p>Just above this line is a short description of the 'wrap' option.  Move the
cursor one line up to place it in this line.  Now hit &lt;Enter&gt; and you jump to
the full help on the 'wrap' option.</p>
</div>
<div class="paragraph">
<p>For options that take a number or string argument you can edit the value.
Then press &lt;Enter&gt; to apply the new value.  For example, move the cursor a few
lines up to this line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set so=0</pre>
</div>
</div>
<div class="paragraph">
<p>Position the cursor on the zero with "$".  Change it into a five with "r5".
Then press &lt;Enter&gt; to apply the new value.  When you now move the cursor
around you will notice that the text starts scrolling before you reach the
border.  This is what the 'scrolloff' option does, it specifies an offset
from the window border where scrolling starts.</p>
</div>
</div>
<div class="sect2">
<h3 id="_often_used_options">Often used options</h3>
<div class="paragraph">
<p>There are an awful lot of options.  Most of them you will hardly ever use.
Some of the more useful ones will be mentioned here.  Don&#8217;t forget you can
find more help on these options with the ":help" command, with single quotes
before and after the option name.  For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help 'wrap'</pre>
</div>
</div>
<div class="paragraph">
<p>In case you have messed up an option value, you can set it back to the
default by putting an ampersand (&amp;) after the option name.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set iskeyword&amp;</pre>
</div>
</div>
<div class="sect3">
<h4 id="_not_wrapping_lines">NOT WRAPPING LINES</h4>
<div class="paragraph">
<p>Vim normally wraps long lines, so that you can see all of the text.  Sometimes
it&#8217;s better to let the text continue right of the window.  Then you need to
scroll the text left-right to see all of a long line.  Switch wrapping off
with this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set nowrap</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will automatically scroll the text when you move to text that is not
displayed.  To see a context of ten characters, do this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set sidescroll=10</pre>
</div>
</div>
<div class="paragraph">
<p>This doesn&#8217;t change the text in the file, only the way it is displayed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_wrapping_movement_commands">WRAPPING MOVEMENT COMMANDS</h4>
<div class="paragraph">
<p>Most commands for moving around will stop moving at the start and end of a
line.  You can change that with the 'whichwrap' option.  This sets it to the
default value:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set whichwrap=b,s</pre>
</div>
</div>
<div class="paragraph">
<p>This allows the &lt;BS&gt; key, when used in the first position of a line, to move
the cursor to the end of the previous line.  And the &lt;Space&gt; key moves from
the end of a line to the start of the next one.</p>
</div>
<div class="paragraph">
<p>To allow the cursor keys &lt;Left&gt; and &lt;Right&gt; to also wrap, use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set whichwrap=b,s,&lt;,&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>This is still only for Normal mode.  To let &lt;Left&gt; and &lt;Right&gt; do this in
Insert mode as well:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set whichwrap=b,s,&lt;,&gt;,[,]</pre>
</div>
</div>
<div class="paragraph">
<p>There are a few other flags that can be added, see 'whichwrap'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_viewing_tabs">VIEWING TABS</h4>
<div class="paragraph">
<p>When there are tabs in a file, you cannot see where they are.  To make them
visible:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set list</pre>
</div>
</div>
<div class="paragraph">
<p>Now every tab is displayed as ^I.  And a $ is displayed at the end of each
line, so that you can spot trailing spaces that would otherwise go unnoticed.
   A disadvantage is that this looks ugly when there are many Tabs in a file.
If you have a color terminal, or are using the GUI, Vim can show the spaces
and tabs as highlighted characters.  Use the 'listchars' option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set listchars=tab:&gt;-,trail:-</pre>
</div>
</div>
<div class="paragraph">
<p>Now every tab will be displayed as "&gt;---" (with more or less "-") and trailing
white space as "-".  Looks a lot better, doesn&#8217;t it?</p>
</div>
</div>
<div class="sect3">
<h4 id="_keywords">KEYWORDS</h4>
<div class="paragraph">
<p>The 'iskeyword' option specifies which characters can appear in a word:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :set iskeyword
&lt;         iskeyword=@,48-57,_,192-255</pre>
</div>
</div>
<div class="paragraph">
<p>The "@" stands for all alphabetic letters.  "48-57" stands for ASCII
characters 48 to 57, which are the numbers 0 to 9.  "192-255" are the
printable latin characters.
   Sometimes you will want to include a dash in keywords, so that commands
like "w" consider "upper-case" to be one word.  You can do it like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :set iskeyword+=-
        :set iskeyword
&lt;         iskeyword=@,48-57,_,192-255,-</pre>
</div>
</div>
<div class="paragraph">
<p>If you look at the new value, you will see that Vim has added a comma for you.
   To remove a character use "-=".  For example, to remove the underscore:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :set iskeyword-=_
        :set iskeyword
&lt;         iskeyword=@,48-57,192-255,-</pre>
</div>
</div>
<div class="paragraph">
<p>This time a comma is automatically deleted.</p>
</div>
</div>
<div class="sect3">
<h4 id="_room_for_messages">ROOM FOR MESSAGES</h4>
<div class="paragraph">
<p>When Vim starts there is one line at the bottom that is used for messages.
When a message is long, it is either truncated, thus you can only see part of
it, or the text scrolls and you have to press &lt;Enter&gt; to continue.
   You can set the 'cmdheight' option to the number of lines used for
messages.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set cmdheight=3</pre>
</div>
</div>
<div class="paragraph">
<p>This does mean there is less room to edit text, thus it&#8217;s a compromise.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_06.txt|  Using syntax highlighting</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_syntax_highlighting">Using syntax highlighting</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Black and white text is boring.  With colors your file comes to life.  This
not only looks nice, it also speeds up your work.  Change the colors used for
the different sorts of text.  Print your text, with the colors you see on the
screen.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Switching it on</p>
</li>
<li>
<p>No or wrong colors?</p>
</li>
<li>
<p>Different colors</p>
</li>
<li>
<p>With colors or without colors</p>
</li>
<li>
<p>Printing with colors</p>
</li>
<li>
<p>Further reading</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_switching_it_on">Switching it on</h3>
<div class="paragraph">
<p>It all starts with one simple command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax enable</pre>
</div>
</div>
<div class="paragraph">
<p>That should work in most situations to get color in your files.  Vim will
automagically detect the type of file and load the right syntax highlighting.
Suddenly comments are blue, keywords brown and strings red.  This makes it
easy to overview the file.  After a while you will find that black&amp;white text
slows you down!</p>
</div>
<div class="paragraph">
<p>If you always want to use syntax highlighting, put the ":syntax enable"
command in your |vimrc| file.</p>
</div>
<div class="paragraph">
<p>If you want syntax highlighting only when the terminal supports colors, you
can put this in your |vimrc| file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if &amp;t_Co &gt; 1
   syntax enable
endif</pre>
</div>
</div>
<div class="paragraph">
<p>If you want syntax highlighting only in the GUI version, put the ":syntax
enable" command in your |gvimrc| file.</p>
</div>
</div>
<div class="sect2">
<h3 id="_no_or_wrong_colors">No or wrong colors?</h3>
<div class="paragraph">
<p>There can be a number of reasons why you don&#8217;t see colors:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Your terminal does not support colors.
Vim will use bold, italic and underlined text, but this doesn&#8217;t look
very nice.  You probably will want to try to get a terminal with
colors.  For Unix, I recommend the xterm from the XFree86 project:
|xfree-xterm|.</p>
</li>
<li>
<p>Your terminal does support colors, but Vim doesn&#8217;t know this.
Make sure your $TERM setting is correct.  For example, when using an
xterm that supports colors:</p>
<div class="literalblock">
<div class="content">
<pre>setenv TERM xterm-color</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>or (depending on your shell):</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>TERM=xterm-color; export TERM</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;       The terminal name must match the terminal you are using.  If it
        still doesn&#8217;t work, have a look at |xterm-color|, which shows a few
        ways to make Vim display colors (not only for an xterm).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The file type is not recognized.
Vim doesn&#8217;t know all file types, and sometimes it&#8217;s near to impossible
to tell what language a file uses.  Try this command:</p>
<div class="literalblock">
<div class="content">
<pre>:set filetype</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>If the result is "filetype=" then the problem is indeed that Vim
doesn't know what type of file this is.  You can set the type
manually:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>:set filetype=fortran</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;       To see which types are available, look in the directory
        $VIMRUNTIME/syntax.  For the GUI you can use the Syntax menu.
        Setting the filetype can also be done with a |modeline|, so that the
        file will be highlighted each time you edit it.  For example, this
        line can be used in a Makefile (put it near the start or end of the
        file):</p>
</div>
<div class="literalblock">
<div class="content">
<pre># vim: syntax=make</pre>
</div>
</div>
<div class="paragraph">
<p>&lt;       You might know how to detect the file type yourself.  Often the file
        name extension (after the dot) can be used.
        See |new-filetype| for how to tell Vim to detect that file type.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There is no highlighting for your file type.
You could try using a similar file type by manually setting it as
mentioned above.  If that isn&#8217;t good enough, you can write your own
syntax file, see |mysyntaxfile|.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Or the colors could be wrong:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The colored text is very hard to read.
Vim guesses the background color that you are using.  If it is black
(or another dark color) it will use light colors for text.  If it is
white (or another light color) it will use dark colors for text.  If
Vim guessed wrong the text will be hard to read.  To solve this, set
the 'background' option.  For a dark background:</p>
<div class="literalblock">
<div class="content">
<pre>:set background=dark</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;       And for a light background:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set background=light</pre>
</div>
</div>
<div class="paragraph">
<p>&lt;       Make sure you put this <em>before</em> the ":syntax enable" command,
        otherwise the colors will already have been set.  You could do
        ":syntax reset" after setting 'background' to make Vim set the default
        colors again.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The colors are wrong when scrolling bottom to top.
Vim doesn&#8217;t read the whole file to parse the text.  It starts parsing
wherever you are viewing the file.  That saves a lot of time, but
sometimes the colors are wrong.  A simple fix is hitting CTRL-L.  Or
scroll back a bit and then forward again.
For a real fix, see |:syn-sync|.  Some syntax files have a way to make
it look further back, see the help for the specific syntax file.  For
example, |tex.vim| for the TeX syntax.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_different_colors">Different colors</h3>
<div class="paragraph">
<p>If you don&#8217;t like the default colors, you can select another color scheme.  In
the GUI use the Edit/Color Scheme menu.  You can also type the command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:colorscheme evening</pre>
</div>
</div>
<div class="paragraph">
<p>"evening" is the name of the color scheme.  There are several others you might
want to try out.  Look in the directory $VIMRUNTIME/colors.</p>
</div>
<div class="paragraph">
<p>When you found the color scheme that you like, add the ":colorscheme" command
to your |vimrc| file.</p>
</div>
<div class="paragraph">
<p>You could also write your own color scheme.  This is how you do it:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Select a color scheme that comes close.  Copy this file to your own Vim
directory.  For Unix, this should work:</p>
<div class="literalblock">
<div class="content">
<pre>!mkdir ~/.vim/colors
!cp $VIMRUNTIME/colors/morning.vim ~/.vim/colors/mine.vim</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>This is done from Vim, because it knows the value of $VIMRUNTIME.</pre>
</div>
</div>
</li>
<li>
<p>Edit the color scheme file.  These entries are useful:</p>
<div class="literalblock">
<div class="content">
<pre>term            attributes in a B&amp;W terminal
cterm           attributes in a color terminal
ctermfg         foreground color in a color terminal
ctermbg         background color in a color terminal
gui             attributes in the GUI
guifg           foreground color in the GUI
guibg           background color in the GUI</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>For example, to make comments green:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>:highlight Comment ctermfg=green guifg=green</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Attributes you can use for "cterm" and "gui" are "bold" and "underline".
If you want both, use "bold,underline".  For details see the |:highlight|
command.</pre>
</div>
</div>
</li>
<li>
<p>Tell Vim to always use your color scheme.  Put this line in your |vimrc|:</p>
<div class="literalblock">
<div class="content">
<pre>colorscheme mine</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you want to see what the most often used color combinations look like, use
this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:runtime syntax/colortest.vim</pre>
</div>
</div>
<div class="paragraph">
<p>You will see text in various color combinations.  You can check which ones are
readable and look nice.</p>
</div>
</div>
<div class="sect2">
<h3 id="_with_colors_or_without_colors">With colors or without colors</h3>
<div class="paragraph">
<p>Displaying text in color takes a lot of effort.  If you find the displaying
too slow, you might want to disable syntax highlighting for a moment:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax clear</pre>
</div>
</div>
<div class="paragraph">
<p>When editing another file (or the same one) the colors will come back.</p>
</div>
<div class="paragraph">
<p>If you want to stop highlighting completely use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax off</pre>
</div>
</div>
<div class="paragraph">
<p>This will completely disable syntax highlighting and remove it immediately for
all buffers.  See |:syntax-off| for more details.</p>
</div>
<div class="paragraph">
<p>If you want syntax highlighting only for specific files, use this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax manual</pre>
</div>
</div>
<div class="paragraph">
<p>This will enable the syntax highlighting, but not switch it on automatically
when starting to edit a buffer.  To switch highlighting on for the current
buffer, set the 'syntax' option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set syntax=ON</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_printing_with_colors">Printing with colors</h3>
<div class="paragraph">
<p>In the MS-Windows version you can print the current file with this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:hardcopy</pre>
</div>
</div>
<div class="paragraph">
<p>You will get the usual printer dialog, where you can select the printer and a
few settings.  If you have a color printer, the paper output should look the
same as what you see inside Vim.  But when you use a dark background the
colors will be adjusted to look good on white paper.</p>
</div>
<div class="paragraph">
<p>There are several options that change the way Vim prints:
        'printdevice'
        'printheader'
        'printfont'
        'printoptions'</p>
</div>
<div class="paragraph">
<p>To print only a range of lines,  use Visual mode to select the lines and then
type the command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>v100j:hardcopy</pre>
</div>
</div>
<div class="paragraph">
<p>"v" starts Visual mode.  "100j" moves a hundred lines down, they will be
highlighted.  Then ":hardcopy" will print those lines.  You can use other
commands to move in Visual mode, of course.</p>
</div>
<div class="paragraph">
<p>This also works on Unix, if you have a PostScript printer.  Otherwise, you
will have to do a bit more work.  You need to convert the text to HTML first,
and then print it from a web browser.</p>
</div>
<div class="paragraph">
<p>Convert the current file to HTML with this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:TOhtml</pre>
</div>
</div>
<div class="paragraph">
<p>In case that doesn&#8217;t work:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:source $VIMRUNTIME/syntax/2html.vim</pre>
</div>
</div>
<div class="paragraph">
<p>You will see it crunching away, this can take quite a while for a large file.
Some time later another window shows the HTML code.  Now write this somewhere
(doesn&#8217;t matter where, you throw it away later):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:write main.c.html</pre>
</div>
</div>
<div class="paragraph">
<p>Open this file in your favorite browser and print it from there.  If all goes
well, the output should look exactly as it does in Vim.  See |2html.vim| for
details.  Don&#8217;t forget to delete the HTML file when you are done with it.</p>
</div>
<div class="paragraph">
<p>Instead of printing, you could also put the HTML file on a web server, and let
others look at the colored text.</p>
</div>
</div>
<div class="sect2">
<h3 id="_further_reading">Further reading</h3>
<div class="paragraph">
<p>|usr_44.txt|  Your own syntax highlighted.
|syntax|      All the details.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_07.txt|  Editing more than one file</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_editing_more_than_one_file">Editing more than one file</h2>
<div class="sectionbody">
<div class="paragraph">
<p>No matter how many files you have, you can edit them without leaving Vim.
Define a list of files to work on and jump from one to the other.  Copy text
from one file and put it in another one.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Edit another file</p>
</li>
<li>
<p>A list of files</p>
</li>
<li>
<p>Jumping from file to file</p>
</li>
<li>
<p>Backup files</p>
</li>
<li>
<p>Copy text between files</p>
</li>
<li>
<p>Viewing a file</p>
</li>
<li>
<p>Changing the file name</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_edit_another_file">Edit another file</h3>
<div class="paragraph">
<p>So far you had to start Vim for every file you wanted to edit.  There is a
simpler way.  To start editing another file, use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit foo.txt</pre>
</div>
</div>
<div class="paragraph">
<p>You can use any file name instead of "foo.txt".  Vim will close the current
file and open the new one.  If the current file has unsaved changes, however,
Vim displays an error message and does not open the new file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E37: No write since last change (use ! to override)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
Vim puts an error ID at the start of each error message.  If you do
not understand the message or what caused it, look in the help system
for this ID.  In this case:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>:help E37</pre>
</div>
</div>
<div class="paragraph">
<p>At this point, you have a number of alternatives.  You can write the file
using this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:write</pre>
</div>
</div>
<div class="paragraph">
<p>Or you can force Vim to discard your changes and edit the new file, using the
force (!) character:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit! foo.txt</pre>
</div>
</div>
<div class="paragraph">
<p>If you want to edit another file, but not write the changes in the current
file yet, you can make it hidden:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:hide edit foo.txt</pre>
</div>
</div>
<div class="paragraph">
<p>The text with changes is still there, but you can&#8217;t see it.  This is further
explained in section |22.4|: The buffer list.</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_list_of_files">A list of files</h3>
<div class="paragraph">
<p>You can start Vim to edit a sequence of files.  For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim one.c two.c three.c</pre>
</div>
</div>
<div class="paragraph">
<p>This command starts Vim and tells it that you will be editing three files.
Vim displays just the first file.  After you have done your thing in this
file, to edit the next file you use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:next</pre>
</div>
</div>
<div class="paragraph">
<p>If you have unsaved changes in the current file, you will get an error
message and the ":next" will not work.  This is the same problem as with
":edit" mentioned in the previous section.  To abandon the changes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:next!</pre>
</div>
</div>
<div class="paragraph">
<p>But mostly you want to save the changes and move on to the next file.  There
is a special command for this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:wnext</pre>
</div>
</div>
<div class="paragraph">
<p>This does the same as using two separate commands:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:write
:next</pre>
</div>
</div>
<div class="paragraph">
<p>WHERE AM I?</p>
</div>
<div class="paragraph">
<p>To see which file in the argument list you are editing, look in the window
title.  It should show something like "(2 of 3)".  This means you are editing
the second file out of three files.
   If you want to see the list of files, use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:args</pre>
</div>
</div>
<div class="paragraph">
<p>This is short for "arguments".  The output might look like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>one.c [two.c] three.c</pre>
</div>
</div>
<div class="paragraph">
<p>These are the files you started Vim with.  The one you are currently editing,
"two.c", is in square brackets.</p>
</div>
<div class="sect3">
<h4 id="_moving_to_other_arguments">MOVING TO OTHER ARGUMENTS</h4>
<div class="paragraph">
<p>To go back one file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:previous</pre>
</div>
</div>
<div class="paragraph">
<p>This is just like the ":next" command, except that it moves in the other
direction.  Again, there is a shortcut command for when you want to write the
file first:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:wprevious</pre>
</div>
</div>
<div class="paragraph">
<p>To move to the very last file in the list:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:last</pre>
</div>
</div>
<div class="paragraph">
<p>And to move back to the first one again:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:first</pre>
</div>
</div>
<div class="paragraph">
<p>There is no ":wlast" or ":wfirst" command though!</p>
</div>
<div class="paragraph">
<p>You can use a count for ":next" and ":previous".  To skip two files forward:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:2next</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_automatic_writing">AUTOMATIC WRITING</h4>
<div class="paragraph">
<p>When moving around the files and making changes, you have to remember to use
":write".  Otherwise you will get an error message.  If you are sure you
always want to write modified files, you can tell Vim to automatically write
them:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set autowrite</pre>
</div>
</div>
<div class="paragraph">
<p>When you are editing a file which you may not want to write, switch it off
again:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set noautowrite</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_editing_another_list_of_files">EDITING ANOTHER LIST OF FILES</h4>
<div class="paragraph">
<p>You can redefine the list of files without the need to exit Vim and start it
again.  Use this command to edit three other files:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:args five.c six.c seven.h</pre>
</div>
</div>
<div class="paragraph">
<p>Or use a wildcard, like it&#8217;s used in the shell:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:args *.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will take you to the first file in the list.  Again, if the current file
has changes, you can either write the file first, or use ":args!" (with !
added) to abandon the changes.</p>
</div>
<div class="paragraph">
<p>DID YOU EDIT THE LAST FILE?</p>
</div>
<div class="paragraph">
<p>When you use a list of files, Vim assumes you want to edit them all.  To
protect you from exiting too early, you will get this error when you didn&#8217;t
edit the last file in the list yet:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E173: 46 more files to edit</pre>
</div>
</div>
<div class="paragraph">
<p>If you really want to exit, just do it again.  Then it will work (but not when
you did other commands in between).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jumping_from_file_to_file">Jumping from file to file</h3>
<div class="paragraph">
<p>To quickly jump between two files, press CTRL-^ (on English-US keyboards the ^
is above the 6 key).  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:args one.c two.c three.c</pre>
</div>
</div>
<div class="paragraph">
<p>You are now in one.c. &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:next</pre>
</div>
</div>
<div class="paragraph">
<p>Now you are in two.c.  Now use CTRL-^ to go back to one.c.  Another CTRL-^ and
you are back in two.c.  Another CTRL-^ and you are in one.c again.  If you now
do:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:next</pre>
</div>
</div>
<div class="paragraph">
<p>You are in three.c.  Notice that the CTRL-^ command does not change the idea
of where you are in the list of files.  Only commands like ":next" and
":previous" do that.</p>
</div>
<div class="paragraph">
<p>The file you were previously editing is called the "alternate" file.  When you
just started Vim CTRL-^ will not work, since there isn&#8217;t a previous file.</p>
</div>
<div class="sect3">
<h4 id="_predefined_marks">PREDEFINED MARKS</h4>
<div class="paragraph">
<p>After jumping to another file, you can use two predefined marks which are very
useful:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`"</pre>
</div>
</div>
<div class="paragraph">
<p>This takes you to the position where the cursor was when you left the file.
Another mark that is remembered is the position where you made the last
change:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`.</pre>
</div>
</div>
<div class="paragraph">
<p>Suppose you are editing the file "one.txt".  Somewhere halfway through the
file you use "x" to delete a character.  Then you go to the last line with "G"
and write the file with ":w".  You edit several other files, and then use
":edit one.txt" to come back to "one.txt".  If you now use `" Vim jumps to the
last line of the file.  Using `. takes you to the position where you deleted
the character.  Even when you move around in the file `" and `. will take you
to the remembered position.  At least until you make another change or leave
the file.</p>
</div>
</div>
<div class="sect3">
<h4 id="_file_marks">FILE MARKS</h4>
<div class="paragraph">
<p>In section |03.10| was explained how you can place a mark in a file with "mx"
and jump to that position with "`x".  That works within one file.  If you edit
another file and place marks there, these are specific for that file.  Thus
each file has its own set of marks, they are local to the file.
   So far we were using marks with a lowercase letter.  There are also marks
with an uppercase letter.  These are global, they can be used from any file.
For example suppose that we are editing the file "foo.txt".  Go to halfway
down the file ("50%") and place the F mark there (F for foo):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>50%mF</pre>
</div>
</div>
<div class="paragraph">
<p>Now edit the file "bar.txt" and place the B mark (B for bar) at its last line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>GmB</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can use the "'F" command to jump back to halfway foo.txt.  Or edit yet
another file, type "'B" and you are at the end of bar.txt again.</p>
</div>
<div class="paragraph">
<p>The file marks are remembered until they are placed somewhere else.  Thus you
can place the mark, do hours of editing and still be able to jump back to that
mark.
   It&#8217;s often useful to think of a simple connection between the mark letter
and where it is placed.  For example, use the H mark in a header file, M in
a Makefile and C in a C code file.</p>
</div>
<div class="paragraph">
<p>To see where a specific mark is, give an argument to the ":marks" command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:marks M</pre>
</div>
</div>
<div class="paragraph">
<p>You can also give several arguments:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:marks MCP</pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t forget that you can use CTRL-O and CTRL-I to jump to older and newer
positions without placing marks there.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_backup_files">Backup files</h3>
<div class="paragraph">
<p>Usually Vim does not produce a backup file.  If you want to have one, all you
need to do is execute the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set backup</pre>
</div>
</div>
<div class="paragraph">
<p>The name of the backup file is the original file with a  ~  added to the end.
If your file is named data.txt, for example, the backup file name is
data.txt~.
   If you do not like the fact that the backup files end with ~, you can
change the extension:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set backupext=.bak</pre>
</div>
</div>
<div class="paragraph">
<p>This will use data.txt.bak instead of data.txt~.
   Another option that matters here is 'backupdir'.  It specifies where the
backup file is written.  The default, to write the backup in the same
directory as the original file, will mostly be the right thing.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
When the 'backup' option isn't set but the 'writebackup' is, Vim will
still create a backup file.  However, it is deleted as soon as writing
the file was completed successfully.  This functions as a safety
against losing your original file when writing fails in some way (disk
full is the most common cause; being hit by lightning might be
another, although less common).</pre>
</div>
</div>
<div class="sect3">
<h4 id="_keeping_the_original_file">KEEPING THE ORIGINAL FILE</h4>
<div class="paragraph">
<p>If you are editing source files, you might want to keep the file before you
make any changes.  But the backup file will be overwritten each time you write
the file.  Thus it only contains the previous version, not the first one.
   To make Vim keep the original file, set the 'patchmode' option.  This
specifies the extension used for the first backup of a changed file.  Usually
you would do this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set patchmode=.orig</pre>
</div>
</div>
<div class="paragraph">
<p>When you now edit the file data.txt for the first time, make changes and write
the file, Vim will keep a copy of the unchanged file under the name
"data.txt.orig".
   If you make further changes to the file, Vim will notice that
"data.txt.orig" already exists and leave it alone.  Further backup files will
then be called "data.txt~" (or whatever you specified with 'backupext').
   If you leave 'patchmode' empty (that is the default), the original file
will not be kept.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_copy_text_between_files">Copy text between files</h3>
<div class="paragraph">
<p>This explains how to copy text from one file to another.  Let&#8217;s start with a
simple example.  Edit the file that contains the text you want to copy.  Move
the cursor to the start of the text and press "v".  This starts Visual mode.
Now move the cursor to the end of the text and press "y".  This yanks (copies)
the selected text.
   To copy the above paragraph, you would do:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit thisfile
/This
vjjjj$y</pre>
</div>
</div>
<div class="paragraph">
<p>Now edit the file you want to put the text in.  Move the cursor to the
character where you want the text to appear after.  Use "p" to put the text
there. &gt;
        :edit otherfile
        /There
        p</p>
</div>
<div class="paragraph">
<p>Of course you can use many other commands to yank the text.  For example, to
select whole lines start Visual mode with "V".  Or use CTRL-V to select a
rectangular block.  Or use "Y" to yank a single line, "yaw" to yank-a-word,
etc.
   The "p" command puts the text after the cursor.  Use "P" to put the text
before the cursor.  Notice that Vim remembers if you yanked a whole line or a
block, and puts it back that way.</p>
</div>
<div class="sect3">
<h4 id="_using_registers">USING REGISTERS</h4>
<div class="paragraph">
<p>When you want to copy several pieces of text from one file to another, having
to switch between the files and writing the target file takes a lot of time.
To avoid this, copy each piece of text to its own register.
   A register is a place where Vim stores text.  Here we will use the
registers named a to z (later you will find out there are others).  Let&#8217;s copy
a sentence to the f register (f for First):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"fyas</pre>
</div>
</div>
<div class="paragraph">
<p>The "yas" command yanks a sentence like before.  It&#8217;s the "f that tells Vim
the text should be placed in the f register.  This must come just before the
yank command.
   Now yank three whole lines to the l register (l for line):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"l3Y</pre>
</div>
</div>
<div class="paragraph">
<p>The count could be before the "l just as well.  To yank a block of text to the
b (for block) register:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-Vjjww"by</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the register specification "b is just before the "y" command.
This is required.  If you would have put it before the "w" command, it would
not have worked.
   Now you have three pieces of text in the f, l and b registers.  Edit
another file, move around and place the text where you want it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"fp</pre>
</div>
</div>
<div class="paragraph">
<p>Again, the register specification "f comes before the "p" command.
   You can put the registers in any order.  And the text stays in the register
until you yank something else into it.  Thus you can put it as many times as
you like.</p>
</div>
<div class="paragraph">
<p>When you delete text, you can also specify a register.  Use this to move
several pieces of text around.  For example, to delete-a-word and write it in
the w register:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"wdaw</pre>
</div>
</div>
<div class="paragraph">
<p>Again, the register specification comes before the delete command "d".</p>
</div>
</div>
<div class="sect3">
<h4 id="_appending_to_a_file">APPENDING TO A FILE</h4>
<div class="paragraph">
<p>When collecting lines of text into one file, you can use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:write &gt;&gt; logfile</pre>
</div>
</div>
<div class="paragraph">
<p>This will write the text of the current file to the end of "logfile".  Thus it
is appended.  This avoids that you have to copy the lines, edit the log file
and put them there.  Thus you save two steps.  But you can only append to the
end of a file.
   To append only a few lines, select them in Visual mode before typing
":write".  In chapter 10 you will learn other ways to select a range of lines.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_viewing_a_file">Viewing a file</h3>
<div class="paragraph">
<p>Sometimes you only want to see what a file contains, without the intention to
ever write it back.  There is the risk that you type ":w" without thinking and
overwrite the original file anyway.  To avoid this, edit the file read-only.
   To start Vim in readonly mode, use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim -R file</pre>
</div>
</div>
<div class="paragraph">
<p>On Unix this command should do the same thing:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>view file</pre>
</div>
</div>
<div class="paragraph">
<p>You are now editing "file" in read-only mode.  When you try using ":w" you
will get an error message and the file won&#8217;t be written.
   When you try to make a change to the file Vim will give you a warning:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>W10: Warning: Changing a readonly file</pre>
</div>
</div>
<div class="paragraph">
<p>The change will be done though.  This allows for formatting the file, for
example, to be able to read it easily.
   If you make changes to a file and forgot that it was read-only, you can
still write it.  Add the ! to the write command to force writing.</p>
</div>
<div class="paragraph">
<p>If you really want to forbid making changes in a file, do this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim -M file</pre>
</div>
</div>
<div class="paragraph">
<p>Now every attempt to change the text will fail.  The help files are like this,
for example.  If you try to make a change you get this error message:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E21: Cannot make changes, 'modifiable' is off</pre>
</div>
</div>
<div class="paragraph">
<p>You could use the -M argument to setup Vim to work in a viewer mode.  This is
only voluntary though, since these commands will remove the protection:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set modifiable
:set write</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_changing_the_file_name">Changing the file name</h3>
<div class="paragraph">
<p>A clever way to start editing a new file is by using an existing file that
contains most of what you need.  For example, you start writing a new program
to move a file.  You know that you already have a program that copies a file,
thus you start with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit copy.c</pre>
</div>
</div>
<div class="paragraph">
<p>You can delete the stuff you don&#8217;t need.  Now you need to save the file under
a new name.  The ":saveas" command can be used for this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:saveas move.c</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will write the file under the given name, and edit that file.  Thus the
next time you do ":write", it will write "move.c".  "copy.c" remains
unmodified.
   When you want to change the name of the file you are editing, but don&#8217;t
want to write the file, you can use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:file move.c</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will mark the file as "not edited".  This means that Vim knows this is not
the file you started editing.  When you try to write the file, you might get
this message:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E13: File exists (use ! to override)</pre>
</div>
</div>
<div class="paragraph">
<p>This protects you from accidentally overwriting another file.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_08.txt|  Splitting windows</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_splitting_windows">Splitting windows</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Display two different files above each other.  Or view two locations in the
file at the same time.  See the difference between two files by putting them
side by side.  All this is possible with split windows.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Split a window</p>
</li>
<li>
<p>Split a window on another file</p>
</li>
<li>
<p>Window size</p>
</li>
<li>
<p>Vertical splits</p>
</li>
<li>
<p>Moving windows</p>
</li>
<li>
<p>Commands for all windows</p>
</li>
<li>
<p>Viewing differences with vimdiff</p>
</li>
<li>
<p>Various</p>
</li>
<li>
<p>Tab pages</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_split_a_window">Split a window</h3>
<div class="paragraph">
<p>The easiest way to open a new window is to use the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:split</pre>
</div>
</div>
<div class="paragraph">
<p>This command splits the screen into two windows and leaves the cursor in the
top one:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+----------------------------------+
|/* file one.c */                  |
|~                                 |
|~                                 |
|one.c=============================|
|/* file one.c */                  |
|~                                 |
|one.c=============================|
|                                  |
+----------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>What you see here is two windows on the same file.  The line with "====" is
the status line.  It displays information about the window above it.  (In
practice the status line will be in reverse video.)
   The two windows allow you to view two parts of the same file.  For example,
you could make the top window show the variable declarations of a program, and
the bottom one the code that uses these variables.</p>
</div>
<div class="paragraph">
<p>The CTRL-W w command can be used to jump between the windows.  If you are in
the top window, CTRL-W w jumps to the window below it.  If you are in the
bottom window it will jump to the first window.  (CTRL-W CTRL-W does the same
thing, in case you let go of the CTRL key a bit later.)</p>
</div>
<div class="sect3">
<h4 id="_close_the_window">CLOSE THE WINDOW</h4>
<div class="paragraph">
<p>To close a window, use the command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:close</pre>
</div>
</div>
<div class="paragraph">
<p>Actually, any command that quits editing a file works, like ":quit" and "ZZ".
But ":close" prevents you from accidentally exiting Vim when you close the
last window.</p>
</div>
</div>
<div class="sect3">
<h4 id="_closing_all_other_windows">CLOSING ALL OTHER WINDOWS</h4>
<div class="paragraph">
<p>If you have opened a whole bunch of windows, but now want to concentrate on
one of them, this command will be useful:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:only</pre>
</div>
</div>
<div class="paragraph">
<p>This closes all windows, except for the current one.  If any of the other
windows has changes, you will get an error message and that window won&#8217;t be
closed.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_split_a_window_on_another_file">Split a window on another file</h3>
<div class="paragraph">
<p>The following command opens a second window and starts editing the given file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:split two.c</pre>
</div>
</div>
<div class="paragraph">
<p>If you were editing one.c, then the result looks like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+----------------------------------+
|/* file two.c */                  |
|~                                 |
|~                                 |
|two.c=============================|
|/* file one.c */                  |
|~                                 |
|one.c=============================|
|                                  |
+----------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>To open a window on a new, empty file, use this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:new</pre>
</div>
</div>
<div class="paragraph">
<p>You can repeat the ":split" and ":new" commands to create as many windows as
you like.</p>
</div>
</div>
<div class="sect2">
<h3 id="_window_size">Window size</h3>
<div class="paragraph">
<p>The ":split" command can take a number argument.  If specified, this will be
the height of the new window.  For example, the following opens a new window
three lines high and starts editing the file alpha.c:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:3split alpha.c</pre>
</div>
</div>
<div class="paragraph">
<p>For existing windows you can change the size in several ways.  When you have a
working mouse, it is easy: Move the mouse pointer to the status line that
separates two windows, and drag it up or down.</p>
</div>
<div class="paragraph">
<p>To increase the size of a window:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-W +</pre>
</div>
</div>
<div class="paragraph">
<p>To decrease it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-W -</pre>
</div>
</div>
<div class="paragraph">
<p>Both of these commands take a count and increase or decrease the window size
by that many lines.  Thus "4 CTRL-W +" make the window four lines higher.</p>
</div>
<div class="paragraph">
<p>To set the window height to a specified number of lines:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>{height}CTRL-W _</pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s: a number {height}, CTRL-W and then an underscore (the - key with Shift
on English-US keyboards).
   To make a window as high as it can be, use the CTRL-W _ command without a
count.</p>
</div>
<div class="sect3">
<h4 id="_using_the_mouse">USING THE MOUSE</h4>
<div class="paragraph">
<p>In Vim you can do many things very quickly from the keyboard.  Unfortunately,
the window resizing commands require quite a bit of typing.  In this case,
using the mouse is faster.  Position the mouse pointer on a status line.  Now
press the left mouse button and drag.  The status line will move, thus making
the window on one side higher and the other smaller.</p>
</div>
</div>
<div class="sect3">
<h4 id="_options">OPTIONS</h4>
<div class="paragraph">
<p>The 'winheight' option can be set to a minimal desired height of a window and
'winminheight' to a hard minimum height.
   Likewise, there is 'winwidth' for the minimal desired width and
'winminwidth' for the hard minimum width.
   The 'equalalways' option, when set, makes Vim equalize the windows sizes
when a window is closed or opened.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_vertical_splits">Vertical splits</h3>
<div class="paragraph">
<p>The ":split" command creates the new window above the current one.  To make
the window appear at the left side, use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:vsplit</pre>
</div>
</div>
<div class="paragraph">
<p>or:
        :vsplit two.c</p>
</div>
<div class="paragraph">
<p>The result looks something like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+--------------------------------------+
|/* file two.c */   |/* file one.c */  |
|~                  |~                 |
|~                  |~                 |
|~                  |~                 |
|two.c===============one.c=============|
|                                      |
+--------------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>Actually, the | lines in the middle will be in reverse video.  This is called
the vertical separator.  It separates the two windows left and right of it.</p>
</div>
<div class="paragraph">
<p>There is also the ":vnew" command, to open a vertically split window on a new,
empty file.  Another way to do this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:vertical new</pre>
</div>
</div>
<div class="paragraph">
<p>The ":vertical" command can be inserted before another command that splits a
window.  This will cause that command to split the window vertically instead
of horizontally.  (If the command doesn&#8217;t split a window, it works
unmodified.)</p>
</div>
<div class="sect3">
<h4 id="_moving_between_windows">MOVING BETWEEN WINDOWS</h4>
<div class="paragraph">
<p>Since you can split windows horizontally and vertically as much as you like,
you can create almost any layout of windows.  Then you can use these commands
to move between them:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-W h        move to the window on the left
CTRL-W j        move to the window below
CTRL-W k        move to the window above
CTRL-W l        move to the window on the right</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-W t        move to the TOP window
CTRL-W b        move to the BOTTOM window</pre>
</div>
</div>
<div class="paragraph">
<p>You will notice the same letters as used for moving the cursor.  And the
cursor keys can also be used, if you like.
   More commands to move to other windows: |Q_wi|.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_moving_windows">Moving windows</h3>
<div class="paragraph">
<p>You have split a few windows, but now they are in the wrong place.  Then you
need a command to move the window somewhere else.  For example, you have three
windows like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+----------------------------------+
|/* file two.c */                  |
|~                                 |
|~                                 |
|two.c=============================|
|/* file three.c */                |
|~                                 |
|~                                 |
|three.c===========================|
|/* file one.c */                  |
|~                                 |
|one.c=============================|
|                                  |
+----------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>Clearly the last one should be at the top.  Go to that window (using CTRL-W w)
and the type this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-W K</pre>
</div>
</div>
<div class="paragraph">
<p>This uses the uppercase letter K.  What happens is that the window is moved to
the very top.  You will notice that K is again used for moving upwards.
   When you have vertical splits, CTRL-W K will move the current window to the
top and make it occupy the full width of the Vim window.  If this is your
layout:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+-------------------------------------------+
|/* two.c */  |/* three.c */  |/* one.c */  |
|~            |~              |~            |
|~            |~              |~            |
|~            |~              |~            |
|~            |~              |~            |
|~            |~              |~            |
|two.c=========three.c=========one.c========|
|                                           |
+-------------------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>Then using CTRL-W K in the middle window (three.c) will result in:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+-------------------------------------------+
|/* three.c */                              |
|~                                          |
|~                                          |
|three.c====================================|
|/* two.c */           |/* one.c */         |
|~                     |~                   |
|two.c==================one.c===============|
|                                           |
+-------------------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>The other three similar commands (you can probably guess these now):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-W H        move window to the far left
CTRL-W J        move window to the bottom
CTRL-W L        move window to the far right</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_commands_for_all_windows">Commands for all windows</h3>
<div class="paragraph">
<p>When you have several windows open and you want to quit Vim, you can close
each window separately.  A quicker way is using this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:qall</pre>
</div>
</div>
<div class="paragraph">
<p>This stands for "quit all".  If any of the windows contain changes, Vim will
not exit.  The cursor will automatically be positioned in a window with
changes.  You can then either use ":write" to save the changes, or ":quit!" to
throw them away.</p>
</div>
<div class="paragraph">
<p>If you know there are windows with changes, and you want to save all these
changes, use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:wall</pre>
</div>
</div>
<div class="paragraph">
<p>This stands for "write all".  But actually, it only writes files with
changes.  Vim knows it doesn&#8217;t make sense to write files that were not
changed.
   And then there is the combination of ":qall" and ":wall": the "write and
quit all" command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:wqall</pre>
</div>
</div>
<div class="paragraph">
<p>This writes all modified files and quits Vim.
   Finally, there is a command that quits Vim and throws away all changes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:qall!</pre>
</div>
</div>
<div class="paragraph">
<p>Be careful, there is no way to undo this command!</p>
</div>
<div class="sect3">
<h4 id="_opening_a_window_for_all_arguments">OPENING A WINDOW FOR ALL ARGUMENTS</h4>
<div class="paragraph">
<p>To make Vim open a window for each file, start it with the "-o" argument:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim -o one.txt two.txt three.txt</pre>
</div>
</div>
<div class="paragraph">
<p>This results in:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+-------------------------------+
|file one.txt                   |
|~                              |
|one.txt========================|
|file two.txt                   |
|~                              |
|two.txt========================|
|file three.txt                 |
|~                              |
|three.txt======================|
|                               |
+-------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>The "-O" argument is used to get vertically split windows.
   When Vim is already running, the ":all" command opens a window for each
file in the argument list.  ":vertical all" does it with vertical splits.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_viewing_differences_with_vimdiff">Viewing differences with vimdiff</h3>
<div class="paragraph">
<p>There is a special way to start Vim, which shows the differences between two
files.  Let&#8217;s take a file "main.c" and insert a few characters in one line.
Write this file with the 'backup' option set, so that the backup file
"main.c~" will contain the previous version of the file.
   Type this command in a shell (not in Vim):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vimdiff main.c~ main.c</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will start, with two windows side by side.  You will only see the line
in which you added characters, and a few lines above and below it.</p>
</div>
<div class="sect3">
<h4 id="_vv_vv">VV                   VV</h4>
<div class="literalblock">
<div class="content">
<pre>+-----------------------------------------+
|+ +--123 lines: /* a|+ +--123 lines: /* a|  &lt;- fold
|  text              |  text              |
|  text              |  text              |
|  text              |  text              |
|  text              |  changed text      |  &lt;- changed line
|  text              |  text              |
|  text              |  ------------------|  &lt;- deleted line
|  text              |  text              |
|  text              |  text              |
|  text              |  text              |
|+ +--432 lines: text|+ +--432 lines: text|  &lt;- fold
|  ~                 |  ~                 |
|  ~                 |  ~                 |
|main.c~==============main.c==============|
|                                         |
+-----------------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>(This picture doesn&#8217;t show the highlighting, use the vimdiff command for a
better look.)</p>
</div>
<div class="paragraph">
<p>The lines that were not modified have been collapsed into one line.  This is
called a closed fold.  They are indicated in the picture with "&#8592; fold".  Thus
the single fold line at the top stands for 123 text lines.  These lines are
equal in both files.
   The line marked with "&#8592; changed line" is highlighted, and the inserted
text is displayed with another color.  This clearly shows what the difference
is between the two files.
   The line that was deleted is displayed with "---" in the main.c window.
See the "&#8592; deleted line" marker in the picture.  These characters are not
really there.  They just fill up main.c, so that it displays the same number
of lines as the other window.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_fold_column">THE FOLD COLUMN</h4>
<div class="paragraph">
<p>Each window has a column on the left with a slightly different background.  In
the picture above these are indicated with "VV".  You notice there is a plus
character there, in front of each closed fold.  Move the mouse pointer to that
plus and click the left button.  The fold will open, and you can see the text
that it contains.
   The fold column contains a minus sign for an open fold.  If you click on
this -, the fold will close.
   Obviously, this only works when you have a working mouse.  You can also use
"zo" to open a fold and "zc" to close it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_diffing_in_vim">DIFFING IN VIM</h4>
<div class="paragraph">
<p>Another way to start in diff mode can be done from inside Vim.  Edit the
"main.c" file, then make a split and show the differences:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit main.c
:vertical diffsplit main.c~</pre>
</div>
</div>
<div class="paragraph">
<p>The ":vertical" command is used to make the window split vertically.  If you
omit this, you will get a horizontal split.</p>
</div>
<div class="paragraph">
<p>If you have a patch or diff file, you can use the third way to start diff
mode.  First edit the file to which the patch applies.  Then tell Vim the name
of the patch file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit main.c
:vertical diffpatch main.c.diff</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
The patch file must contain only one patch, for the file you are
editing.  Otherwise you will get a lot of error messages, and some files might
be patched unexpectedly.
   The patching will only be done to the copy of the file in Vim.  The file on
your harddisk will remain unmodified (until you decide to write the file).
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_scroll_binding">SCROLL BINDING</h4>
<div class="paragraph">
<p>When the files have more changes, you can scroll in the usual way.  Vim will
try to keep both the windows start at the same position, so you can easily see
the differences side by side.
   When you don&#8217;t want this for a moment, use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set noscrollbind</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_jumping_to_changes">JUMPING TO CHANGES</h4>
<div class="paragraph">
<p>When you have disabled folding in some way, it may be difficult to find the
changes.  Use this command to jump forward to the next change:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>]c</pre>
</div>
</div>
<div class="paragraph">
<p>To go the other way use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[c</pre>
</div>
</div>
<div class="paragraph">
<p>Prepended a count to jump further away.</p>
</div>
</div>
<div class="sect3">
<h4 id="_removing_changes">REMOVING CHANGES</h4>
<div class="paragraph">
<p>You can move text from one window to the other.  This either removes
differences or adds new ones.  Vim doesn&#8217;t keep the highlighting updated in
all situations.  To update it use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:diffupdate</pre>
</div>
</div>
<div class="paragraph">
<p>To remove a difference, you can move the text in a highlighted block from one
window to another.  Take the "main.c" and "main.c~" example above.  Move the
cursor to the left window, on the line that was deleted in the other window.
Now type this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>dp</pre>
</div>
</div>
<div class="paragraph">
<p>The change will be removed by putting the text of the current window in the
other window.  "dp" stands for "diff put".
   You can also do it the other way around.  Move the cursor to the right
window, to the line where "changed" was inserted.  Now type this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>do</pre>
</div>
</div>
<div class="paragraph">
<p>The change will now be removed by getting the text from the other window.
Since there are no changes left now, Vim puts all text in a closed fold.
"do" stands for "diff obtain".  "dg" would have been better, but that already
has a different meaning ("dgg" deletes from the cursor until the first line).</p>
</div>
<div class="paragraph">
<p>For details about diff mode, see |vimdiff|.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_various">Various</h3>
<div class="paragraph">
<p>The 'laststatus' option can be used to specify when the last window has a
statusline:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>0       never
1       only when there are split windows (the default)
2       always</pre>
</div>
</div>
<div class="paragraph">
<p>Many commands that edit another file have a variant that splits the window.
For Command-line commands this is done by prepending an "s".  For example:
":tag" jumps to a tag, ":stag" splits the window and jumps to a
tag.
   For Normal mode commands a CTRL-W is prepended.  CTRL-^ jumps to the
alternate file, CTRL-W CTRL-^ splits the window and edits the alternate file.</p>
</div>
<div class="paragraph">
<p>The 'splitbelow' option can be set to make a new window appear below the
current window.  The 'splitright' option can be set to make a vertically split
window appear right of the current window.</p>
</div>
<div class="paragraph">
<p>When splitting a window you can prepend a modifier command to tell where the
window is to appear:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:leftabove {cmd}        left or above the current window
:aboveleft {cmd}        idem
:rightbelow {cmd}       right or below the current window
:belowright {cmd}       idem
:topleft {cmd}          at the top or left of the Vim window
:botright {cmd}         at the bottom or right of the Vim window</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tab_pages">Tab pages</h3>
<div class="paragraph">
<p>You will have noticed that windows never overlap.  That means you quickly run
out of screen space.  The solution for this is called Tab pages.</p>
</div>
<div class="paragraph">
<p>Assume you are editing "thisfile".  To create a new tab page use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tabedit thatfile</pre>
</div>
</div>
<div class="paragraph">
<p>This will edit the file "thatfile" in a window that occupies the whole Vim
window.  And you will notice a bar at the top with the two file names:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+----------------------------------+
| thisfile | /thatfile/ __________X|    (thatfile is bold)
|/* thatfile */                    |
|that                              |
|that                              |
|~                                 |
|~                                 |
|~                                 |
|                                  |
+----------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>You now have two tab pages.  The first one has a window for "thisfile" and the
second one a window for "thatfile".  It&#8217;s like two pages that are on top of
each other, with a tab sticking out of each page showing the file name.</p>
</div>
<div class="paragraph">
<p>Now use the mouse to click on "thisfile" in the top line.  The result is</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+----------------------------------+
| /thisfile/ | thatfile __________X|    (thisfile is bold)
|/* thisfile */                    |
|this                              |
|this                              |
|~                                 |
|~                                 |
|~                                 |
|                                  |
+----------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>Thus you can switch between tab pages by clicking on the label in the top
line.  If you don&#8217;t have a mouse or don&#8217;t want to use it, you can use the "gt"
command.  Mnemonic: Goto Tab.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s create another tab page with the command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tab split</pre>
</div>
</div>
<div class="paragraph">
<p>This makes a new tab page with one window that is editing the same buffer as
the window we were in:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+-------------------------------------+
| thisfile | /thisfile/ | thatfile __X|   (thisfile is bold)
|/* thisfile */                       |
|this                                 |
|this                                 |
|~                                    |
|~                                    |
|~                                    |
|                                     |
+-------------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>You can put ":tab" before any Ex command that opens a window.  The window will
be opened in a new tab page.  Another example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tab help gt</pre>
</div>
</div>
<div class="paragraph">
<p>Will show the help text for "gt" in a new tab page.</p>
</div>
<div class="paragraph">
<p>A few more things you can do with tab pages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>click with the mouse in the space after the last label
The next tab page will be selected, like with "gt".</p>
</li>
<li>
<p>click with the mouse on the "X" in the top right corner
The current tab page will be closed.  Unless there are unsaved
changes in the current tab page.</p>
</li>
<li>
<p>double click with the mouse in the top line
A new tab page will be created.</p>
</li>
<li>
<p>the "tabonly" command
Closes all tab pages except the current one.  Unless there are unsaved
changes in other tab pages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information about tab pages see |tab-page|.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_09.txt|  Using the GUI</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_the_gui">Using the GUI</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vim works in an ordinary terminal, while gVim has a Graphical User Interface
(GUI).  It can do the same things and a few more.  The GUI offers menus, a
toolbar, scrollbars and other items.  This chapter is about these extra things
that the GUI offers.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Parts of the GUI</p>
</li>
<li>
<p>Using the mouse</p>
</li>
<li>
<p>The clipboard</p>
</li>
<li>
<p>Select mode</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_parts_of_the_gui">Parts of the GUI</h3>
<div class="paragraph">
<p>You might have an icon on your desktop that starts gvim.  Otherwise, one of
these commands should do it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gvim file.txt
vim -g file.txt</pre>
</div>
</div>
<div class="paragraph">
<p>If this doesn&#8217;t work you don&#8217;t have a version of Vim with GUI support.  You
will have to install one first.
   Vim will open a window and display "file.txt" in it.  What the window looks
like depends on the version of Vim.  It should resemble the following picture
(for as far as this can be shown in ASCII!).</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+----------------------------------------------------+
| file.txt + (~/dir) - VIM                         X |  &lt;- window title
+----------------------------------------------------+
| File  Edit  Tools  Syntax  Buffers  Window  Help   |  &lt;- menubar
+----------------------------------------------------+
| aaa  bbb  ccc  ddd  eee  fff  ggg  hhh  iii  jjj   |  &lt;- toolbar
| aaa  bbb  ccc  ddd  eee  fff  ggg  hhh  iii  jjj   |
+----------------------------------------------------+
| file text                                      | ^ |
| ~                                              | # |
| ~                                              | # |  &lt;- scrollbar
| ~                                              | # |
| ~                                              | # |
| ~                                              | # |
|                                                | V |
+----------------------------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>The largest space is occupied by the file text.  This shows the file in the
same way as in a terminal.  With some different colors and another font
perhaps.</p>
</div>
<div class="sect3">
<h4 id="_the_window_title">THE WINDOW TITLE</h4>
<div class="paragraph">
<p>At the very top is the window title.  This is drawn by your window system.
Vim will set the title to show the name of the current file.  First comes the
name of the file.  Then some special characters and the directory of the file
in parens.  These special characters can be present:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The file cannot be modified (e.g., a help file)
+       The file contains changes
=       The file is read-only
=+      The file is read-only, contains changes anyway</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If nothing is shown you have an ordinary, unchanged file.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_menubar">THE MENUBAR</h4>
<div class="paragraph">
<p>You know how menus work, right?  Vim has the usual items, plus a few more.
Browse them to get an idea of what you can use them for.  A relevant submenu
is Edit/Global Settings.  You will find these entries:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Toggle Toolbar          make the toolbar appear/disappear
Toggle Bottom Scrollbar make a scrollbar appear/disappear at the bottom
Toggle Left Scrollbar   make a scrollbar appear/disappear at the left
Toggle Right Scrollbar  make a scrollbar appear/disappear at the right</pre>
</div>
</div>
<div class="paragraph">
<p>On most systems you can tear-off the menus.  Select the top item of the menu,
the one that looks like a dashed line.  You will get a separate window with
the items of the menu.  It will hang around until you close the window.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_toolbar">THE TOOLBAR</h4>
<div class="paragraph">
<p>This contains icons for the most often used actions.  Hopefully the icons are
self-explanatory.  There are tooltips to get an extra hint (move the mouse
pointer to the icon without clicking and don&#8217;t move it for a second).</p>
</div>
<div class="paragraph">
<p>The "Edit/Global Settings/Toggle Toolbar" menu item can be used to make the
toolbar disappear.  If you never want a toolbar, use this command in your
vimrc file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set guioptions-=T</pre>
</div>
</div>
<div class="paragraph">
<p>This removes the 'T' flag from the 'guioptions' option.  Other parts of the
GUI can also be enabled or disabled with this option.  See the help for it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_scrollbars">THE SCROLLBARS</h4>
<div class="paragraph">
<p>By default there is one scrollbar on the right.  It does the obvious thing.
When you split the window, each window will get its own scrollbar.
   You can make a horizontal scrollbar appear with the menu item
Edit/Global Settings/Toggle Bottom Scrollbar.  This is useful in diff mode, or
when the 'wrap' option has been reset (more about that later).</p>
</div>
<div class="paragraph">
<p>When there are vertically split windows, only the windows on the right side
will have a scrollbar.  However, when you move the cursor to a window on the
left, it will be this one the that scrollbar controls.  This takes a bit of
time to get used to.
   When you work with vertically split windows, consider adding a scrollbar on
the left.  This can be done with a menu item, or with the 'guioptions' option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set guioptions+=l</pre>
</div>
</div>
<div class="paragraph">
<p>This adds the 'l' flag to 'guioptions'.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_mouse_2">Using the mouse</h3>
<div class="paragraph">
<p>Standards are wonderful.  In Microsoft Windows, you can use the mouse to
select text in a standard manner.  The X Window system also has a standard
system for using the mouse.  Unfortunately, these two standards are not the
same.
   Fortunately, you can customize Vim.  You can make the behavior of the mouse
work like an X Window system mouse or a Microsoft Windows mouse.  The following
command makes the mouse behave like an X Window mouse:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:behave xterm</pre>
</div>
</div>
<div class="paragraph">
<p>The following command makes the mouse work like a Microsoft Windows mouse:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:behave mswin</pre>
</div>
</div>
<div class="paragraph">
<p>The default behavior of the mouse on UNIX systems is xterm.  The default
behavior on a Microsoft Windows system is selected during the installation
process.  For details about what the two behaviors are, see |:behave|.  Here
follows a summary.</p>
</div>
<div class="sect3">
<h4 id="_xterm_mouse_behavior">XTERM MOUSE BEHAVIOR</h4>
<div class="paragraph">
<p>Left mouse click                position the cursor
Left mouse drag                 select text in Visual mode
Middle mouse click              paste text from the clipboard
Right mouse click               extend the selected text until the mouse
                                pointer</p>
</div>
</div>
<div class="sect3">
<h4 id="_mswin_mouse_behavior">MSWIN MOUSE BEHAVIOR</h4>
<div class="paragraph">
<p>Left mouse click                position the cursor
Left mouse drag                 select text in Select mode (see |09.4|)
Left mouse click, with Shift    extend the selected text until the mouse
                                pointer
Middle mouse click              paste text from the clipboard
Right mouse click               display a pop-up menu</p>
</div>
<div class="paragraph">
<p>The mouse can be further tuned.  Check out these options if you want to change
the way how the mouse works:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>'mouse'                 in which mode the mouse is used by Vim
'mousemodel'            what effect a mouse click has
'mousetime'             time between clicks for a double-click
'mousehide'             hide the mouse while typing
'selectmode'            whether the mouse starts Visual or Select mode</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_clipboard">The clipboard</h3>
<div class="paragraph">
<p>In section |04.7| the basic use of the clipboard was explained.  There is one
essential thing to explain about X-windows: There are actually two places to
exchange text between programs.  MS-Windows doesn&#8217;t have this.</p>
</div>
<div class="paragraph">
<p>In X-Windows there is the "current selection".  This is the text that is
currently highlighted.  In Vim this is the Visual area (this assumes you are
using the default option settings).  You can paste this selection in another
application without any further action.
   For example, in this text select a few words with the mouse.  Vim will
switch to Visual mode and highlight the text.  Now start another gvim, without
a file name argument, so that it displays an empty window.  Click the middle
mouse button.  The selected text will be inserted.</p>
</div>
<div class="paragraph">
<p>The "current selection" will only remain valid until some other text is
selected.  After doing the paste in the other gvim, now select some characters
in that window.  You will notice that the words that were previously selected
in the other gvim window are displayed differently.  This means that it no
longer is the current selection.</p>
</div>
<div class="paragraph">
<p>You don&#8217;t need to select text with the mouse, using the keyboard commands for
Visual mode works just as well.</p>
</div>
<div class="sect3">
<h4 id="_the_real_clipboard">THE REAL CLIPBOARD</h4>
<div class="paragraph">
<p>Now for the other place with which text can be exchanged.  We call this the
"real clipboard", to avoid confusion.  Often both the "current selection" and
the "real clipboard" are called clipboard, you&#8217;ll have to get used to that.
   To put text on the real clipboard, select a few different words in one of
the gvims you have running.  Then use the Edit/Copy menu entry.  Now the text
has been copied to the real clipboard.  You can&#8217;t see this, unless you have
some application that shows the clipboard contents (e.g., KDE&#8217;s Klipper).
   Now select the other gvim, position the cursor somewhere and use the
Edit/Paste menu.  You will see the text from the real clipboard is inserted.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_both">USING BOTH</h4>
<div class="paragraph">
<p>This use of both the "current selection" and the "real clipboard" might sound
a bit confusing.  But it is very useful.  Let&#8217;s show this with an example.
Use one gvim with a text file and perform these actions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Select two words in Visual mode.</p>
</li>
<li>
<p>Use the Edit/Copy menu to get these words onto the clipboard.</p>
</li>
<li>
<p>Select one other word in Visual mode.</p>
</li>
<li>
<p>Use the Edit/Paste menu item.  What will happen is that the single selected
word is replaced with the two words from the clipboard.</p>
</li>
<li>
<p>Move the mouse pointer somewhere else and click the middle button.  You
will see that the word you just overwrote with the clipboard is inserted
here.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you use the "current selection" and the "real clipboard" with care, you can
do a lot of useful editing with them.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_the_keyboard">USING THE KEYBOARD</h4>
<div class="paragraph">
<p>If you don&#8217;t like using the mouse, you can access the current selection and
the real clipboard with two registers.  The "* register is for the current
selection.
   To make text become the current selection, use Visual mode.  For example,
to select a whole line just press "V".
   To insert the current selection before the cursor:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"*P</pre>
</div>
</div>
<div class="paragraph">
<p>Notice the uppercase "P".  The lowercase "p" puts the text after the cursor.</p>
</div>
<div class="paragraph">
<p>The "+ register is used for the real clipboard.  For example, to copy the text
from the cursor position until the end of the line to the clipboard:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"+y$</pre>
</div>
</div>
<div class="paragraph">
<p>Remember, "y" is yank, which is Vim&#8217;s copy command.
   To insert the contents of the real clipboard before the cursor:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"+P</pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s the same as for the current selection, but uses the plus (+) register
instead of the star (*) register.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_select_mode">Select mode</h3>
<div class="paragraph">
<p>And now something that is used more often on MS-Windows than on X-Windows.
But both can do it.  You already know about Visual mode.  Select mode is like
Visual mode, because it is also used to select text.  But there is an obvious
difference: When typing text, the selected text is deleted and the typed text
replaces it.</p>
</div>
<div class="paragraph">
<p>To start working with Select mode, you must first enable it (for MS-Windows
it is probably already enabled, but you can do this anyway):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set selectmode+=mouse</pre>
</div>
</div>
<div class="paragraph">
<p>Now use the mouse to select some text.  It is highlighted like in Visual mode.
Now press a letter.  The selected text is deleted, and the single letter
replaces it.  You are in Insert mode now, thus you can continue typing.</p>
</div>
<div class="paragraph">
<p>Since typing normal text causes the selected text to be deleted, you can not
use the normal movement commands "hjkl", "w", etc.  Instead, use the shifted
function keys.  &lt;S-Left&gt; (shifted cursor left key) moves the cursor left.  The
selected text is changed like in Visual mode.  The other shifted cursor keys
do what you expect.  &lt;S-End&gt; and &lt;S-Home&gt; also work.</p>
</div>
<div class="paragraph">
<p>You can tune the way Select mode works with the 'selectmode' option.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_10.txt|  Making big changes</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_making_big_changes">Making big changes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In chapter 4 several ways to make small changes were explained.  This chapter
goes into making changes that are repeated or can affect a large amount of
text.  The Visual mode allows doing various things with blocks of text.  Use
an external program to do really complicated things.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Record and playback commands</p>
</li>
<li>
<p>Substitution</p>
</li>
<li>
<p>Command ranges</p>
</li>
<li>
<p>The global command</p>
</li>
<li>
<p>Visual block mode</p>
</li>
<li>
<p>Reading and writing part of a file</p>
</li>
<li>
<p>Formatting text</p>
</li>
<li>
<p>Changing case</p>
</li>
<li>
<p>Using an external program</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_record_and_playback_commands">Record and playback commands</h3>
<div class="paragraph">
<p>The "." command repeats the preceding change.  But what if you want to do
something more complex than a single change?  That&#8217;s where command recording
comes in.  There are three steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The "q{register}" command starts recording keystrokes into the register
named {register}.  The register name must be between a and z.</p>
</li>
<li>
<p>Type your commands.</p>
</li>
<li>
<p>To finish recording, press q (without any extra character).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can now execute the macro by typing the command "@{register}".</p>
</div>
<div class="paragraph">
<p>Take a look at how to use these commands in practice.  You have a list of
filenames that look like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>stdio.h
fcntl.h
unistd.h
stdlib.h</pre>
</div>
</div>
<div class="paragraph">
<p>And what you want is the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#include "stdio.h"
#include "fcntl.h"
#include "unistd.h"
#include "stdlib.h"</pre>
</div>
</div>
<div class="paragraph">
<p>You start by moving to the first character of the first line.  Next you
execute the following commands:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>qa                      Start recording a macro in register a.
^                       Move to the beginning of the line.
i#include "&lt;Esc&gt;        Insert the string #include " at the beginning
                        of the line.
$                       Move to the end of the line.
a"&lt;Esc&gt;                 Append the character double quotation mark (")
                        to the end of the line.
j                       Go to the next line.
q                       Stop recording the macro.</pre>
</div>
</div>
<div class="paragraph">
<p>Now that you have done the work once, you can repeat the change by typing the
command "@a" three times.
   The "@a" command can be preceded by a count, which will cause the macro to
be executed that number of times.  In this case you would type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>3@a</pre>
</div>
</div>
<div class="sect3">
<h4 id="_move_and_execute">MOVE AND EXECUTE</h4>
<div class="paragraph">
<p>You might have the lines you want to change in various places.  Just move the
cursor to each location and use the "@a" command.  If you have done that once,
you can do it again with "@@".  That&#8217;s a bit easier to type.  If you now
execute register b with "@b", the next "@@" will use register b.
   If you compare the playback method with using ".", there are several
differences.  First of all, "." can only repeat one change.  As seen in the
example above, "@a" can do several changes, and move around as well.
Secondly, "." can only remember the last change.  Executing a register allows
you to make any changes and then still use "@a" to replay the recorded
commands.  Finally, you can use 26 different registers.  Thus you can remember
26 different command sequences to execute.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_registers_2">USING REGISTERS</h4>
<div class="paragraph">
<p>The registers used for recording are the same ones you used for yank and
delete commands.  This allows you to mix recording with other commands to
manipulate the registers.
   Suppose you have recorded a few commands in register n.  When you execute
this with "@n" you notice you did something wrong.  You could try recording
again, but perhaps you will make another mistake.  Instead, use this trick:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>G                       Go to the end of the file.
o&lt;Esc&gt;                  Create an empty line.
"np                     Put the text from the n register.  You now see
                        the commands you typed as text in the file.
{edits}                 Change the commands that were wrong.  This is
                        just like editing text.
0                       Go to the start of the line.
"ny$                    Yank the corrected commands into the n
                        register.
dd                      Delete the scratch line.</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can execute the corrected commands with "@n".  (If your recorded
commands include line breaks, adjust the last two items in the example to
include all the lines.)</p>
</div>
</div>
<div class="sect3">
<h4 id="_appending_to_a_register">APPENDING TO A REGISTER</h4>
<div class="paragraph">
<p>So far we have used a lowercase letter for the register name.  To append to a
register, use an uppercase letter.
   Suppose you have recorded a command to change a word to register c.  It
works properly, but you would like to add a search for the next word to
change.  This can be done with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>qC/word&lt;Enter&gt;q</pre>
</div>
</div>
<div class="paragraph">
<p>You start with "qC", which records to the c register and appends.  Thus
writing to an uppercase register name means to append to the register with
the same letter, but lowercase.</p>
</div>
<div class="paragraph">
<p>This works both with recording and with yank and delete commands.  For
example, you want to collect a sequence of lines into the a register.  Yank
the first line with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"aY</pre>
</div>
</div>
<div class="paragraph">
<p>Now move to the second line, and type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"AY</pre>
</div>
</div>
<div class="paragraph">
<p>Repeat this command for all lines.  The a register now contains all those
lines, in the order you yanked them.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_substitution">Substitution</h3>
<div class="paragraph">
<p>The ":substitute" command enables you to perform string replacements on a
whole range of lines.  The general form of this command is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:[range]substitute/from/to/[flags]</pre>
</div>
</div>
<div class="paragraph">
<p>This command changes the "from" string to the "to" string in the lines
specified with [range].  For example, you can change "Professor" to "Teacher"
in all lines with the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:%substitute/Professor/Teacher/</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
The ":substitute" command is almost never spelled out completely.
Most of the time, people use the abbreviated version ":s".  From here
on the abbreviation will be used.</pre>
</div>
</div>
<div class="paragraph">
<p>The "%" before the command specifies the command works on all lines.  Without
a range, ":s" only works on the current line.  More about ranges in the next
section |10.3|.</p>
</div>
<div class="paragraph">
<p>By default, the ":substitute" command changes only the first occurrence on
each line.  For example, the preceding command changes the line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Professor Smith criticized Professor Johnson today.</pre>
</div>
</div>
<div class="paragraph">
<p>to:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Teacher Smith criticized Professor Johnson today.</pre>
</div>
</div>
<div class="paragraph">
<p>To change every occurrence on the line, you need to add the g (global) flag.
The command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:%s/Professor/Teacher/g</pre>
</div>
</div>
<div class="paragraph">
<p>results in (starting with the original line):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Teacher Smith criticized Teacher Johnson today.</pre>
</div>
</div>
<div class="paragraph">
<p>Other flags include p (print), which causes the ":substitute" command to print
out the last line it changes.  The c (confirm) flag tells ":substitute" to ask
you for confirmation before it performs each substitution.  Enter the
following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:%s/Professor/Teacher/c</pre>
</div>
</div>
<div class="paragraph">
<p>Vim finds the first occurrence of "Professor" and displays the text it is
about to change.  You get the following prompt:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>replace with Teacher (y/n/a/q/l/^E/^Y)?</pre>
</div>
</div>
<div class="paragraph">
<p>At this point, you must enter one of the following answers:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>y               Yes; make this change.
n               No; skip this match.
a               All; make this change and all remaining ones without
                further confirmation.
q               Quit; don't make any more changes.
l               Last; make this change and then quit.
CTRL-E          Scroll the text one line up.
CTRL-Y          Scroll the text one line down.</pre>
</div>
</div>
<div class="paragraph">
<p>The "from" part of the substitute command is actually a pattern.  The same
kind as used for the search command.  For example, this command only
substitutes "the" when it appears at the start of a line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:s/^the/these/</pre>
</div>
</div>
<div class="paragraph">
<p>If you are substituting with a "from" or "to" part that includes a slash, you
need to put a backslash before it.  A simpler way is to use another character
instead of the slash.  A plus, for example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:s+one/two+one or two+</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_command_ranges">Command ranges</h3>
<div class="paragraph">
<p>The ":substitute" command, and many other : commands, can be applied to a
selection of lines.  This is called a range.
   The simple form of a range is {number},{number}.  For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:1,5s/this/that/g</pre>
</div>
</div>
<div class="paragraph">
<p>Executes the substitute command on the lines 1 to 5.  Line 5 is included.
The range is always placed before the command.</p>
</div>
<div class="paragraph">
<p>A single number can be used to address one specific line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:54s/President/Fool/</pre>
</div>
</div>
<div class="paragraph">
<p>Some commands work on the whole file when you do not specify a range.  To make
them work on the current line the "." address is used.  The ":write" command
works like that.  Without a range, it writes the whole file.  To make it write
only the current line into a file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:.write otherfile</pre>
</div>
</div>
<div class="paragraph">
<p>The first line always has number one.  How about the last line?  The "$"
character is used for this.  For example, to substitute in the lines from the
cursor to the end:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:.,$s/yes/no/</pre>
</div>
</div>
<div class="paragraph">
<p>The "%" range that we used before, is actually a short way to say "1,$", from
the first to the last line.</p>
</div>
<div class="sect3">
<h4 id="_using_a_pattern_in_a_range">USING A PATTERN IN A RANGE</h4>
<div class="paragraph">
<p>Suppose you are editing a chapter in a book, and want to replace all
occurrences of "grey" with "gray".  But only in this chapter, not in the next
one.  You know that only chapter boundaries have the word "Chapter" in the
first column.  This command will work then:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:?^Chapter?,/^Chapter/s=grey=gray=g</pre>
</div>
</div>
<div class="paragraph">
<p>You can see a search pattern is used twice.  The first "?^Chapter?" finds the
line above the current position that matches this pattern.  Thus the ?pattern?
range is used to search backwards.  Similarly, "/^Chapter/" is used to search
forward for the start of the next chapter.
   To avoid confusion with the slashes, the "=" character was used in the
substitute command here.  A slash or another character would have worked as
well.</p>
</div>
</div>
<div class="sect3">
<h4 id="_add_and_subtract">ADD AND SUBTRACT</h4>
<div class="paragraph">
<p>There is a slight error in the above command: If the title of the next chapter
had included "grey" it would be replaced as well.  Maybe that&#8217;s what you
wanted, but what if you didn&#8217;t?  Then you can specify an offset.
   To search for a pattern and then use the line above it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/Chapter/-1</pre>
</div>
</div>
<div class="paragraph">
<p>You can use any number instead of the 1.  To address the second line below the
match:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/Chapter/+2</pre>
</div>
</div>
<div class="paragraph">
<p>The offsets can also be used with the other items in a range.  Look at this
one:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:.+3,$-5</pre>
</div>
</div>
<div class="paragraph">
<p>This specifies the range that starts three lines below the cursor and ends
five lines before the last line in the file.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_marks_2">USING MARKS</h4>
<div class="paragraph">
<p>Instead of figuring out the line numbers of certain positions, remembering them
and typing them in a range, you can use marks.
   Place the marks as mentioned in chapter 3.  For example, use "mt" to mark
the top of an area and "mb" to mark the bottom.  Then you can use this range
to specify the lines between the marks (including the lines with the marks):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:'t,'b</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_visual_mode_and_ranges">VISUAL MODE AND RANGES</h4>
<div class="paragraph">
<p>You can select text with Visual mode.  If you then press ":" to start a colon
command, you will see this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:'&lt;,'&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can type the command and it will be applied to the range of lines that
was visually selected.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
When using Visual mode to select part of a line, or using CTRL-V to
select a block of text, the colon commands will still apply to whole
lines.  This might change in a future version of Vim.</pre>
</div>
</div>
<div class="paragraph">
<p>The '&lt; and '&gt; are actually marks, placed at the start and end of the Visual
selection.  The marks remain at their position until another Visual selection
is made.  Thus you can use the "'&lt;" command to jump to position where the
Visual area started.  And you can mix the marks with other items:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:'&gt;,$</pre>
</div>
</div>
<div class="paragraph">
<p>This addresses the lines from the end of the Visual area to the end of the
file.</p>
</div>
</div>
<div class="sect3">
<h4 id="_a_number_of_lines">A NUMBER OF LINES</h4>
<div class="paragraph">
<p>When you know how many lines you want to change, you can type the number and
then ":".  For example, when you type "5:", you will get:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:.,.+4</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can type the command you want to use.  It will use the range "."
(current line) until ".+4" (four lines down).  Thus it spans five lines.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_global_command">The global command</h3>
<div class="paragraph">
<p>The ":global" command is one of the more powerful features of Vim.  It allows
you to find a match for a pattern and execute a command there.  The general
form is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:[range]global/{pattern}/{command}</pre>
</div>
</div>
<div class="paragraph">
<p>This is similar to the ":substitute" command.  But, instead of replacing the
matched text with other text, the command {command} is executed.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
The command executed for ":global" must be one that starts with a
colon.  Normal mode commands can not be used directly.  The |:normal|
command can do this for you.</pre>
</div>
</div>
<div class="paragraph">
<p>Suppose you want to change "foobar" to "barfoo", but only in C++ style
comments.  These comments start with "//".  Use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:g+//+s/foobar/barfoo/g</pre>
</div>
</div>
<div class="paragraph">
<p>This starts with ":g".  That is short for ":global", just like ":s" is short
for ":substitute".  Then the pattern, enclosed in plus characters.  Since the
pattern we are looking for contains a slash, this uses the plus character to
separate the pattern.  Next comes the substitute command that changes "foobar"
into "barfoo".
   The default range for the global command is the whole file.  Thus no range
was specified in this example.  This is different from ":substitute", which
works on one line without a range.
   The command isn&#8217;t perfect, since it also matches lines where "//" appears
halfway through a line, and the substitution will also take place before the
"//".</p>
</div>
<div class="paragraph">
<p>Just like with ":substitute", any pattern can be used.  When you learn more
complicated patterns later, you can use them here.</p>
</div>
</div>
<div class="sect2">
<h3 id="_visual_block_mode">Visual block mode</h3>
<div class="paragraph">
<p>With CTRL-V you can start selection of a rectangular area of text.  There are
a few commands that do something special with the text block.</p>
</div>
<div class="paragraph">
<p>There is something special about using the "$" command in Visual block mode.
When the last motion command used was "$", all lines in the Visual selection
will extend until the end of the line, also when the line with the cursor is
shorter.  This remains effective until you use a motion command that moves the
cursor horizontally.  Thus using "j" keeps it, "h" stops it.</p>
</div>
<div class="sect3">
<h4 id="_inserting_text_2">INSERTING TEXT</h4>
<div class="paragraph">
<p>The command  "I{string}&lt;Esc&gt;" inserts the text {string} in each line, just
left of the visual block.  You start by pressing CTRL-V to enter visual block
mode.  Now you move the cursor to define your block.  Next you type I to enter
Insert mode, followed by the text to insert.  As you type, the text appears on
the first line only.
   After you press &lt;Esc&gt; to end the insert, the text will magically be
inserted in the rest of the lines contained in the visual selection.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>include one
include two
include three
include four</pre>
</div>
</div>
<div class="paragraph">
<p>Move the cursor to the "o" of "one" and press CTRL-V.  Move it down with "3j"
to "four".  You now have a block selection that spans four lines.  Now type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Imain.&lt;Esc&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The result:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>include main.one
include main.two
include main.three
include main.four</pre>
</div>
</div>
<div class="paragraph">
<p>If the block spans short lines that do not extend into the block, the text is
not inserted in that line.  For example, make a Visual block selection that
includes the word "long" in the first and last line of this text, and thus has
no text selected in the second line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>This is a long line
short
Any other long line</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>^^^^ selected block</pre>
</div>
</div>
<div class="paragraph">
<p>Now use the command "Ivery &lt;Esc&gt;".  The result is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>This is a very long line
short
Any other very long line</pre>
</div>
</div>
<div class="paragraph">
<p>In the short line no text was inserted.</p>
</div>
<div class="paragraph">
<p>If the string you insert contains a newline, the "I" acts just like a Normal
insert command and affects only the first line of the block.</p>
</div>
<div class="paragraph">
<p>The "A" command works the same way, except that it appends after the right
side of the block.  And it does insert text in a short line.  Thus you can
make a choice whether you do or don&#8217;t want to append text to a short line.
   There is one special case for "A": Select a Visual block and then use "$"
to make the block extend to the end of each line.  Using "A" now will append
the text to the end of each line.
   Using the same example from above, and then typing "$A XXX&lt;Esc&gt;, you get
this result:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>This is a long line XXX
short XXX
Any other long line XXX</pre>
</div>
</div>
<div class="paragraph">
<p>This really requires using the "$" command.  Vim remembers that it was used.
Making the same selection by moving the cursor to the end of the longest line
with other movement commands will not have the same result.</p>
</div>
</div>
<div class="sect3">
<h4 id="_changing_text_2">CHANGING TEXT</h4>
<div class="paragraph">
<p>The Visual block "c" command deletes the block and then throws you into Insert
mode to enable you to type in a string.  The string will be inserted in each
line in the block.
   Starting with the same selection of the "long" words as above, then typing
"c_LONG_&lt;Esc&gt;", you get this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>This is a _LONG_ line
short
Any other _LONG_ line</pre>
</div>
</div>
<div class="paragraph">
<p>Just like with "I" the short line is not changed.  Also, you can&#8217;t enter a
newline in the new text.</p>
</div>
<div class="paragraph">
<p>The "C" command deletes text from the left edge of the block to the end of
line.  It then puts you in Insert mode so that you can type in a string,
which is added to the end of each line.
   Starting with the same text again, and typing "Cnew text&lt;Esc&gt;" you get:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>This is a new text
short
Any other new text</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that, even though only the "long" word was selected, the text after it
is deleted as well.  Thus only the location of the left edge of the visual
block really matters.
   Again, short lines that do not reach into the block are excluded.</p>
</div>
<div class="paragraph">
<p>Other commands that change the characters in the block:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>~       swap case       (a -&gt; A and A -&gt; a)
U       make uppercase  (a -&gt; A and A -&gt; A)
u       make lowercase  (a -&gt; a and A -&gt; a)</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_filling_with_a_character">FILLING WITH A CHARACTER</h4>
<div class="paragraph">
<p>To fill the whole block with one character, use the "r" command.  Again,
starting with the same example text from above, and then typing "rx":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>This is a xxxx line
short
Any other xxxx line</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
If you want to include characters beyond the end of the line in the
block, check out the 'virtualedit' feature in chapter 25.</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_shifting">SHIFTING</h4>
<div class="paragraph">
<p>The command "&gt;" shifts the selected text to the right one shift amount,
inserting whitespace.  The starting point for this shift is the left edge of
the visual block.
   With the same example again, "&gt;" gives this result:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>This is a         long line
short
Any other         long line</pre>
</div>
</div>
<div class="paragraph">
<p>The shift amount is specified with the 'shiftwidth' option.  To change it to
use 4 spaces:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set shiftwidth=4</pre>
</div>
</div>
<div class="paragraph">
<p>The "&lt;" command removes one shift amount of whitespace at the left
edge of the block.  This command is limited by the amount of text that is
there; so if there is less than a shift amount of whitespace available, it
removes what it can.</p>
</div>
</div>
<div class="sect3">
<h4 id="_joining_lines">JOINING LINES</h4>
<div class="paragraph">
<p>The "J" command joins all selected lines together into one line.  Thus it
removes the line breaks.  Actually, the line break, leading white space and
trailing white space is replaced by one space.  Two spaces are used after a
line ending (that can be changed with the 'joinspaces' option).
   Let&#8217;s use the example that we got so familiar with now.  The result of
using the "J" command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>This is a long line short Any other long line</pre>
</div>
</div>
<div class="paragraph">
<p>The "J" command doesn&#8217;t require a blockwise selection.  It works with "v" and
"V" selection in exactly the same way.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t want the white space to be changed, use the "gJ" command.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reading_and_writing_part_of_a_file">Reading and writing part of a file</h3>
<div class="paragraph">
<p>When you are writing an e-mail message, you may want to include another file.
This can be done with the ":read {filename}" command.  The text of the file is
put below the cursor line.
   Starting with this text:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Hi John,
Here is the diff that fixes the bug:
Bye, Pierre.</pre>
</div>
</div>
<div class="paragraph">
<p>Move the cursor to the second line and type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:read patch</pre>
</div>
</div>
<div class="paragraph">
<p>The file named "patch" will be inserted, with this result:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Hi John,
Here is the diff that fixes the bug:
2c2
&lt;       for (i = 0; i &lt;= length; ++i)
---
&gt;       for (i = 0; i &lt; length; ++i)
Bye, Pierre.</pre>
</div>
</div>
<div class="paragraph">
<p>The ":read" command accepts a range.  The file will be put below the last line
number of this range.  Thus ":$r patch" appends the file "patch" at the end of
the file.
   What if you want to read the file above the first line?  This can be done
with the line number zero.  This line doesn&#8217;t really exist, you will get an
error message when using it with most commands.  But this command is allowed:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:0read patch</pre>
</div>
</div>
<div class="paragraph">
<p>The file "patch" will be put above the first line of the file.</p>
</div>
<div class="sect3">
<h4 id="_writing_a_range_of_lines">WRITING A RANGE OF LINES</h4>
<div class="paragraph">
<p>To write a range of lines to a file, the ":write" command can be used.
Without a range it writes the whole file.  With a range only the specified
lines are written:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:.,$write tempo</pre>
</div>
</div>
<div class="paragraph">
<p>This writes the lines from the cursor until the end of the file into the file
"tempo".  If this file already exists you will get an error message.  Vim
protects you from accidentally overwriting an existing file.  If you know what
you are doing and want to overwrite the file, append !:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:.,$write! tempo</pre>
</div>
</div>
<div class="paragraph">
<p>CAREFUL: The ! must follow the ":write" command immediately, without white
space.  Otherwise it becomes a filter command, which is explained later in
this chapter.</p>
</div>
</div>
<div class="sect3">
<h4 id="_appending_to_a_file_2">APPENDING TO A FILE</h4>
<div class="paragraph">
<p>In the first section of this chapter was explained how to collect a number of
lines into a register.  The same can be done to collect lines in a file.
Write the first line with this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:.write collection</pre>
</div>
</div>
<div class="paragraph">
<p>Now move the cursor to the second line you want to collect, and type this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:.write &gt;&gt;collection</pre>
</div>
</div>
<div class="paragraph">
<p>The "&gt;&gt;" tells Vim the "collection" file is not to be written as a new file,
but the line must be appended at the end.   You can repeat this as many times
as you like.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_formatting_text">Formatting text</h3>
<div class="paragraph">
<p>When you are typing plain text, it&#8217;s nice if the length of each line is
automatically trimmed to fit in the window.  To make this happen while
inserting text, set the 'textwidth' option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set textwidth=72</pre>
</div>
</div>
<div class="paragraph">
<p>You might remember that in the example vimrc file this command was used for
every text file.  Thus if you are using that vimrc file, you were already
using it.  To check the current value of 'textwidth':</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set textwidth</pre>
</div>
</div>
<div class="paragraph">
<p>Now lines will be broken to take only up to 72 characters.  But when you
insert text halfway through a line, or when you delete a few words, the lines
will get too long or too short.  Vim doesn&#8217;t automatically reformat the text.
   To tell Vim to format the current paragraph:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gqap</pre>
</div>
</div>
<div class="paragraph">
<p>This starts with the "gq" command, which is an operator.  Following is "ap",
the text object that stands for "a paragraph".  A paragraph is separated from
the next paragraph by an empty line.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
A blank line, which contains white space, does NOT separate
paragraphs.  This is hard to notice!</pre>
</div>
</div>
<div class="paragraph">
<p>Instead of "ap" you could use any motion or text object.  If your paragraphs
are properly separated, you can use this command to format the whole file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gggqG</pre>
</div>
</div>
<div class="paragraph">
<p>"gg" takes you to the first line, "gq" is the format operator and "G" the
motion that jumps to the last line.</p>
</div>
<div class="paragraph">
<p>In case your paragraphs aren&#8217;t clearly defined, you can format just the lines
you manually select.  Move the cursor to the first line you want to format.
Start with the command "gqj".  This formats the current line and the one below
it.  If the first line was short, words from the next line will be appended.
If it was too long, words will be moved to the next line.  The cursor moves to
the second line.  Now you can use "." to repeat the command.  Keep doing this
until you are at the end of the text you want to format.</p>
</div>
</div>
<div class="sect2">
<h3 id="_changing_case">Changing case</h3>
<div class="paragraph">
<p>You have text with section headers in lowercase.  You want to make the word
"section" all uppercase.  Do this with the "gU" operator.  Start with the
cursor in the first column:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>                             gUw
&lt;       section header      ----&gt;      SECTION header</pre>
</div>
</div>
<div class="paragraph">
<p>The "gu" operator does exactly the opposite:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>                             guw
&lt;       SECTION header      ----&gt;      section header</pre>
</div>
</div>
<div class="paragraph">
<p>You can also use "g~" to swap case.  All these are operators, thus they work
with any motion command, with text objects and in Visual mode.
   To make an operator work on lines you double it.  The delete operator is
"d", thus to delete a line you use "dd".  Similarly, "gugu" makes a whole line
lowercase.  This can be shortened to "guu".  "gUgU" is shortened to "gUU" and
"g<sub>g</sub>" to "g~~".  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>                                g~~
&lt;       Some GIRLS have Fun    ----&gt;   sOME girls HAVE fUN</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_an_external_program">Using an external program</h3>
<div class="paragraph">
<p>Vim has a very powerful set of commands, it can do anything.  But there may
still be something that an external command can do better or faster.
   The command "!{motion}{program}" takes a block of text and filters it
through an external program.  In other words, it runs the system command
represented by {program}, giving it the block of text represented by {motion}
as input.  The output of this command then replaces the selected block.
   Because this summarizes badly if you are unfamiliar with UNIX filters, take
a look at an example.  The sort command sorts a file.  If you execute the
following command, the unsorted file input.txt will be sorted and written to
output.txt.  (This works on both UNIX and Microsoft Windows.) &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>sort &lt;input.txt &gt;output.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Now do the same thing in Vim.  You want to sort lines 1 through 5 of a file.
You start by putting the cursor on line 1.  Next you execute the following
command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>!5G</pre>
</div>
</div>
<div class="paragraph">
<p>The "!" tells Vim that you are performing a filter operation.  The Vim editor
expects a motion command to follow, indicating which part of the file to
filter.  The "5G" command tells Vim to go to line 5, so it now knows that it
is to filter lines 1 (the current line) through 5.
   In anticipation of the filtering, the cursor drops to the bottom of the
screen and a ! prompt displays.  You can now type in the name of the filter
program, in this case "sort".  Therefore, your full command is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>!5Gsort&lt;Enter&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The result is that the sort program is run on the first 5 lines.  The output
of the program replaces these lines.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>line 55                       line 11
line 33                       line 22
line 11         --&gt;           line 33
line 22                       line 44
line 44                       line 55
last line                     last line</pre>
</div>
</div>
<div class="paragraph">
<p>The "!!" command filters the current line through a filter.  In Unix the "date"
command prints the current time and date.  "!!date&lt;Enter&gt;" replaces the current
line with the output of "date".  This is useful to add a timestamp to a file.</p>
</div>
<div class="paragraph">
<p>WHEN IT DOESN&#8217;T WORK</p>
</div>
<div class="paragraph">
<p>Starting a shell, sending it text and capturing the output requires that Vim
knows how the shell works exactly.  When you have problems with filtering,
check the values of these options:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>'shell'         specifies the program that Vim uses to execute
                external programs.
'shellcmdflag'  argument to pass a command to the shell
'shellquote'    quote to be used around the command
'shellxquote'   quote to be used around the command and redirection
'shelltype'     kind of shell (only for the Amiga)
'shellslash'    use forward slashes in the command (only for
                MS-Windows and alikes)
'shellredir'    string used to write the command output into a file</pre>
</div>
</div>
<div class="paragraph">
<p>On Unix this is hardly ever a problem, because there are two kinds of shells:
"sh" like and "csh" like.  Vim checks the 'shell' option and sets related
options automatically, depending on whether it sees "csh" somewhere in
'shell'.
   On MS-Windows, however, there are many different shells and you might have
to tune the options to make filtering work.  Check the help for the options
for more information.</p>
</div>
<div class="sect3">
<h4 id="_reading_command_output">READING COMMAND OUTPUT</h4>
<div class="paragraph">
<p>To read the contents of the current directory into the file, use this:</p>
</div>
<div class="paragraph">
<p>on Unix:
        :read !ls
on MS-Windows:
        :read !dir</p>
</div>
<div class="paragraph">
<p>The output of the "ls" or "dir" command is captured and inserted in the text,
below the cursor.  This is similar to reading a file, except that the "!" is
used to tell Vim that a command follows.
   The command may have arguments.  And a range can be used to tell where Vim
should put the lines:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:0read !date -u</pre>
</div>
</div>
<div class="paragraph">
<p>This inserts the current time and date in UTC format at the top of the file.
(Well, if you have a date command that accepts the "-u" argument.)  Note the
difference with using "!!date": that replaced a line, while ":read !date" will
insert a line.</p>
</div>
</div>
<div class="sect3">
<h4 id="_writing_text_to_a_command">WRITING TEXT TO A COMMAND</h4>
<div class="paragraph">
<p>The Unix command "wc" counts words.  To count the words in the current file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:write !wc</pre>
</div>
</div>
<div class="paragraph">
<p>This is the same write command as before, but instead of a file name the "!"
character is used and the name of an external command.  The written text will
be passed to the specified command as its standard input.  The output could
look like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>4      47     249</pre>
</div>
</div>
<div class="paragraph">
<p>The "wc" command isn&#8217;t verbose.  This means you have 4 lines, 47 words and 249
characters.</p>
</div>
<div class="paragraph">
<p>Watch out for this mistake:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:write! wc</pre>
</div>
</div>
<div class="paragraph">
<p>This will write the file "wc" in the current directory, with force.  White
space is important here!</p>
</div>
</div>
<div class="sect3">
<h4 id="_redrawing_the_screen">REDRAWING THE SCREEN</h4>
<div class="paragraph">
<p>If the external command produced an error message, the display may have been
messed up.  Vim is very efficient and only redraws those parts of the screen
that it knows need redrawing.  But it can&#8217;t know about what another program
has written.  To tell Vim to redraw the screen:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-L</pre>
</div>
</div>
<div class="paragraph">
<p>Next chapter: |usr_11.txt|  Recovering from a crash</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_recovering_from_a_crash">Recovering from a crash</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Did your computer crash?  And you just spent hours editing?  Don&#8217;t panic!  Vim
stores enough information to be able to restore most of your work.  This
chapter shows you how to get your work back and explains how the swap file is
used.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Basic recovery</p>
</li>
<li>
<p>Where is the swap file?</p>
</li>
<li>
<p>Crashed or not?</p>
</li>
<li>
<p>Further reading</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_basic_recovery">Basic recovery</h3>
<div class="paragraph">
<p>In most cases recovering a file is quite simple, assuming you know which file
you were editing (and the harddisk is still working).  Start Vim on the file,
with the "-r" argument added:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim -r help.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will read the swap file (used to store text you were editing) and may read
bits and pieces of the original file.  If Vim recovered your changes you will
see these messages (with different file names, of course):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Using swap file ".help.txt.swp"
Original file "~/vim/runtime/doc/help.txt"
Recovery completed. You should check if everything is OK.
(You might want to write out this file under another name
and run diff with the original file to check for changes)
You may want to delete the .swp file now.</pre>
</div>
</div>
<div class="paragraph">
<p>To be on the safe side, write this file under another name:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:write help.txt.recovered</pre>
</div>
</div>
<div class="paragraph">
<p>Compare the file with the original file to check if you ended up with what you
expected.  Vimdiff is very useful for this |08.7|.  For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:write help.txt.recovered
:edit #
:diffsp help.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Watch out for the original file to contain a more recent version (you saved
the file just before the computer crashed).  And check that no lines are
missing (something went wrong that Vim could not recover).
   If Vim produces warning messages when recovering, read them carefully.
This is rare though.</p>
</div>
<div class="paragraph">
<p>If the recovery resulted in text that is exactly the same as the file
contents, you will get this message:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Using swap file ".help.txt.swp"
Original file "~/vim/runtime/doc/help.txt"
Recovery completed. Buffer contents equals file contents.
You may want to delete the .swp file now.</pre>
</div>
</div>
<div class="paragraph">
<p>This usually happens if you already recovered your changes, or you wrote the
file after making changes.  It is safe to delete the swap file now.</p>
</div>
<div class="paragraph">
<p>It is normal that the last few changes can not be recovered.  Vim flushes the
changes to disk when you don&#8217;t type for about four seconds, or after typing
about two hundred characters.  This is set with the 'updatetime' and
'updatecount' options.  Thus when Vim didn&#8217;t get a chance to save itself when
the system went down, the changes after the last flush will be lost.</p>
</div>
<div class="paragraph">
<p>If you were editing without a file name, give an empty string as argument:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim -r ""</pre>
</div>
</div>
<div class="paragraph">
<p>You must be in the right directory, otherwise Vim can&#8217;t find the swap file.</p>
</div>
</div>
<div class="sect2">
<h3 id="_where_is_the_swap_file">Where is the swap file?</h3>
<div class="paragraph">
<p>Vim can store the swap file in several places.  Normally it is in the same
directory as the original file.  To find it, change to the directory of the
file, and use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim -r</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will list the swap files that it can find.  It will also look in other
directories where the swap file for files in the current directory may be
located.  It will not find swap files in any other directories though, it
doesn&#8217;t search the directory tree.
   The output could look like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Swap files found:
   In current directory:
1.    .main.c.swp
          owned by: mool   dated: Tue May 29 21:00:25 2001
         file name: ~mool/vim/vim6/src/main.c
          modified: YES
         user name: mool   host name: masaka.moolenaar.net
        process ID: 12525
   In directory ~/tmp:
      -- none --
   In directory /var/tmp:
      -- none --
   In directory /tmp:
      -- none --</pre>
</div>
</div>
<div class="paragraph">
<p>If there are several swap files that look like they may be the one you want to
use, a list is given of these swap files and you are requested to enter the
number of the one you want to use.  Carefully look at the dates to decide
which one you want to use.
   In case you don&#8217;t know which one to use, just try them one by one and check
the resulting files if they are what you expected.</p>
</div>
<div class="sect3">
<h4 id="_using_a_specific_swap_file">USING A SPECIFIC SWAP FILE</h4>
<div class="paragraph">
<p>If you know which swap file needs to be used, you can recover by giving the
swap file name.  Vim will then find out the name of the original file from
the swap file.</p>
</div>
<div class="paragraph">
<p>Example:
        vim -r .help.txt.swo</p>
</div>
<div class="paragraph">
<p>This is also handy when the swap file is in another directory than expected.
Vim recognizes files with the pattern *.s[uvw][a-z] as swap files.</p>
</div>
<div class="paragraph">
<p>If this still does not work, see what file names Vim reports and rename the
files accordingly.  Check the 'directory' option to see where Vim may have
put the swap file.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
Vim tries to find the swap file by searching the directories in the
'dir' option, looking for files that match "filename.sw?".  If
wildcard expansion doesn't work (e.g., when the 'shell' option is
invalid), Vim does a desperate try to find the file "filename.swp".
If that fails too, you will have to give the name of the swapfile
itself to be able to recover the file.</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_crashed_or_not">Crashed or not?</h3>
<div class="paragraph">
<p>Vim tries to protect you from doing stupid things.  Suppose you innocently
start editing a file, expecting the contents of the file to show up.  Instead,
Vim produces a very long message:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        E325: ATTENTION
Found a swap file by the name ".main.c.swp"
          owned by: mool   dated: Tue May 29 21:09:28 2001
         file name: ~mool/vim/vim6/src/main.c
          modified: no
         user name: mool   host name: masaka.moolenaar.net
        process ID: 12559 (still running)
While opening file "main.c"
             dated: Tue May 29 19:46:12 2001</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>(1) Another program may be editing the same file.
    If this is the case, be careful not to end up with two
    different instances of the same file when making changes.
    Quit, or continue with caution.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>(2) An edit session for this file crashed.
    If this is the case, use ":recover" or "vim -r main.c"
    to recover the changes (see ":help recovery").
    If you did this already, delete the swap file ".main.c.swp"
    to avoid this message.</pre>
</div>
</div>
<div class="paragraph">
<p>You get this message, because, when starting to edit a file, Vim checks if a
swap file already exists for that file.  If there is one, there must be
something wrong.  It may be one of these two situations.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Another edit session is active on this file.  Look in the message for the
line with "process ID".  It might look like this:</p>
<div class="literalblock">
<div class="content">
<pre>process ID: 12559 (still running)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>The text "(still running)" indicates that the process editing this file
runs on the same computer.  When working on a non-Unix system you will not
get this extra hint.  When editing a file over a network, you may not see
the hint, because the process might be running on another computer.  In
those two cases you must find out what the situation is yourself.
   If there is another Vim editing the same file, continuing to edit will
result in two versions of the same file.  The one that is written last will
overwrite the other one, resulting in loss of changes.  You better quit
this Vim.</pre>
</div>
</div>
</li>
<li>
<p>The swap file might be the result from a previous crash of Vim or the
computer.  Check the dates mentioned in the message.  If the date of the
swap file is newer than the file you were editing, and this line appears:</p>
<div class="literalblock">
<div class="content">
<pre>modified: YES</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Then you very likely have a crashed edit session that is worth recovering.
   If the date of the file is newer than the date of the swap file, then
either it was changed after the crash (perhaps you recovered it earlier,
but didn't delete the swap file?), or else the file was saved before the
crash but after the last write of the swap file (then you're lucky: you
don't even need that old swap file).  Vim will warn you for this with this
extra line:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>NEWER than swap file!</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>NOTE that in the following situation Vim knows the swap file is not useful and
will automatically delete it:
- The file is a valid swap file (Magic number is correct).
- The flag that the file was modified is not set.
- The process is not running.</p>
</div>
<div class="paragraph">
<p>You can programatically deal with this situation with the |FileChangedShell|
autocommand event.</p>
</div>
<div class="sect3">
<h4 id="_unreadable_swap_file">UNREADABLE SWAP FILE</h4>
<div class="paragraph">
<p>Sometimes the line</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[cannot be read]</pre>
</div>
</div>
<div class="paragraph">
<p>will appear under the name of the swap file.  This can be good or bad,
depending on circumstances.</p>
</div>
<div class="paragraph">
<p>It is good if a previous editing session crashed without having made any
changes to the file.  Then a directory listing of the swap file will show
that it has zero bytes.  You may delete it and proceed.</p>
</div>
<div class="paragraph">
<p>It is slightly bad if you don&#8217;t have read permission for the swap file.  You
may want to view the file read-only, or quit.  On multi-user systems, if you
yourself did the last changes under a different login name, a logout
followed by a login under that other name might cure the "read error".  Or
else you might want to find out who last edited (or is editing) the file and
have a talk with them.</p>
</div>
<div class="paragraph">
<p>It is very bad if it means there is a physical read error on the disk
containing the swap file.  Fortunately, this almost never happens.
You may want to view the file read-only at first (if you can), to see the
extent of the changes that were "forgotten".  If you are the one in charge of
that file, be prepared to redo your last changes.</p>
</div>
<div class="paragraph">
<p>WHAT TO DO?                                     <strong>swap-exists-choices</strong></p>
</div>
<div class="paragraph">
<p>If dialogs are supported you will be asked to select one of six choices:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Swap file ".main.c.swp" already exists!
[O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort, (D)elete it:</pre>
</div>
</div>
<div class="paragraph">
<p>O  Open the file readonly.  Use this when you just want to view the file and
   don&#8217;t need to recover it.  You might want to use this when you know someone
   else is editing the file, but you just want to look in it and not make
   changes.</p>
</div>
<div class="paragraph">
<p>E  Edit the file anyway.  Use this with caution!  If the file is being edited
   in another Vim, you might end up with two versions of the file.  Vim will
   try to warn you when this happens, but better be safe then sorry.</p>
</div>
<div class="paragraph">
<p>R  Recover the file from the swap file.  Use this if you know that the swap
   file contains changes that you want to recover.</p>
</div>
<div class="paragraph">
<p>Q  Quit.  This avoids starting to edit the file.  Use this if there is another
   Vim editing the same file.
      When you just started Vim, this will exit Vim.  When starting Vim with
   files in several windows, Vim quits only if there is a swap file for the
   first one.  When using an edit command, the file will not be loaded and you
   are taken back to the previously edited file.</p>
</div>
<div class="paragraph">
<p>A  Abort.  Like Quit, but also abort further commands.  This is useful when
   loading a script that edits several files, such as a session with multiple
   windows.</p>
</div>
<div class="paragraph">
<p>D  Delete the swap file.  Use this when you are sure you no longer need it.
   For example, when it doesn&#8217;t contain changes, or when the file itself is
   newer than the swap file.
      On Unix this choice is only offered when the process that created the
   swap file does not appear to be running.</p>
</div>
<div class="paragraph">
<p>If you do not get the dialog (you are running a version of Vim that does not
support it), you will have to do it manually.  To recover the file, use this
command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:recover</pre>
</div>
</div>
<div class="paragraph">
<p>Vim cannot always detect that a swap file already exists for a file.  This is
the case when the other edit session puts the swap files in another directory
or when the path name for the file is different when editing it on different
machines.  Therefore, don&#8217;t rely on Vim always warning you.</p>
</div>
<div class="paragraph">
<p>If you really don&#8217;t want to see this message, you can add the 'A' flag to the
'shortmess' option.  But it&#8217;s very unusual that you need this.</p>
</div>
<div class="paragraph">
<p>For remarks about encryption and the swap file, see |:recover-crypt|.
For programatic access to the swap file, see |swapinfo()|.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_further_reading_2">Further reading</h3>
<div class="paragraph">
<p>|swap-file|     An explanation about where the swap file will be created and
                what its name is.
|:preserve|     Manually flushing the swap file to disk.
|:swapname|     See the name of the swap file for the current file.
'updatecount'   Number of key strokes after which the swap file is flushed to
                disk.
'updatetime'    Timeout after which the swap file is flushed to disk.
'swapsync'      Whether the disk is synced when the swap file is flushed.
'directory'     List of directory names where to store the swap file.
'maxmem'        Limit for memory usage before writing text to the swap file.
'maxmemtot'     Same, but for all files in total.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_12.txt|  Clever tricks</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_clever_tricks">Clever tricks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By combining several commands you can make Vim do nearly everything.  In this
chapter a number of useful combinations will be presented.  This uses the
commands introduced in the previous chapters and a few more.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Replace a word</p>
</li>
<li>
<p>Change "Last, First" to "First Last"</p>
</li>
<li>
<p>Sort a list</p>
</li>
<li>
<p>Reverse line order</p>
</li>
<li>
<p>Count words</p>
</li>
<li>
<p>Find a man page</p>
</li>
<li>
<p>Trim blanks</p>
</li>
<li>
<p>Find where a word is used</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_replace_a_word">Replace a word</h3>
<div class="paragraph">
<p>The substitute command can be used to replace all occurrences of a word with
another word:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:%s/four/4/g</pre>
</div>
</div>
<div class="paragraph">
<p>The "%" range means to replace in all lines.  The "g" flag at the end causes
all words in a line to be replaced.
   This will not do the right thing if your file also contains "thirtyfour".
It would be replaced with "thirty4".  To avoid this, use the "\&lt;" item to
match the start of a word:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:%s/\&lt;four/4/g</pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, this still goes wrong on "fourteen".  Use "\&gt;" to match the end of
a word:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:%s/\&lt;four\&gt;/4/g</pre>
</div>
</div>
<div class="paragraph">
<p>If you are programming, you might want to replace "four" in comments, but not
in the code.  Since this is difficult to specify, add the "c" flag to have the
substitute command prompt you for each replacement:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:%s/\&lt;four\&gt;/4/gc</pre>
</div>
</div>
<div class="sect3">
<h4 id="_replacing_in_several_files">REPLACING IN SEVERAL FILES</h4>
<div class="paragraph">
<p>Suppose you want to replace a word in more than one file.  You could edit each
file and type the command manually.  It&#8217;s a lot faster to use record and
playback.
   Let&#8217;s assume you have a directory with C++ files, all ending in ".cpp".
There is a function called "GetResp" that you want to rename to "GetAnswer".</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim *.cpp               Start Vim, defining the argument list to
                        contain all the C++ files.  You are now in the
                        first file.
qq                      Start recording into the q register
:%s/\&lt;GetResp\&gt;/GetAnswer/g
                        Do the replacements in the first file.
:wnext                  Write this file and move to the next one.
q                       Stop recording.
@q                      Execute the q register.  This will replay the
                        substitution and ":wnext".  You can verify
                        that this doesn't produce an error message.
999@q                   Execute the q register on the remaining files.</pre>
</div>
</div>
<div class="paragraph">
<p>At the last file you will get an error message, because ":wnext" cannot move
to the next file.  This stops the execution, and everything is done.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
When playing back a recorded sequence, an error stops the execution.
Therefore, make sure you don't get an error message when recording.</pre>
</div>
</div>
<div class="paragraph">
<p>There is one catch: If one of the .cpp files does not contain the word
"GetResp", you will get an error and replacing will stop.  To avoid this, add
the "e" flag to the substitute command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:%s/\&lt;GetResp\&gt;/GetAnswer/ge</pre>
</div>
</div>
<div class="paragraph">
<p>The "e" flag tells ":substitute" that not finding a match is not an error.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_change_last_first_to_first_last">Change "Last, First" to "First Last"</h3>
<div class="paragraph">
<p>You have a list of names in this form:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Doe, John
Smith, Peter</pre>
</div>
</div>
<div class="paragraph">
<p>You want to change that to:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>John Doe
Peter Smith</pre>
</div>
</div>
<div class="paragraph">
<p>This can be done with just one command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:%s/\([^,]*\), \(.*\)/\2 \1/</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s break this down in parts.  Obviously it starts with a substitute
command.  The "%" is the line range, which stands for the whole file.  Thus
the substitution is done in every line in the file.
   The arguments for the substitute command are "/from/to/".  The slashes
separate the "from" pattern and the "to" string.  This is what the "from"
pattern contains:
                                                        \(<strong class="^">\), \(.</strong>\)</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The first part between \( \) matches "Last"     \(     \)
    match anything but a comma                    [^,]
    any number of times                               *
matches ", " literally                                   ,
The second part between \( \) matches "First"              \(  \)
    any character                                            .
    any number of times                                       *</pre>
</div>
</div>
<div class="paragraph">
<p>In the "to" part we have "\2" and "\1".  These are called backreferences.
They refer to the text matched by the "\( \)" parts in the pattern.  "\2"
refers to the text matched by the second "\( \)", which is the "First" name.
"\1" refers to the first "\( \)", which is the "Last" name.
   You can use up to nine backreferences in the "to" part of a substitute
command.  "\0" stands for the whole matched pattern.  There are a few more
special items in a substitute command, see |sub-replace-special|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sort_a_list">Sort a list</h3>
<div class="paragraph">
<p>In a Makefile you often have a list of files.  For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>OBJS = \
        version.o \
        pch.o \
        getopt.o \
        util.o \
        getopt1.o \
        inp.o \
        patch.o \
        backup.o</pre>
</div>
</div>
<div class="paragraph">
<p>To sort this list, filter the text through the external sort command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/^OBJS
j
:.,/^$/-1!sort</pre>
</div>
</div>
<div class="paragraph">
<p>This goes to the first line, where "OBJS" is the first thing in the line.
Then it goes one line down and filters the lines until the next empty line.
You could also select the lines in Visual mode and then use "!sort".  That&#8217;s
easier to type, but more work when there are many lines.
   The result is this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>OBJS = \
        backup.o
        getopt.o \
        getopt1.o \
        inp.o \
        patch.o \
        pch.o \
        util.o \
        version.o \</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that a backslash at the end of each line is used to indicate the line
continues.  After sorting, this is wrong!  The "backup.o" line that was at
the end didn&#8217;t have a backslash.  Now that it sorts to another place, it
must have a backslash.
   The simplest solution is to add the backslash with "A \&lt;Esc&gt;".  You can
keep the backslash in the last line, if you make sure an empty line comes
after it.  That way you don&#8217;t have this problem again.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reverse_line_order">Reverse line order</h3>
<div class="paragraph">
<p>The |:global| command can be combined with the |:move| command to move all the
lines before the first line, resulting in a reversed file.  The command is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:global/^/m 0</pre>
</div>
</div>
<div class="paragraph">
<p>Abbreviated:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:g/^/m 0</pre>
</div>
</div>
<div class="paragraph">
<p>The "^" regular expression matches the beginning of the line (even if the line
is blank).  The |:move| command moves the matching line to after the mythical
zeroth line, so the current matching line becomes the first line of the file.
As the |:global| command is not confused by the changing line numbering,
|:global| proceeds to match all remaining lines of the file and puts each as
the first.</p>
</div>
<div class="paragraph">
<p>This also works on a range of lines.  First move to above the first line and
mark it with "mt".  Then move the cursor to the last line in the range and
type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:'t+1,.g/^/m 't</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_count_words">Count words</h3>
<div class="paragraph">
<p>Sometimes you have to write a text with a maximum number of words.  Vim can
count the words for you.
   When the whole file is what you want to count the words in, use this
command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>g CTRL-G</pre>
</div>
</div>
<div class="paragraph">
<p>Do not type a space after the g, this is just used here to make the command
easy to read.
   The output looks like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Col 1 of 0; Line 141 of 157; Word 748 of 774; Byte 4489 of 4976</pre>
</div>
</div>
<div class="paragraph">
<p>You can see on which word you are (748), and the total number of words in the
file (774).</p>
</div>
<div class="paragraph">
<p>When the text is only part of a file, you could move to the start of the text,
type "g CTRL-G", move to the end of the text, type "g CTRL-G" again, and then
use your brain to compute the difference in the word position.  That&#8217;s a good
exercise, but there is an easier way.  With Visual mode, select the text you
want to count words in.  Then type g CTRL-G.  The result:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Selected 5 of 293 Lines; 70 of 1884 Words; 359 of 10928 Bytes</pre>
</div>
</div>
<div class="paragraph">
<p>For other ways to count words, lines and other items, see |count-items|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_find_a_man_page">Find a man page</h3>
<div class="paragraph">
<p>While editing a shell script or C program, you are using a command or function
that you want to find the man page for (this is on Unix).  Let&#8217;s first use a
simple way: Move the cursor to the word you want to find help on and press &gt;</p>
</div>
<div class="sect3">
<h4 id="_k">K</h4>
<div class="paragraph">
<p>Vim will run the external "man" program on the word.  If the man page is
found, it is displayed.  This uses the normal pager to scroll through the text
(mostly the "more" program).  When you get to the end pressing &lt;Enter&gt; will
get you back into Vim.</p>
</div>
<div class="paragraph">
<p>A disadvantage is that you can&#8217;t see the man page and the text you are working
on at the same time.  There is a trick to make the man page appear in a Vim
window.  First, load the man filetype plugin:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:runtime! ftplugin/man.vim</pre>
</div>
</div>
<div class="paragraph">
<p>Put this command in your vimrc file if you intend to do this often.  Now you
can use the ":Man" command to open a window on a man page:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:Man csh</pre>
</div>
</div>
<div class="paragraph">
<p>You can scroll around and the text is highlighted.  This allows you to find
the help you were looking for.  Use CTRL-W w to jump to the window with the
text you were working on.
   To find a man page in a specific section, put the section number first.
For example, to look in section 3 for "echo":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:Man 3 echo</pre>
</div>
</div>
<div class="paragraph">
<p>To jump to another man page, which is in the text with the typical form
"word(1)", press CTRL-] on it.  Further ":Man" commands will use the same
window.</p>
</div>
<div class="paragraph">
<p>To display a man page for the word under the cursor, use this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>\K</pre>
</div>
</div>
<div class="paragraph">
<p>(If you redefined the &lt;Leader&gt;, use it instead of the backslash).
For example, you want to know the return value of "strstr()" while editing
this line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if ( strstr (input, "aap") == )</pre>
</div>
</div>
<div class="paragraph">
<p>Move the cursor to somewhere on "strstr" and type "\K".  A window will open
to display the man page for strstr().</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_trim_blanks">Trim blanks</h3>
<div class="paragraph">
<p>Some people find spaces and tabs at the end of a line useless, wasteful, and
ugly.  To remove whitespace at the end of every line, execute the following
command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:%s/\s\+$//</pre>
</div>
</div>
<div class="paragraph">
<p>The line range "%" is used, thus this works on the whole file.  The pattern
that the ":substitute" command matches with is "\s\$".  This finds white
space characters (\s), 1 or more of them (\), before the end-of-line ($).
Later will be explained how you write patterns like this, see |usr_27.txt|.
   The "to" part of the substitute command is empty: "//".  Thus it replaces
with nothing, effectively deleting the matched white space.</p>
</div>
<div class="paragraph">
<p>Another wasteful use of spaces is placing them before a tab.  Often these can
be deleted without changing the amount of white space.  But not always!
Therefore, you can best do this manually.  Use this search command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/</pre>
</div>
</div>
<div class="paragraph">
<p>You cannot see it, but there is a space before a tab in this command.  Thus
it&#8217;s "/&lt;Space&gt;&lt;Tab&gt;".   Now use "x" to delete the space and check that the
amount of white space doesn&#8217;t change.  You might have to insert a tab if it
does change.  Type "n" to find the next match.  Repeat this until no more
matches can be found.</p>
</div>
</div>
<div class="sect2">
<h3 id="_find_where_a_word_is_used">Find where a word is used</h3>
<div class="paragraph">
<p>If you are a UNIX user, you can use a combination of Vim and the grep command
to edit all the files that contain a given word.  This is extremely useful if
you are working on a program and want to view or edit all the files that
contain a specific variable.
   For example, suppose you want to edit all the C program files that contain
the word "frame_counter".  To do this you use the command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim `grep -l frame_counter *.c`</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s look at this command in detail.  The grep command searches through a set
of files for a given word.  Because the -l argument is specified, the command
will only list the files containing the word and not print the matching lines.
The word it is searching for is "frame_counter".  Actually, this can be any
regular expression.  (Note: What grep uses for regular expressions is not
exactly the same as what Vim uses.)
   The entire command is enclosed in backticks (`).  This tells the UNIX shell
to run this command and pretend that the results were typed on the command
line.  So what happens is that the grep command is run and produces a list of
files, these files are put on the Vim command line.  This results in Vim
editing the file list that is the output of grep.  You can then use commands
like ":next" and ":first" to browse through the files.</p>
</div>
<div class="sect3">
<h4 id="_finding_each_line">FINDING EACH LINE</h4>
<div class="paragraph">
<p>The above command only finds the files in which the word is found.  You still
have to find the word within the files.
   Vim has a built-in command that you can use to search a set of files for a
given string.  If you want to find all occurrences of "error_string" in all C
program files, for example, enter the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:grep error_string *.c</pre>
</div>
</div>
<div class="paragraph">
<p>This causes Vim to search for the string "error_string" in all the specified
files (*.c).  The editor will now open the first file where a match is found
and position the cursor on the first matching line.  To go to the next
matching line (no matter in what file it is), use the ":cnext" command.  To go
to the previous match, use the ":cprev" command.  Use ":clist" to see all the
matches and where they are.
   The ":grep" command uses the external commands grep (on Unix) or findstr
(on Windows).  You can change this by setting the option 'grepprg'.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_20.txt|  Typing command-line commands quickly</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_typing_command_line_commands_quickly">Typing command-line commands quickly</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vim has a few generic features that makes it easier to enter commands.  Colon
commands can be abbreviated, edited and repeated.  Completion is available for
nearly everything.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Command line editing</p>
</li>
<li>
<p>Command line abbreviations</p>
</li>
<li>
<p>Command line completion</p>
</li>
<li>
<p>Command line history</p>
</li>
<li>
<p>Command line window</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_command_line_editing">Command line editing</h3>
<div class="paragraph">
<p>When you use a colon (:) command or search for a string with / or ?, Vim puts
the cursor on the bottom of the screen.  There you type the command or search
pattern.  This is called the Command line.  Also when it&#8217;s used for entering a
search command.</p>
</div>
<div class="paragraph">
<p>The most obvious way to edit the command you type is by pressing the &lt;BS&gt; key.
This erases the character before the cursor.  To erase another character,
typed earlier, first move the cursor with the cursor keys.
   For example, you have typed this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:s/col/pig/</pre>
</div>
</div>
<div class="paragraph">
<p>Before you hit &lt;Enter&gt;, you notice that "col" should be "cow".  To correct
this, you type &lt;Left&gt; five times.  The cursor is now just after "col".  Type
&lt;BS&gt; and "w" to correct:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:s/cow/pig/</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can press &lt;Enter&gt; directly.  You don&#8217;t have to move the cursor to the
end of the line before executing the command.</p>
</div>
<div class="paragraph">
<p>The most often used keys to move around in the command line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;Left&gt;                  one character left
&lt;Right&gt;                 one character right
&lt;S-Left&gt; or &lt;C-Left&gt;    one word left
&lt;S-Right&gt; or &lt;C-Right&gt;  one word right
CTRL-B or &lt;Home&gt;        to begin of command line
CTRL-E or &lt;End&gt;         to end of command line</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
&lt;S-Left&gt; (cursor left key with Shift key pressed) and &lt;C-Left&gt; (cursor
left key with Control pressed) will not work on all keyboards.  Same
for the other Shift and Control combinations.</pre>
</div>
</div>
<div class="paragraph">
<p>You can also use the mouse to move the cursor.</p>
</div>
<div class="sect3">
<h4 id="_deleting">DELETING</h4>
<div class="paragraph">
<p>As mentioned, &lt;BS&gt; deletes the character before the cursor.  To delete a whole
word use CTRL-W.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/the fine pig</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-W</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>/the fine</pre>
</div>
</div>
<div class="paragraph">
<p>CTRL-U removes all text, thus allows you to start all over again.</p>
</div>
</div>
<div class="sect3">
<h4 id="_overstrike">OVERSTRIKE</h4>
<div class="paragraph">
<p>The &lt;Insert&gt; key toggles between inserting characters and replacing the
existing ones.  Start with this text:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/the fine pig</pre>
</div>
</div>
<div class="paragraph">
<p>Move the cursor to the start of "fine" with &lt;S-Left&gt; twice (or &lt;Left&gt; eight
times, if &lt;S-Left&gt; doesn&#8217;t work).  Now press &lt;Insert&gt; to switch to overstrike
and type "great":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/the greatpig</pre>
</div>
</div>
<div class="paragraph">
<p>Oops, we lost the space.  Now, don&#8217;t use &lt;BS&gt;, because it would delete the
"t" (this is different from Replace mode).  Instead, press &lt;Insert&gt; to switch
from overstrike to inserting, and type the space:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/the great pig</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cancelling">CANCELLING</h4>
<div class="paragraph">
<p>You thought of executing a : or / command, but changed your mind.  To get rid
of what you already typed, without executing it, press CTRL-C or &lt;Esc&gt;.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
&lt;Esc&gt; is the universal "get out" key.  Unfortunately, in the good old
Vi pressing &lt;Esc&gt; in a command line executed the command!  Since that
might be considered to be a bug, Vim uses &lt;Esc&gt; to cancel the command.
But with the 'cpoptions' option it can be made Vi compatible.  And
when using a mapping (which might be written for Vi) &lt;Esc&gt; also works
Vi compatible.  Therefore, using CTRL-C is a method that always works.</pre>
</div>
</div>
<div class="paragraph">
<p>If you are at the start of the command line, pressing &lt;BS&gt; will cancel the
command.  It&#8217;s like deleting the ":" or "/" that the line starts with.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_command_line_abbreviations">Command line abbreviations</h3>
<div class="paragraph">
<p>Some of the ":" commands are really long.  We already mentioned that
":substitute" can be abbreviated to ":s".  This is a generic mechanism, all
":" commands can be abbreviated.</p>
</div>
<div class="paragraph">
<p>How short can a command get?  There are 26 letters, and many more commands.
For example, ":set" also starts with ":s", but ":s" doesn&#8217;t start a ":set"
command.  Instead ":set" can be abbreviated to ":se".
   When the shorter form of a command could be used for two commands, it
stands for only one of them.  There is no logic behind which one, you have to
learn them.  In the help files the shortest form that works is mentioned.  For
example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:s[ubstitute]</pre>
</div>
</div>
<div class="paragraph">
<p>This means that the shortest form of ":substitute" is ":s".  The following
characters are optional.  Thus ":su" and ":sub" also work.</p>
</div>
<div class="paragraph">
<p>In the user manual we will either use the full name of command, or a short
version that is still readable.  For example, ":function" can be abbreviated
to ":fu".  But since most people don&#8217;t understand what that stands for, we
will use ":fun".  (Vim doesn&#8217;t have a ":funny" command, otherwise ":fun" would
be confusing too.)</p>
</div>
<div class="paragraph">
<p>It is recommended that in Vim scripts you write the full command name.  That
makes it easier to read back when you make later changes.  Except for some
often used commands like ":w" (":write") and ":r" (":read").
   A particularly confusing one is ":end", which could stand for ":endif",
":endwhile" or ":endfunction".  Therefore, always use the full name.</p>
</div>
<div class="sect3">
<h4 id="_short_option_names">SHORT OPTION NAMES</h4>
<div class="paragraph">
<p>In the user manual the long version of the option names is used.  Many options
also have a short name.  Unlike ":" commands, there is only one short name
that works.  For example, the short name of 'autoindent' is 'ai'.  Thus these
two commands do the same thing:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set autoindent
:set ai</pre>
</div>
</div>
<div class="paragraph">
<p>You can find the full list of long and short names here: |option-list|.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_command_line_completion">Command line completion</h3>
<div class="paragraph">
<p>This is one of those Vim features that, by itself, is a reason to switch from
Vi to Vim.  Once you have used this, you can&#8217;t do without.</p>
</div>
<div class="paragraph">
<p>Suppose you have a directory that contains these files:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>info.txt
intro.txt
bodyofthepaper.txt</pre>
</div>
</div>
<div class="paragraph">
<p>To edit the last one, you use the command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit bodyofthepaper.txt</pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s easy to type this wrong.  A much quicker way is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit b&lt;Tab&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Which will result in the same command.  What happened?  The &lt;Tab&gt; key does
completion of the word before the cursor.  In this case "b".  Vim looks in the
directory and finds only one file that starts with a "b".  That must be the
one you are looking for, thus Vim completes the file name for you.</p>
</div>
<div class="paragraph">
<p>Now type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit i&lt;Tab&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will beep, and give you:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit info.txt</pre>
</div>
</div>
<div class="paragraph">
<p>The beep means that Vim has found more than one match.  It then uses the first
match it found (alphabetically).  If you press &lt;Tab&gt; again, you get:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit intro.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Thus, if the first &lt;Tab&gt; doesn&#8217;t give you the file you were looking for, press
it again.  If there are more matches, you will see them all, one at a time.
   If you press &lt;Tab&gt; on the last matching entry, you will go back to what you
first typed:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit i</pre>
</div>
</div>
<div class="paragraph">
<p>Then it starts all over again.  Thus Vim cycles through the list of matches.
Use CTRL-P to go through the list in the other direction:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>      &lt;------------------- &lt;Tab&gt; -------------------------+
                                                          |
          &lt;Tab&gt; --&gt;                    &lt;Tab&gt; --&gt;
:edit i               :edit info.txt               :edit intro.txt
          &lt;-- CTRL-P                   &lt;-- CTRL-P
   |
   +---------------------- CTRL-P ------------------------&gt;</pre>
</div>
</div>
<div class="sect3">
<h4 id="_context">CONTEXT</h4>
<div class="paragraph">
<p>When you type ":set i" instead of ":edit i" and press &lt;Tab&gt; you get:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set icon</pre>
</div>
</div>
<div class="paragraph">
<p>Hey, why didn&#8217;t you get ":set info.txt"?  That&#8217;s because Vim has context
sensitive completion.  The kind of words Vim will look for depends on the
command before it.  Vim knows that you cannot use a file name just after a
":set" command, but you can use an option name.
   Again, if you repeat typing the &lt;Tab&gt;, Vim will cycle through all matches.
There are quite a few, it&#8217;s better to type more characters first:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set isk&lt;Tab&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Gives:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set iskeyword</pre>
</div>
</div>
<div class="paragraph">
<p>Now type "=" and press &lt;Tab&gt;:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set iskeyword=@,48-57,_,192-255</pre>
</div>
</div>
<div class="paragraph">
<p>What happens here is that Vim inserts the old value of the option.  Now you
can edit it.
   What is completed with &lt;Tab&gt; is what Vim expects in that place.  Just try
it out to see how it works.  In some situations you will not get what you
want.  That&#8217;s either because Vim doesn&#8217;t know what you want, or because
completion was not implemented for that situation.  In that case you will get
a &lt;Tab&gt; inserted (displayed as ^I).</p>
</div>
</div>
<div class="sect3">
<h4 id="_list_matches">LIST MATCHES</h4>
<div class="paragraph">
<p>When there are many matches, you would like to see an overview.  Do this by
pressing CTRL-D.  For example, pressing CTRL-D after:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set is</pre>
</div>
</div>
<div class="paragraph">
<p>results in:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set is
incsearch  isfname    isident    iskeyword  isprint
:set is</pre>
</div>
</div>
<div class="paragraph">
<p>Vim lists the matches and then comes back with the text you typed.  You can
now check the list for the item you wanted.  If it isn&#8217;t there, you can use
&lt;BS&gt; to correct the word.  If there are many matches, type a few more
characters before pressing &lt;Tab&gt; to complete the rest.
   If you have watched carefully, you will have noticed that "incsearch"
doesn&#8217;t start with "is".  In this case "is" stands for the short name of
"incsearch".  (Many options have a short and a long name.)  Vim is clever
enough to know that you might have wanted to expand the short name of the
option into the long name.</p>
</div>
</div>
<div class="sect3">
<h4 id="_there_is_more">THERE IS MORE</h4>
<div class="paragraph">
<p>The CTRL-L command completes the word to the longest unambiguous string.  If
you type ":edit i" and there are files "info.txt" and "info_backup.txt" you
will get ":edit info".</p>
</div>
<div class="paragraph">
<p>The 'wildmode' option can be used to change the way completion works.
The 'wildmenu' option can be used to get a menu-like list of matches.
Use the 'suffixes' option to specify files that are less important and appear
at the end of the list of files.
The 'wildignore' option specifies files that are not listed at all.</p>
</div>
<div class="paragraph">
<p>More about all of this here: |cmdline-completion|</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_command_line_history">Command line history</h3>
<div class="paragraph">
<p>In chapter 3 we briefly mentioned the history.  The basics are that you can
use the &lt;Up&gt; key to recall an older command line.  &lt;Down&gt; then takes you back
to newer commands.</p>
</div>
<div class="paragraph">
<p>There are actually four histories.  The ones we will mention here are for ":"
commands and for "/" and "?" search commands.  The "/" and "?" commands share
the same history, because they are both search commands.  The two other
histories are for expressions and input lines for the input() function.
|cmdline-history|</p>
</div>
<div class="paragraph">
<p>Suppose you have done a ":set" command, typed ten more colon commands and then
want to repeat that ":set" command again.  You could press ":" and then ten
times &lt;Up&gt;.  There is a quicker way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:se&lt;Up&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will now go back to the previous command that started with "se".  You have
a good chance that this is the ":set" command you were looking for.  At least
you should not have to press &lt;Up&gt; very often (unless ":set" commands is all
you have done).</p>
</div>
<div class="paragraph">
<p>The &lt;Up&gt; key will use the text typed so far and compare it with the lines in
the history.  Only matching lines will be used.
   If you do not find the line you were looking for, use &lt;Down&gt; to go back to
what you typed and correct that.  Or use CTRL-U to start all over again.</p>
</div>
<div class="paragraph">
<p>To see all the lines in the history:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:history</pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s the history of ":" commands.  The search history is displayed with this
command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:history /</pre>
</div>
</div>
<div class="paragraph">
<p>CTRL-P will work like &lt;Up&gt;, except that it doesn&#8217;t matter what you already
typed.  Similarly for CTRL-N and &lt;Down&gt;.  CTRL-P stands for previous, CTRL-N
for next.</p>
</div>
</div>
<div class="sect2">
<h3 id="_command_line_window">Command line window</h3>
<div class="paragraph">
<p>Typing the text in the command line works different from typing text in Insert
mode.  It doesn&#8217;t allow many commands to change the text.  For most commands
that&#8217;s OK, but sometimes you have to type a complicated command.  That&#8217;s where
the command line window is useful.</p>
</div>
<div class="paragraph">
<p>Open the command line window with this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>q:</pre>
</div>
</div>
<div class="paragraph">
<p>Vim now opens a (small) window at the bottom.  It contains the command line
history, and an empty line at the end:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+-------------------------------------+
|other window                         |
|~                                    |
|file.txt=============================|
|:e c                                 |
|:e config.h.in                       |
|:set path=.,/usr/include,,           |
|:set iskeyword=@,48-57,_,192-255     |
|:set is                              |
|:q                                   |
|:                                    |
|command-line=========================|
|                                     |
+-------------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>You are now in Normal mode.  You can use the "hjkl" keys to move around.  For
example, move up with "5k" to the ":e config.h.in" line.  Type "$h" to go to
the "i" of "in" and type "cwout".  Now you have changed the line to:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:e config.h.out</pre>
</div>
</div>
<div class="paragraph">
<p>Now press &lt;Enter&gt; and this command will be executed.  The command line window
will close.
   The &lt;Enter&gt; command will execute the line under the cursor.  It doesn&#8217;t
matter whether Vim is in Insert mode or in Normal mode.
   Changes in the command line window are lost.  They do not result in the
history to be changed.  Except that the command you execute will be added to
the end of the history, like with all executed commands.</p>
</div>
<div class="paragraph">
<p>The command line window is very useful when you want to have overview of the
history, lookup a similar command, change it a bit and execute it.  A search
command can be used to find something.
   In the previous example the "?config" search command could have been used
to find the previous command that contains "config".  It&#8217;s a bit strange,
because you are using a command line to search in the command line window.
While typing that search command you can&#8217;t open another command line window,
there can be only one.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_21.txt|  Go away and come back</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_go_away_and_come_back">Go away and come back</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter goes into mixing the use of other programs with Vim.  Either by
executing program from inside Vim or by leaving Vim and coming back later.
Furthermore, this is about the ways to remember the state of Vim and restore
it later.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Suspend and resume</p>
</li>
<li>
<p>Executing shell commands</p>
</li>
<li>
<p>Remembering information; viminfo</p>
</li>
<li>
<p>Sessions</p>
</li>
<li>
<p>Views</p>
</li>
<li>
<p>Modelines</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_suspend_and_resume">Suspend and resume</h3>
<div class="paragraph">
<p>Like most Unix programs Vim can be suspended by pressing CTRL-Z.  This stops
Vim and takes you back to the shell it was started in.  You can then do any
other commands until you are bored with them.  Then bring back Vim with the
"fg" command. &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-Z
{any sequence of shell commands}
fg</pre>
</div>
</div>
<div class="paragraph">
<p>You are right back where you left Vim, nothing has changed.
   In case pressing CTRL-Z doesn&#8217;t work, you can also use ":suspend".
Don&#8217;t forget to bring Vim back to the foreground, you would lose any changes
that you made!</p>
</div>
<div class="paragraph">
<p>Only Unix has support for this.  On other systems Vim will start a shell for
you.  This also has the functionality of being able to execute shell commands.
But it&#8217;s a new shell, not the one that you started Vim from.
   When you are running the GUI you can&#8217;t go back to the shell where Vim was
started.  CTRL-Z will minimize the Vim window instead.</p>
</div>
</div>
<div class="sect2">
<h3 id="_executing_shell_commands">Executing shell commands</h3>
<div class="paragraph">
<p>To execute a single shell command from Vim use ":!{command}".  For example, to
see a directory listing:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:!ls
:!dir</pre>
</div>
</div>
<div class="paragraph">
<p>The first one is for Unix, the second one for MS-Windows.
   Vim will execute the program.  When it ends you will get a prompt to hit
&lt;Enter&gt;.  This allows you to have a look at the output from the command before
returning to the text you were editing.
   The "!" is also used in other places where a program is run.  Let&#8217;s take
a look at an overview:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:!{program}             execute {program}
:r !{program}           execute {program} and read its output
:w !{program}           execute {program} and send text to its input
:[range]!{program}      filter text through {program}</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the presence of a range before "!{program}" makes a big
difference.  Without it executes the program normally, with the range a number
of text lines is filtered through the program.</p>
</div>
<div class="paragraph">
<p>Executing a whole row of programs this way is possible.  But a shell is much
better at it.  You can start a new shell this way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:shell</pre>
</div>
</div>
<div class="paragraph">
<p>This is similar to using CTRL-Z to suspend Vim.  The difference is that a new
shell is started.</p>
</div>
<div class="paragraph">
<p>When using the GUI the shell will be using the Vim window for its input and
output.  Since Vim is not a terminal emulator, this will not work perfectly.
If you have trouble, try toggling the 'guipty' option.  If this still doesn&#8217;t
work well enough, start a new terminal to run the shell in.  For example with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:!xterm&amp;</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_remembering_information_viminfo">Remembering information; viminfo</h3>
<div class="paragraph">
<p>After editing for a while you will have text in registers, marks in various
files, a command line history filled with carefully crafted commands.  When
you exit Vim all of this is lost.  But you can get it back!</p>
</div>
<div class="paragraph">
<p>The viminfo file is designed to store status information:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Command-line and Search pattern history
Text in registers
Marks for various files
The buffer list
Global variables</pre>
</div>
</div>
<div class="paragraph">
<p>Each time you exit Vim it will store this information in a file, the viminfo
file.  When Vim starts again, the viminfo file is read and the information
restored.</p>
</div>
<div class="paragraph">
<p>The 'viminfo' option is set by default to restore a limited number of items.
You might want to set it to remember more information.  This is done through
the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set viminfo=string</pre>
</div>
</div>
<div class="paragraph">
<p>The string specifies what to save.  The syntax of this string is an option
character followed by an argument.  The option/argument pairs are separated by
commas.
   Take a look at how you can build up your own viminfo string.  First, the '
option is used to specify how many files for which you save marks (a-z).  Pick
a nice even number for this option (1000, for instance).  Your command now
looks like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set viminfo='1000</pre>
</div>
</div>
<div class="paragraph">
<p>The f option controls whether global marks (A-Z and 0-9) are stored.  If this
option is 0, none are stored.  If it is 1 or you do not specify an f option,
the marks are stored.  You want this feature, so now you have this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set viminfo='1000,f1</pre>
</div>
</div>
<div class="paragraph">
<p>The &lt; option controls how many lines are saved for each of the registers.  By
default, all the lines are saved.  If 0, nothing is saved.  To avoid adding
thousands of lines to your viminfo file (which might never get used and makes
starting Vim slower) you use a maximum of 500 lines:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set viminfo='1000,f1,&lt;500</pre>
</div>
</div>
<div class="paragraph">
<p>Other options you might want to use:
        :       number of lines to save from the command line history
        @       number of lines to save from the input line history
        /       number of lines to save from the search history
        r       removable media, for which no marks will be stored (can be
                used several times)
        !       global variables that start with an uppercase letter and
                don&#8217;t contain lowercase letters
        h       disable 'hlsearch' highlighting when starting
        %       the buffer list (only restored when starting Vim without file
                arguments)
        c       convert the text using 'encoding'
        n       name used for the viminfo file (must be the last option)</p>
</div>
<div class="paragraph">
<p>See the 'viminfo' option and |viminfo-file| for more information.</p>
</div>
<div class="paragraph">
<p>When you run Vim multiple times, the last one exiting will store its
information.  This may cause information that previously exiting Vims stored
to be lost.  Each item can be remembered only once.</p>
</div>
<div class="sect3">
<h4 id="_getting_back_to_where_you_stopped_vim">GETTING BACK TO WHERE YOU STOPPED VIM</h4>
<div class="paragraph">
<p>You are halfway editing a file and it&#8217;s time to leave for holidays.  You exit
Vim and go enjoy yourselves, forgetting all about your work.  After a couple
of weeks you start Vim, and type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>'0</pre>
</div>
</div>
<div class="paragraph">
<p>And you are right back where you left Vim.  So you can get on with your work.
   Vim creates a mark each time you exit Vim.  The last one is '0.  The
position that '0 pointed to is made '1.  And '1 is made to '2, and so forth.
Mark '9 is lost.
   The |:marks| command is useful to find out where '0 to '9 will take you.</p>
</div>
</div>
<div class="sect3">
<h4 id="_getting_back_to_some_file">GETTING BACK TO SOME FILE</h4>
<div class="paragraph">
<p>If you want to go back to a file that you edited recently, but not when
exiting Vim, there is a slightly more complicated way.  You can see a list of
files by typing the command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :oldfiles
&lt;       1: ~/.viminfo
        2: ~/text/resume.txt
        3: /tmp/draft</pre>
</div>
</div>
<div class="paragraph">
<p>Now you would like to edit the second file, which is in the list preceded by
"2:".  You type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:e #&lt;2</pre>
</div>
</div>
<div class="paragraph">
<p>Instead of ":e" you can use any command that has a file name argument, the
"<mark>&lt;2" item works in the same place as "%" (current file name) and "</mark>"
(alternate file name).  So you can also split the window to edit the third
file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:split #&lt;3</pre>
</div>
</div>
<div class="paragraph">
<p>That #&lt;123 thing is a bit complicated when you just want to edit a file.
Fortunately there is a simpler way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :browse oldfiles
&lt;       1: ~/.viminfo
        2: ~/text/resume.txt
        3: /tmp/draft
        -- More --</pre>
</div>
</div>
<div class="paragraph">
<p>You get the same list of files as with |:oldfiles|.  If you want to edit
"resume.txt" first press "q" to stop the listing.  You will get a prompt:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Type number and &lt;Enter&gt; (empty cancels):</pre>
</div>
</div>
<div class="paragraph">
<p>Type "2" and press &lt;Enter&gt; to edit the second file.</p>
</div>
<div class="paragraph">
<p>More info at |:oldfiles|, |v:oldfiles| and |c_#&lt;|.</p>
</div>
</div>
<div class="sect3">
<h4 id="_move_info_from_one_vim_to_another">MOVE INFO FROM ONE VIM TO ANOTHER</h4>
<div class="paragraph">
<p>You can use the ":wviminfo" and ":rviminfo" commands to save and restore the
information while still running Vim.  This is useful for exchanging register
contents between two instances of Vim, for example.  In the first Vim do:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:wviminfo! ~/tmp/viminfo</pre>
</div>
</div>
<div class="paragraph">
<p>And in the second Vim do:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:rviminfo! ~/tmp/viminfo</pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, the "w" stands for "write" and the "r" for "read".
   The ! character is used by ":wviminfo" to forcefully overwrite an existing
file.  When it is omitted, and the file exists, the information is merged into
the file.
   The ! character used for ":rviminfo" means that all the information is
used, this may overwrite existing information.  Without the ! only information
that wasn&#8217;t set is used.
   These commands can also be used to store info and use it again later.  You
could make a directory full of viminfo files, each containing info for a
different purpose.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sessions">Sessions</h3>
<div class="paragraph">
<p>Suppose you are editing along, and it is the end of the day.  You want to quit
work and pick up where you left off the next day.  You can do this by saving
your editing session and restoring it the next day.
   A Vim session contains all the information about what you are editing.
This includes things such as the file list, window layout, global variables,
options and other information.  (Exactly what is remembered is controlled by
the 'sessionoptions' option, described below.)
   The following command creates a session file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:mksession vimbook.vim</pre>
</div>
</div>
<div class="paragraph">
<p>Later if you want to restore this session, you can use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:source vimbook.vim</pre>
</div>
</div>
<div class="paragraph">
<p>If you want to start Vim and restore a specific session, you can use the
following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim -S vimbook.vim</pre>
</div>
</div>
<div class="paragraph">
<p>This tells Vim to read a specific file on startup.  The 'S' stands for
session (actually, you can source any Vim script with -S, thus it might as
well stand for "source").</p>
</div>
<div class="paragraph">
<p>The windows that were open are restored, with the same position and size as
before.  Mappings and option values are like before.
   What exactly is restored depends on the 'sessionoptions' option.  The
default value is:
"blank,buffers,curdir,folds,help,options,tabpages,winsize,terminal".</p>
</div>
<div class="literalblock">
<div class="content">
<pre>blank           keep empty windows
buffers         all buffers, not only the ones in a window
curdir          the current directory
folds           folds, also manually created ones
help            the help window
options         all options and mappings
tabpages        all tab pages
winsize         window sizes
terminal        include terminal windows</pre>
</div>
</div>
<div class="paragraph">
<p>Change this to your liking.  To also restore the size of the Vim window, for
example, use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set sessionoptions+=resize</pre>
</div>
</div>
<div class="paragraph">
<p>SESSION HERE, SESSION THERE</p>
</div>
<div class="paragraph">
<p>The obvious way to use sessions is when working on different projects.
Suppose you store your session files in the directory "~/.vim".  You are
currently working on the "secret" project and have to switch to the "boring"
project:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:wall
:mksession! ~/.vim/secret.vim
:source ~/.vim/boring.vim</pre>
</div>
</div>
<div class="paragraph">
<p>This first uses ":wall" to write all modified files.  Then the current session
is saved, using ":mksession!".  This overwrites the previous session.  The
next time you load the secret session you can continue where you were at this
point.  And finally you load the new "boring" session.</p>
</div>
<div class="paragraph">
<p>If you open help windows, split and close various windows, and generally mess
up the window layout, you can go back to the last saved session:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:source ~/.vim/boring.vim</pre>
</div>
</div>
<div class="paragraph">
<p>Thus you have complete control over whether you want to continue next time
where you are now, by saving the current setup in a session, or keep the
session file as a starting point.
   Another way of using sessions is to create a window layout that you like to
use, and save this in a session.  Then you can go back to this layout whenever
you want.
   For example, this is a nice layout to use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+----------------------------------------+
|                  VIM - main help file  |
|                                        |
|Move around:  Use the cursor keys, or "h|
|help.txt================================|
|explorer   |                            |
|dir        |~                           |
|dir        |~                           |
|file       |~                           |
|file       |~                           |
|file       |~                           |
|file       |~                           |
|~/=========|[No File]===================|
|                                        |
+----------------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>This has a help window at the top, so that you can read this text.  The narrow
vertical window on the left contains a file explorer.  This is a Vim plugin
that lists the contents of a directory.  You can select files to edit there.
More about this in the next chapter.
   Create this from a just started Vim with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help
CTRL-W w
:vertical split ~/</pre>
</div>
</div>
<div class="paragraph">
<p>You can resize the windows a bit to your liking.  Then save the session with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:mksession ~/.vim/mine.vim</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can start Vim with this layout:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim -S ~/.vim/mine.vim</pre>
</div>
</div>
<div class="paragraph">
<p>Hint: To open a file you see listed in the explorer window in the empty
window, move the cursor to the filename and press "O".  Double clicking with
the mouse will also do this.</p>
</div>
<div class="paragraph">
<p>UNIX AND MS-WINDOWS</p>
</div>
<div class="paragraph">
<p>Some people have to do work on MS-Windows systems one day and on Unix another
day.  If you are one of them, consider adding "slash" and "unix" to
'sessionoptions'.  The session files will then be written in a format that can
be used on both systems.  This is the command to put in your vimrc file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set sessionoptions+=unix,slash</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will use the Unix format then, because the MS-Windows Vim can read and
write Unix files, but Unix Vim can&#8217;t read MS-Windows format session files.
Similarly, MS-Windows Vim understands file names with / to separate names, but
Unix Vim doesn&#8217;t understand \.</p>
</div>
<div class="sect3">
<h4 id="_sessions_and_viminfo">SESSIONS AND VIMINFO</h4>
<div class="paragraph">
<p>Sessions store many things, but not the position of marks, contents of
registers and the command line history.  You need to use the viminfo feature
for these things.
   In most situations you will want to use sessions separately from viminfo.
This can be used to switch to another session, but keep the command line
history.  And yank text into registers in one session, and paste it back in
another session.
   You might prefer to keep the info with the session.  You will have to do
this yourself then.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:mksession! ~/.vim/secret.vim
:wviminfo! ~/.vim/secret.viminfo</pre>
</div>
</div>
<div class="paragraph">
<p>And to restore this again:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:source ~/.vim/secret.vim
:rviminfo! ~/.vim/secret.viminfo</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_views">Views</h3>
<div class="paragraph">
<p>A session stores the looks of the whole of Vim.  When you want to store the
properties for one window only, use a view.
   The use of a view is for when you want to edit a file in a specific way.
For example, you have line numbers enabled with the 'number' option and
defined a few folds.  Just like with sessions, you can remember this view on
the file and restore it later.  Actually, when you store a session, it stores
the view of each window.
   There are two basic ways to use views.  The first is to let Vim pick a name
for the view file.  You can restore the view when you later edit the same
file.  To store the view for the current window:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:mkview</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will decide where to store the view.  When you later edit the same file
you get the view back with this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:loadview</pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s easy, isn&#8217;t it?
   Now you want to view the file without the 'number' option on, or with all
folds open, you can set the options to make the window look that way.  Then
store this view with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:mkview 1</pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, you can get this back with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:loadview 1</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can switch between the two views on the file by using ":loadview" with
and without the "1" argument.
   You can store up to ten views for the same file this way, one unnumbered
and nine numbered 1 to 9.</p>
</div>
<div class="sect3">
<h4 id="_a_view_with_a_name">A VIEW WITH A NAME</h4>
<div class="paragraph">
<p>The second basic way to use views is by storing the view in a file with a name
you choose.  This view can be loaded while editing another file.  Vim will
then switch to editing the file specified in the view.  Thus you can use this
to quickly switch to editing another file, with all its options set as you
saved them.
   For example, to save the view of the current file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:mkview ~/.vim/main.vim</pre>
</div>
</div>
<div class="paragraph">
<p>You can restore it with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:source ~/.vim/main.vim</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_modelines">Modelines</h3>
<div class="paragraph">
<p>When editing a specific file, you might set options specifically for that
file.  Typing these commands each time is boring.  Using a session or view for
editing a file doesn&#8217;t work when sharing the file between several people.
   The solution for this situation is adding a modeline to the file.  This is
a line of text that tells Vim the values of options, to be used in this file
only.
   A typical example is a C program where you make indents by a multiple of 4
spaces.  This requires setting the 'shiftwidth' option to 4.  This modeline
will do that:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/* vim:set shiftwidth=4: */</pre>
</div>
</div>
<div class="paragraph">
<p>Put this line as one of the first or last five lines in the file.  When
editing the file, you will notice that 'shiftwidth' will have been set to
four.  When editing another file, it&#8217;s set back to the default value of eight.
   For some files the modeline fits well in the header, thus it can be put at
the top of the file.  For text files and other files where the modeline gets
in the way of the normal contents, put it at the end of the file.</p>
</div>
<div class="paragraph">
<p>The 'modelines' option specifies how many lines at the start and end of the
file are inspected for containing a modeline.  To inspect ten lines:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set modelines=10</pre>
</div>
</div>
<div class="paragraph">
<p>The 'modeline' option can be used to switch this off.  Do this when you are
working as root on Unix or Administrator on MS-Windows, or when you don&#8217;t
trust the files you are editing:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set nomodeline</pre>
</div>
</div>
<div class="paragraph">
<p>Use this format for the modeline:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>any-text vim:set {option}={value} ... : any-text</pre>
</div>
</div>
<div class="paragraph">
<p>The "any-text" indicates that you can put any text before and after the part
that Vim will use.  This allows making it look like a comment, like what was
done above with /* and */.
   The " vim:" part is what makes Vim recognize this line.  There must be
white space before "vim", or "vim" must be at the start of the line.  Thus
using something like "gvim:" will not work.
   The part between the colons is a ":set" command.  It works the same way as
typing the ":set" command, except that you need to insert a backslash before a
colon (otherwise it would be seen as the end of the modeline).</p>
</div>
<div class="paragraph">
<p>Another example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>// vim:set textwidth=72 dir=c\:\tmp:  use c:\tmp here</pre>
</div>
</div>
<div class="paragraph">
<p>There is an extra backslash before the first colon, so that it&#8217;s included in
the ":set" command.  The text after the second colon is ignored, thus a remark
can be placed there.</p>
</div>
<div class="paragraph">
<p>For more details see |modeline|.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_22.txt|  Finding the file to edit</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_finding_the_file_to_edit">Finding the file to edit</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Files can be found everywhere.  So how do you find them?  Vim offers various
ways to browse the directory tree.  There are commands to jump to a file that
is mentioned in another.  And Vim remembers which files have been edited
before.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The file browser</p>
</li>
<li>
<p>The current directory</p>
</li>
<li>
<p>Finding a file</p>
</li>
<li>
<p>The buffer list</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_the_file_browser">The file browser</h3>
<div class="paragraph">
<p>Vim has a plugin that makes it possible to edit a directory.  Try this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit .</pre>
</div>
</div>
<div class="paragraph">
<p>Through the magic of autocommands and Vim scripts, the window will be filled
with the contents of the directory.  It looks like this:</p>
</div>
<div class="paragraph">
<p>" ============================================================================
" Netrw Directory Listing                                        (netrw v109)
"   Sorted by      name
"   Sort sequence: [\/]$,\.h$,\.c$,\.cpp$,*,\.info$,\.swp$,\.o$\.obj$,\.bak$
"   Quick Help: &lt;F1&gt;:help  -:go up dir  D:delete  R:rename  s:sort-by  x:exec
" ============================================================================
../
./
check/
Makefile
autocmd.txt
change.txt
eval.txt~
filetype.txt~
help.txt.info</p>
</div>
<div class="paragraph">
<p>You can see these items:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The name of the browsing tool and its version number</p>
</li>
<li>
<p>The name of the browsing directory</p>
</li>
<li>
<p>The method of sorting (may be by name, time, or size)</p>
</li>
<li>
<p>How names are to be sorted (directories first, then *.h files,
*.c files, etc)</p>
</li>
<li>
<p>How to get help (use the &lt;F1&gt; key), and an abbreviated listing
of available commands</p>
</li>
<li>
<p>A listing of files, including "../", which allows one to list
the parent directory.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you have syntax highlighting enabled, the different parts are highlighted
so as to make it easier to spot them.</p>
</div>
<div class="paragraph">
<p>You can use Normal mode Vim commands to move around in the text.  For example,
move the cursor atop a file and press &lt;Enter&gt;; you will then be editing that
file.  To go back to the browser use ":edit ." again, or use ":Explore".
CTRL-O also works.</p>
</div>
<div class="paragraph">
<p>Try using &lt;Enter&gt; while the cursor is atop a directory name.  The result is
that the file browser moves into that directory and displays the items found
there.  Pressing &lt;Enter&gt; on the first directory "../" moves you one level
higher.  Pressing "-" does the same thing, without the need to move to the
"../" item first.</p>
</div>
<div class="paragraph">
<p>You can press &lt;F1&gt; to get help on the things you can do in the netrw file
browser.  This is what you get:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>\9. Directory Browsing        netrw-browse   netrw-dir   netrw-list   netrw-help</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    MAPS                                                                 netrw-maps
         &lt;F1&gt;.............Help.......................................|netrw-help|
         &lt;cr&gt;.............Browsing...................................|netrw-cr|
         &lt;del&gt;............Deleting Files or Directories..............|netrw-delete|
         -................Going Up...................................|netrw--|
         a................Hiding Files or Directories................|netrw-a|
         mb...............Bookmarking a Directory....................|netrw-mb|
         gb...............Changing to a Bookmarked Directory.........|netrw-gb|
         cd...............Make Browsing Directory The Current Dir....|netrw-c|
         d................Make A New Directory.......................|netrw-d|
         D................Deleting Files or Directories..............|netrw-D|
         &lt;c-h&gt;............Edit File/Directory Hiding List............|netrw-ctrl-h|
         i................Change Listing Style.......................|netrw-i|
         &lt;c-l&gt;............Refreshing the Listing.....................|netrw-ctrl-l|
         o................Browsing with a Horizontal Split...........|netrw-o|
         p................Use Preview Window.........................|netrw-p|
         P................Edit in Previous Window....................|netrw-p|
         q................Listing Bookmarks and History..............|netrw-qb|
         r................Reversing Sorting Order....................|netrw-r|
&lt;       (etc)</pre>
</div>
</div>
<div class="paragraph">
<p>The &lt;F1&gt; key thus brings you to a netrw directory browsing contents help page.
It&#8217;s a regular help page; use the usual |CTRL-]| to jump to tagged help items
and |CTRL-O| to jump back.</p>
</div>
<div class="paragraph">
<p>To select files for display and editing: (with the cursor is atop a filename)</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;enter&gt;         Open the file in the current window.       |netrw-cr|
o               Horizontally split window and display file |netrw-o|
v               Vertically split window and display file   |netrw-v|
p               Use the |preview-window|                   |netrw-p|
P               Edit in the previous window                |netrw-P|
t               Open file in a new tab                     |netrw-t|</pre>
</div>
</div>
<div class="paragraph">
<p>The following normal-mode commands may be used to control the browser display:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>i               Controls listing style (thin, long, wide, and tree).
                The long listing includes size and date information.
s               Repeatedly pressing s will change the way the files
                are sorted; one may sort on name, modification time,
                or size.
r               Reverse the sorting order.</pre>
</div>
</div>
<div class="paragraph">
<p>As a sampling of extra normal-mode commands:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>cd              Change Vim's notion of the current directory to be
                the same as the browser directory.  (see
                |g:netrw_keepdir| to control this, too)
R               Rename the file or directory under the cursor; a
                prompt will be issued for the new name.
D               Delete the file or directory under the cursor; a
                confirmation request will be issued.
mb gb           Make bookmark/goto bookmark</pre>
</div>
</div>
<div class="paragraph">
<p>One may also use command mode; again, just a sampling:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:Explore [directory]    Browse specified/current directory
:NetrwSettings          A comprehensive list of your current netrw
                        settings with help linkage.</pre>
</div>
</div>
<div class="paragraph">
<p>The netrw browser is not limited to just your local machine; one may use
urls such as:    (that trailing / is important)</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:Explore ftp://somehost/path/to/dir/
:e scp://somehost/path/to/dir/</pre>
</div>
</div>
<div class="paragraph">
<p>See |netrw-browse| for more.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_current_directory">The current directory</h3>
<div class="paragraph">
<p>Just like the shell, Vim has the concept of a current directory.  Suppose you
are in your home directory and want to edit several files in a directory
"VeryLongFileName".  You could do:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit VeryLongFileName/file1.txt
:edit VeryLongFileName/file2.txt
:edit VeryLongFileName/file3.txt</pre>
</div>
</div>
<div class="paragraph">
<p>To avoid much of the typing, do this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:cd VeryLongFileName
:edit file1.txt
:edit file2.txt
:edit file3.txt</pre>
</div>
</div>
<div class="paragraph">
<p>The ":cd" command changes the current directory.  You can see what the current
directory is with the ":pwd" command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:pwd
/home/Bram/VeryLongFileName</pre>
</div>
</div>
<div class="paragraph">
<p>Vim remembers the last directory that you used.  Use "cd -" to go back to it.
Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:pwd
/home/Bram/VeryLongFileName
:cd /etc
:pwd
/etc
:cd -
:pwd
/home/Bram/VeryLongFileName
:cd -
:pwd
/etc</pre>
</div>
</div>
<div class="sect3">
<h4 id="_window_local_directory">WINDOW LOCAL DIRECTORY</h4>
<div class="paragraph">
<p>When you split a window, both windows use the same current directory.  When
you want to edit a number of files somewhere else in the new window, you can
make it use a different directory, without changing the current directory in
the other window.  This is called a local directory. &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:pwd
/home/Bram/VeryLongFileName
:split
:lcd /etc
:pwd
/etc
CTRL-W w
:pwd
/home/Bram/VeryLongFileName</pre>
</div>
</div>
<div class="paragraph">
<p>So long as no <code>:lcd</code> command has been used, all windows share the same current
directory.  Doing a <code>:cd</code> command in one window will also change the current
directory of the other window.
   For a window where <code>:lcd</code> has been used a different current directory is
remembered.  Using <code>:cd</code> or <code>:lcd</code> in other windows will not change it.
   When using a <code>:cd</code> command in a window that uses a different current
directory, it will go back to using the shared directory.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tab_local_directory">TAB LOCAL DIRECTORY</h4>
<div class="paragraph">
<p>When you open a new tab page, it uses the directory of the window in the
previous tab page from which the new tab page was opened. You can change the
directory of the current tab page using the <code>:tcd</code> command. All the windows in
a tab page share this directory except for windows with a window-local
directory. Any new windows opened in this tab page will use this directory as
the current working directory. Using a <code>:cd</code> command in a tab page will not
change the working directory of tab pages which have a tab local directory.
When the global working directory is changed using the <code>:cd</code> command in a tab
page, it will also change the current tab page working directory.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_finding_a_file">Finding a file</h3>
<div class="paragraph">
<p>You are editing a C program that contains this line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#include "inits.h"</pre>
</div>
</div>
<div class="paragraph">
<p>You want to see what is in that "inits.h" file.  Move the cursor on the name
of the file and type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gf</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will find the file and edit it.
   What if the file is not in the current directory?  Vim will use the 'path'
option to find the file.  This option is a list of directory names where to
look for your file.
   Suppose you have your include files located in "c:/prog/include".  This
command will add it to the 'path' option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set path+=c:/prog/include</pre>
</div>
</div>
<div class="paragraph">
<p>This directory is an absolute path.  No matter where you are, it will be the
same place.  What if you have located files in a subdirectory, below where the
file is?  Then you can specify a relative path name.  This starts with a dot:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set path+=./proto</pre>
</div>
</div>
<div class="paragraph">
<p>This tells Vim to look in the directory "proto", below the directory where the
file in which you use "gf" is.  Thus using "gf" on "inits.h" will make Vim
look for "proto/inits.h", starting in the directory of the file.
   Without the "./", thus "proto", Vim would look in the "proto" directory
below the current directory.  And the current directory might not be where the
file that you are editing is located.</p>
</div>
<div class="paragraph">
<p>The 'path' option allows specifying the directories where to search for files
in many more ways.  See the help on the 'path' option.
   The 'isfname' option is used to decide which characters are included in the
file name, and which ones are not (e.g., the " character in the example
above).</p>
</div>
<div class="paragraph">
<p>When you know the file name, but it&#8217;s not to be found in the file, you can
type it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:find inits.h</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will then use the 'path' option to try and locate the file.  This is the
same as the ":edit" command, except for the use of 'path'.</p>
</div>
<div class="paragraph">
<p>To open the found file in a new window use CTRL-W f instead of "gf", or use
":sfind" instead of ":find".</p>
</div>
<div class="paragraph">
<p>A nice way to directly start Vim to edit a file somewhere in the 'path':</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim "+find stdio.h"</pre>
</div>
</div>
<div class="paragraph">
<p>This finds the file "stdio.h" in your value of 'path'.  The quotes are
necessary to have one argument |-+c|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_buffer_list">The buffer list</h3>
<div class="paragraph">
<p>The Vim editor uses the term buffer to describe a file being edited.
Actually, a buffer is a copy of the file that you edit.  When you finish
changing the buffer, you write the contents of the buffer to the file.
Buffers not only contain file contents, but also all the marks, settings, and
other stuff that goes with it.</p>
</div>
<div class="sect3">
<h4 id="_hidden_buffers">HIDDEN BUFFERS</h4>
<div class="paragraph">
<p>Suppose you are editing the file one.txt and need to edit the file two.txt.
You could simply use ":edit two.txt", but since you made changes to one.txt
that won&#8217;t work.  You also don&#8217;t want to write one.txt yet.  Vim has a
solution for you:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:hide edit two.txt</pre>
</div>
</div>
<div class="paragraph">
<p>The buffer "one.txt" disappears from the screen, but Vim still knows that you
are editing this buffer, so it keeps the modified text.  This is called a
hidden buffer: The buffer contains text, but you can&#8217;t see it.
   The argument of ":hide" is another command.  ":hide" makes that command
behave as if the 'hidden' option was set.  You could also set this option
yourself.  The effect is that when any buffer is abandoned, it becomes hidden.
   Be careful!  When you have hidden buffers with changes, don&#8217;t exit Vim
without making sure you have saved all the buffers.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inactive_buffers">INACTIVE BUFFERS</h4>
<div class="literalblock">
<div class="content">
<pre>   When a buffer has been used once, Vim remembers some information about it.
When it is not displayed in a window and it is not hidden, it is still in the
buffer list.  This is called an inactive buffer.  Overview:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Active               Appears in a window, text loaded.
Hidden               Not in a window, text loaded.
Inactive             Not in a window, no text loaded.</pre>
</div>
</div>
<div class="paragraph">
<p>The inactive buffers are remembered, because Vim keeps information about them,
like marks.  And remembering the file name is useful too, so that you can see
which files you have edited.  And edit them again.</p>
</div>
</div>
<div class="sect3">
<h4 id="_listing_buffers">LISTING BUFFERS</h4>
<div class="paragraph">
<p>View the buffer list with this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:buffers</pre>
</div>
</div>
<div class="paragraph">
<p>A command which does the same, is not so obvious to list buffers, but is much
shorter to type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:ls</pre>
</div>
</div>
<div class="paragraph">
<p>The output could look like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>1 #h   "help.txt"                     line 62
2 %a + "usr_21.txt"                   line 1
3      "usr_toc.txt"                  line 1</pre>
</div>
</div>
<div class="paragraph">
<p>The first column contains the buffer number.  You can use this to edit the
buffer without having to type the name, see below.
   After the buffer number come the flags.  Then the name of the file
and the line number where the cursor was the last time.
   The flags that can appear are these (from left to right):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>u       Buffer is unlisted |unlisted-buffer|.
 %      Current buffer.
 #      Alternate buffer.
  a     Buffer is loaded and displayed.
  h     Buffer is loaded but hidden.
   =    Buffer is read-only.
   -    Buffer is not modifiable, the 'modifiable' option is off.
    +   Buffer has been modified.</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_editing_a_buffer">EDITING A BUFFER</h4>
<div class="paragraph">
<p>You can edit a buffer by its number.  That avoids having to type the file
name:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:buffer 2</pre>
</div>
</div>
<div class="paragraph">
<p>But the only way to know the number is by looking in the buffer list.  You can
use the name, or part of it, instead:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:buffer help</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will find the best match for the name you type.  If there is only one
buffer that matches the name, it will be used.  In this case "help.txt".
   To open a buffer in a new window:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:sbuffer 3</pre>
</div>
</div>
<div class="paragraph">
<p>This works with a name as well.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_the_buffer_list">USING THE BUFFER LIST</h4>
<div class="paragraph">
<p>You can move around in the buffer list with these commands:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:bnext          go to next buffer
:bprevious      go to previous buffer
:bfirst         go to the first buffer
:blast          go to the last buffer</pre>
</div>
</div>
<div class="paragraph">
<p>To remove a buffer from the list, use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:bdelete 3</pre>
</div>
</div>
<div class="paragraph">
<p>Again, this also works with a name.
   If you delete a buffer that was active (visible in a window), that window
will be closed.  If you delete the current buffer, the current window will be
closed.  If it was the last window, Vim will find another buffer to edit.  You
can&#8217;t be editing nothing!</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
Even after removing the buffer with ":bdelete" Vim still remembers it.
It's actually made "unlisted", it no longer appears in the list from
":buffers".  The ":buffers!" command will list unlisted buffers (yes,
Vim can do the impossible).  To really make Vim forget about a buffer,
use ":bwipe".  Also see the 'buflisted' option.</pre>
</div>
</div>
<div class="paragraph">
<p>Next chapter: |usr_23.txt|  Editing other files</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_editing_other_files">Editing other files</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter is about editing files that are not ordinary files.  With Vim you
can edit files that are compressed or encrypted.  Some files need to be
accessed over the internet.  With some restrictions, binary files can be
edited as well.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>DOS, Mac and Unix files</p>
</li>
<li>
<p>Files on the internet</p>
</li>
<li>
<p>Encryption</p>
</li>
<li>
<p>Binary files</p>
</li>
<li>
<p>Compressed files</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_dos_mac_and_unix_files">DOS, Mac and Unix files</h3>
<div class="paragraph">
<p>Back in the early days, the old Teletype machines used two characters to
start a new line.  One to move the carriage back to the first position
(carriage return, &lt;CR&gt;), another to move the paper up (line feed, &lt;LF&gt;).
   When computers came out, storage was expensive.  Some people decided that
they did not need two characters for end-of-line.  The UNIX people decided
they could use &lt;Line Feed&gt; only for end-of-line.  The Apple people
standardized on &lt;CR&gt;.  The Microsoft Windows folks decided to keep
the old &lt;CR&gt;&lt;LF&gt;.
   This means that if you try to move a file from one system to another, you
have line-break problems.  The Vim editor automatically recognizes the
different file formats and handles things properly behind your back.
   The option 'fileformats' contains the various formats that will be tried
when a new file is edited.  The following command, for example, tells Vim to
try UNIX format first and MS-DOS format second:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set fileformats=unix,dos</pre>
</div>
</div>
<div class="paragraph">
<p>You will notice the format in the message you get when editing a file.  You
don&#8217;t see anything if you edit a native file format.  Thus editing a Unix file
on Unix won&#8217;t result in a remark.  But when you edit a dos file, Vim will
notify you of this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"/tmp/test" [dos] 3L, 71C</pre>
</div>
</div>
<div class="paragraph">
<p>For a Mac file you would see "[mac]".
   The detected file format is stored in the 'fileformat' option.  To see
which format you have, execute the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set fileformat?</pre>
</div>
</div>
<div class="paragraph">
<p>The three names that Vim uses are:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>unix            &lt;LF&gt;
dos             &lt;CR&gt;&lt;LF&gt;
mac             &lt;CR&gt;</pre>
</div>
</div>
<div class="sect3">
<h4 id="_using_the_mac_format">USING THE MAC FORMAT</h4>
<div class="paragraph">
<p>On Unix, &lt;LF&gt; is used to break a line.  It&#8217;s not unusual to have a &lt;CR&gt;
character halfway a line.  Incidentally, this happens quite often in Vi (and
Vim) scripts.
   On the Macintosh, where &lt;CR&gt; is the line break character, it&#8217;s possible to
have a &lt;LF&gt; character halfway a line.
   The result is that it&#8217;s not possible to be 100% sure whether a file
containing both &lt;CR&gt; and &lt;LF&gt; characters is a Mac or a Unix file.  Therefore,
Vim assumes that on Unix you probably won&#8217;t edit a Mac file, and doesn&#8217;t check
for this type of file.  To check for this format anyway, add "mac" to
'fileformats':</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set fileformats+=mac</pre>
</div>
</div>
<div class="paragraph">
<p>Then Vim will take a guess at the file format.  Watch out for situations where
Vim guesses wrong.</p>
</div>
</div>
<div class="sect3">
<h4 id="_overruling_the_format">OVERRULING THE FORMAT</h4>
<div class="paragraph">
<p>If you use the good old Vi and try to edit an MS-DOS format file, you will
find that each line ends with a ^M character.  (^M is &lt;CR&gt;).  The automatic
detection avoids this.  Suppose you do want to edit the file that way?  Then
you need to overrule the format:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit ++ff=unix file.txt</pre>
</div>
</div>
<div class="paragraph">
<p>The "" string is an item that tells Vim that an option name follows, which
overrules the default for this single command.  "ff" is used for
'fileformat'.  You could also use "ff=mac" or "ff=dos".
   This doesn&#8217;t work for any option, only "ff" and "enc" are currently
implemented.  The full names "fileformat" and "encoding" also work.</p>
</div>
</div>
<div class="sect3">
<h4 id="_conversion">CONVERSION</h4>
<div class="paragraph">
<p>You can use the 'fileformat' option to convert from one file format to
another.  Suppose, for example, that you have an MS-DOS file named README.TXT
that you want to convert to UNIX format.  Start by editing the MS-DOS format
file:
        vim README.TXT</p>
</div>
<div class="paragraph">
<p>Vim will recognize this as a dos format file.  Now change the file format to
UNIX:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set fileformat=unix
:write</pre>
</div>
</div>
<div class="paragraph">
<p>The file is written in Unix format.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_files_on_the_internet">Files on the internet</h3>
<div class="paragraph">
<p>Someone sends you an e-mail message, which refers to a file by its URL.  For
example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>You can find the information here:
        ftp://ftp.vim.org/pub/vim/README</pre>
</div>
</div>
<div class="paragraph">
<p>You could start a program to download the file, save it on your local disk and
then start Vim to edit it.
   There is a much simpler way.  Move the cursor to any character of the URL.
Then use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gf</pre>
</div>
</div>
<div class="paragraph">
<p>With a bit of luck, Vim will figure out which program to use for downloading
the file, download it and edit the copy.  To open the file in a new window use
CTRL-W f.
   If something goes wrong you will get an error message.  It&#8217;s possible that
the URL is wrong, you don&#8217;t have permission to read it, the network connection
is down, etc.  Unfortunately, it&#8217;s hard to tell the cause of the error.  You
might want to try the manual way of downloading the file.</p>
</div>
<div class="paragraph">
<p>Accessing files over the internet works with the netrw plugin.  Currently URLs
with these formats are recognized:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ftp://          uses ftp
rcp://          uses rcp
scp://          uses scp
http://         uses wget (reading only)</pre>
</div>
</div>
<div class="paragraph">
<p>Vim doesn&#8217;t do the communication itself, it relies on the mentioned programs
to be available on your computer.  On most Unix systems "ftp" and "rcp" will
be present.  "scp" and "wget" might need to be installed.</p>
</div>
<div class="paragraph">
<p>Vim detects these URLs for each command that starts editing a new file, also
with ":edit" and ":split", for example.  Write commands also work, except for
http://.</p>
</div>
<div class="paragraph">
<p>For more information, also about passwords, see |netrw|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_encryption">Encryption</h3>
<div class="paragraph">
<p>Some information you prefer to keep to yourself.  For example, when writing
a test on a computer that students also use.  You don&#8217;t want clever students
to figure out a way to read the questions before the exam starts.  Vim can
encrypt the file for you, which gives you some protection.
   To start editing a new file with encryption, use the "-x" argument to start
Vim.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim -x exam.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Vim prompts you for a key used for encrypting and decrypting the file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Enter encryption key:</pre>
</div>
</div>
<div class="paragraph">
<p>Carefully type the secret key now.  You cannot see the characters you type,
they will be replaced by stars.  To avoid the situation that a typing mistake
will cause trouble, Vim asks you to enter the key again:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Enter same key again:</pre>
</div>
</div>
<div class="paragraph">
<p>You can now edit this file normally and put in all your secrets.  When you
finish editing the file and tell Vim to exit, the file is encrypted and
written.
   When you edit the file with Vim, it will ask you to enter the same key
again.  You don&#8217;t need to use the "-x" argument.  You can also use the normal
":edit" command.  Vim adds a magic string to the file by which it recognizes
that the file was encrypted.
   If you try to view this file using another program, all you get is garbage.
Also, if you edit the file with Vim and enter the wrong key, you get garbage.
Vim does not have a mechanism to check if the key is the right one (this makes
it much harder to break the key).</p>
</div>
<div class="sect3">
<h4 id="_switching_encryption_on_and_off">SWITCHING ENCRYPTION ON AND OFF</h4>
<div class="paragraph">
<p>To disable the encryption of a file, set the 'key' option to an empty string:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set key=</pre>
</div>
</div>
<div class="paragraph">
<p>The next time you write the file this will be done without encryption.
   Setting the 'key' option to enable encryption is not a good idea, because
the password appears in the clear.  Anyone shoulder-surfing can read your
password.
   To avoid this problem, the ":X" command was created.  It asks you for an
encryption key, just like the "-x" argument did:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:X
Enter encryption key: ******
Enter same key again: ******</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_limits_on_encryption">LIMITS ON ENCRYPTION</h4>
<div class="paragraph">
<p>The encryption algorithm used by Vim is not very strong.  It is good enough to
keep out the casual prowler, but not good enough to keep out a cryptology
expert with lots of time on his hands.  The text in the swap file and the undo
file is also encrypted.  However, this is done block-by-block and may reduce
the time needed to crack a password.  You can disable the swap file, but then
a crash will cause you to lose your work, since Vim keeps all the text in
memory only.  The undo file can be disabled with the only disadvantage that
you can&#8217;t undo after unloading the buffer.
   To avoid using a swap file, supply the -n argument on the command line.
For example, to edit the encrypted file "file.txt" without a swap file use the
following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim -x -n file.txt</pre>
</div>
</div>
<div class="paragraph">
<p>When already editing a file, the swapfile can be disabled with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:setlocal noswapfile</pre>
</div>
</div>
<div class="paragraph">
<p>Since there is no swapfile, recovery will be impossible.  Save the file a bit
more often to avoid the risk of losing your changes.</p>
</div>
<div class="paragraph">
<p>While the file is in memory, it is in plain text.  Anyone with privilege can
look in the editor&#8217;s memory and discover the contents of the file.
   If you use a viminfo file, be aware that the contents of text registers are
written out in the clear as well.
   If you really want to secure the contents of a file, edit it only on a
portable computer not connected to a network, use good encryption tools, and
keep the computer locked up in a big safe when not in use.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_binary_files">Binary files</h3>
<div class="paragraph">
<p>You can edit binary files with Vim.  Vim wasn&#8217;t really made for this, thus
there are a few restrictions.  But you can read a file, change a character and
write it back, with the result that only that one character was changed and
the file is identical otherwise.
   To make sure that Vim does not use its clever tricks in the wrong way, add
the "-b" argument when starting Vim:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim -b datafile</pre>
</div>
</div>
<div class="paragraph">
<p>This sets the 'binary' option.  The effect of this is that unexpected side
effects are turned off.  For example, 'textwidth' is set to zero, to avoid
automatic formatting of lines.  And files are always read in Unix file format.</p>
</div>
<div class="paragraph">
<p>Binary mode can be used to change a message in a program.  Be careful not to
insert or delete any characters, it would stop the program from working.  Use
"R" to enter replace mode.</p>
</div>
<div class="paragraph">
<p>Many characters in the file will be unprintable.  To see them in Hex format:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set display=uhex</pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, the "ga" command can be used to see the value of the character
under the cursor.  The output, when the cursor is on an &lt;Esc&gt;, looks like
this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;^[&gt;  27,  Hex 1b,  Octal 033</pre>
</div>
</div>
<div class="paragraph">
<p>There might not be many line breaks in the file.  To get some overview switch
the 'wrap' option off:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set nowrap</pre>
</div>
</div>
<div class="sect3">
<h4 id="_byte_position">BYTE POSITION</h4>
<div class="paragraph">
<p>To see on which byte you are in the file use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>g CTRL-G</pre>
</div>
</div>
<div class="paragraph">
<p>The output is verbose:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Col 9-16 of 9-16; Line 277 of 330; Word 1806 of 2058; Byte 10580 of 12206</pre>
</div>
</div>
<div class="paragraph">
<p>The last two numbers are the byte position in the file and the total number of
bytes.  This takes into account how 'fileformat' changes the number of bytes
that a line break uses.
    To move to a specific byte in the file, use the "go" command.  For
example, to move to byte 2345:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>2345go</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_xxd">USING XXD</h4>
<div class="paragraph">
<p>A real binary editor shows the text in two ways: as it is and in hex format.
You can do this in Vim by first converting the file with the "xxd" program.
This comes with Vim.
   First edit the file in binary mode:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim -b datafile</pre>
</div>
</div>
<div class="paragraph">
<p>Now convert the file to a hex dump with xxd:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:%!xxd</pre>
</div>
</div>
<div class="paragraph">
<p>The text will look like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>0000000: 1f8b 0808 39d7 173b 0203 7474 002b 4e49  ....9..;..tt.+NI
0000010: 4b2c 8660 eb9c ecac c462 eb94 345e 2e30  K,.`.....b..4^.0
0000020: 373b 2731 0b22 0ca6 c1a2 d669 1035 39d9  7;'1.".....i.59.</pre>
</div>
</div>
<div class="paragraph">
<p>You can now view and edit the text as you like.  Vim treats the information as
ordinary text.  Changing the hex does not cause the printable character to be
changed, or the other way around.
   Finally convert it back with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:%!xxd -r</pre>
</div>
</div>
<div class="paragraph">
<p>Only changes in the hex part are used.  Changes in the printable text part on
the right are ignored.</p>
</div>
<div class="paragraph">
<p>See the manual page of xxd for more information.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compressed_files">Compressed files</h3>
<div class="paragraph">
<p>This is easy: You can edit a compressed file just like any other file.  The
"gzip" plugin takes care of decompressing the file when you edit it.  And
compressing it again when you write it.
   These compression methods are currently supported:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>.Z      compress
.gz     gzip
.bz2    bzip2</pre>
</div>
</div>
<div class="paragraph">
<p>Vim uses the mentioned programs to do the actual compression and
decompression.  You might need to install the programs first.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_24.txt|  Inserting quickly</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_inserting_quickly">Inserting quickly</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When entering text, Vim offers various ways to reduce the number of keystrokes
and avoid typing mistakes.  Use Insert mode completion to repeat previously
typed words.  Abbreviate long words to short ones.  Type characters that
aren&#8217;t on your keyboard.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Making corrections</p>
</li>
<li>
<p>Showing matches</p>
</li>
<li>
<p>Completion</p>
</li>
<li>
<p>Repeating an insert</p>
</li>
<li>
<p>Copying from another line</p>
</li>
<li>
<p>Inserting a register</p>
</li>
<li>
<p>Abbreviations</p>
</li>
<li>
<p>Entering special characters</p>
</li>
<li>
<p>Digraphs</p>
</li>
<li>
<p>Normal mode commands</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_making_corrections">Making corrections</h3>
<div class="paragraph">
<p>The &lt;BS&gt; key was already mentioned.  It deletes the character just before the
cursor.  The &lt;Del&gt; key does the same for the character under (after) the
cursor.
   When you typed a whole word wrong, use CTRL-W:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The horse had fallen to the sky
                               CTRL-W
The horse had fallen to the</pre>
</div>
</div>
<div class="paragraph">
<p>If you really messed up a line and want to start over, use CTRL-U to delete
it.  This keeps the text after the cursor and the indent.  Only the text from
the first non-blank to the cursor is deleted.  With the cursor on the "f" of
"fallen" in the next line pressing CTRL-U does this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The horse had fallen to the
              CTRL-U
fallen to the</pre>
</div>
</div>
<div class="paragraph">
<p>When you spot a mistake a few words back, you need to move the cursor there to
correct it.  For example, you typed this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The horse had follen to the ground</pre>
</div>
</div>
<div class="paragraph">
<p>You need to change "follen" to "fallen".  With the cursor at the end, you
would type this to correct it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;Esc&gt;4blraA</pre>
</div>
</div>
<div class="paragraph">
<p>&lt;       get out of Insert mode          &lt;Esc&gt;
        four words back                      4b
        move on top of the "o"                 l
        replace with "a"                        ra
        restart Insert mode                       A</p>
</div>
<div class="paragraph">
<p>Another way to do this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;&lt;Right&gt;&lt;Del&gt;a&lt;End&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>&lt;       four words back              &lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;&lt;C-Left&gt;
        move on top of the "o"                  &lt;Right&gt;
        delete the "o"                                 &lt;Del&gt;
        insert an "a"                                       a
        go to end of the line                                &lt;End&gt;</p>
</div>
<div class="paragraph">
<p>This uses special keys to move around, while remaining in Insert mode.  This
resembles what you would do in a modeless editor.  It&#8217;s easier to remember,
but takes more time (you have to move your hand from the letters to the cursor
keys, and the &lt;End&gt; key is hard to press without looking at the keyboard).
   These special keys are most useful when writing a mapping that doesn&#8217;t
leave Insert mode.  The extra typing doesn&#8217;t matter then.
   An overview of the keys you can use in Insert mode:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;C-Home&gt;        to start of the file
&lt;PageUp&gt;        a whole screenful up
&lt;Home&gt;          to start of line
&lt;S-Left&gt;        one word left
&lt;C-Left&gt;        one word left
&lt;S-Right&gt;       one word right
&lt;C-Right&gt;       one word right
&lt;End&gt;           to end of the line
&lt;PageDown&gt;      a whole screenful down
&lt;C-End&gt;         to end of the file</pre>
</div>
</div>
<div class="paragraph">
<p>There are a few more, see |ins-special-special|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_showing_matches">Showing matches</h3>
<div class="paragraph">
<p>When you type a ) it would be nice to see with which ( it matches.  To make
Vim do that use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set showmatch</pre>
</div>
</div>
<div class="paragraph">
<p>When you now type a text like "(example)", as soon as you type the ) Vim will
briefly move the cursor to the matching (, keep it there for half a second,
and move back to where you were typing.
   In case there is no matching (, Vim will beep.  Then you know that you
might have forgotten the ( somewhere, or typed a ) too many.
   The match will also be shown for [] and {} pairs.  You don&#8217;t have to wait
with typing the next character, as soon as Vim sees it the cursor will move
back and inserting continues as before.
   You can change the time Vim waits with the 'matchtime' option.  For
example, to make Vim wait one and a half second:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set matchtime=15</pre>
</div>
</div>
<div class="paragraph">
<p>The time is specified in tenths of a second.</p>
</div>
</div>
<div class="sect2">
<h3 id="_completion">Completion</h3>
<div class="paragraph">
<p>Vim can automatically complete words on insertion.  You type the first part of
a word, press CTRL-P, and Vim guesses the rest.
   Suppose, for example, that you are creating a C program and want to type in
the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>total = ch_array[0] + ch_array[1] + ch_array[2];</pre>
</div>
</div>
<div class="paragraph">
<p>You start by entering the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>total = ch_array[0] + ch_</pre>
</div>
</div>
<div class="paragraph">
<p>At this point, you tell Vim to complete the word using the command CTRL-P.
Vim searches for a word that starts with what&#8217;s in front of the cursor.  In
this case, it is "ch_", which matches with the word ch_array.  So typing
CTRL-P gives you the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>total = ch_array[0] + ch_array</pre>
</div>
</div>
<div class="paragraph">
<p>After a little more typing, you get this (ending in a space):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>total = ch_array[0] + ch_array[1] +</pre>
</div>
</div>
<div class="paragraph">
<p>If you now type CTRL-P Vim will search again for a word that completes the
word before the cursor.  Since there is nothing in front of the cursor, it
finds the first word backwards, which is "ch_array".  Typing CTRL-P again
gives you the next word that matches, in this case "total".  A third CTRL-P
searches further back.  If there is nothing else, it causes the editor to run
out of words, so it returns to the original text, which is nothing.  A fourth
CTRL-P causes the editor to start over again with "ch_array".</p>
</div>
<div class="paragraph">
<p>To search forward, use CTRL-N.  Since the search wraps around the end of the
file, CTRL-N and CTRL-P will find the same matches, but in a different
sequence.  Hint: CTRL-N is Next-match and CTRL-P is Previous-match.</p>
</div>
<div class="paragraph">
<p>The Vim editor goes through a lot of effort to find words to complete.  By
default, it searches the following places:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Current file</p>
</li>
<li>
<p>Files in other windows</p>
</li>
<li>
<p>Other loaded files (hidden buffers)</p>
</li>
<li>
<p>Files which are not loaded (inactive buffers)</p>
</li>
<li>
<p>Tag files</p>
</li>
<li>
<p>All files #included by the current file</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_options_2">OPTIONS</h4>
<div class="paragraph">
<p>You can customize the search order with the 'complete' option.</p>
</div>
<div class="paragraph">
<p>The 'ignorecase' option is used.  When it is set, case differences are ignored
when searching for matches.</p>
</div>
<div class="paragraph">
<p>A special option for completion is 'infercase'.  This is useful to find
matches while ignoring case ('ignorecase' must be set) but still using the
case of the word typed so far.  Thus if you type "For" and Vim finds a match
"fortunately", it will result in "Fortunately".</p>
</div>
</div>
<div class="sect3">
<h4 id="_completing_specific_items">COMPLETING SPECIFIC ITEMS</h4>
<div class="paragraph">
<p>If you know what you are looking for, you can use these commands to complete
with a certain type of item:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-X CTRL-F           file names
CTRL-X CTRL-L           whole lines
CTRL-X CTRL-D           macro definitions (also in included files)
CTRL-X CTRL-I           current and included files
CTRL-X CTRL-K           words from a dictionary
CTRL-X CTRL-T           words from a thesaurus
CTRL-X CTRL-]           tags
CTRL-X CTRL-V           Vim command line</pre>
</div>
</div>
<div class="paragraph">
<p>After each of them CTRL-N can be used to find the next match, CTRL-P to find
the previous match.
   More information for each of these commands here: |ins-completion|.</p>
</div>
</div>
<div class="sect3">
<h4 id="_completing_file_names">COMPLETING FILE NAMES</h4>
<div class="paragraph">
<p>Let&#8217;s take CTRL-X CTRL-F as an example.  This will find file names.  It scans
the current directory for files and displays each one that matches the word in
front of the cursor.
   Suppose, for example, that you have the following files in the current
directory:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>main.c  sub_count.c  sub_done.c  sub_exit.c</pre>
</div>
</div>
<div class="paragraph">
<p>Now enter Insert mode and start typing:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The exit code is in the file sub</pre>
</div>
</div>
<div class="paragraph">
<p>At this point, you enter the command CTRL-X CTRL-F.  Vim now completes the
current word "sub" by looking at the files in the current directory.  The
first match is sub_count.c.  This is not the one you want, so you match the
next file by typing CTRL-N.  This match is sub_done.c.  Typing CTRL-N again
takes you to sub_exit.c.  The results:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The exit code is in the file sub_exit.c</pre>
</div>
</div>
<div class="paragraph">
<p>If the file name starts with / (Unix) or C:\ (MS-Windows) you can find all
files in the file system.  For example, type "/u" and CTRL-X CTRL-F.  This
will match "/usr" (this is on Unix):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>the file is found in /usr/</pre>
</div>
</div>
<div class="paragraph">
<p>If you now press CTRL-N you go back to "/u".  Instead, to accept the "/usr/"
and go one directory level deeper, use CTRL-X CTRL-F again:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>the file is found in /usr/X11R6/</pre>
</div>
</div>
<div class="paragraph">
<p>The results depend on what is found in your file system, of course.  The
matches are sorted alphabetically.</p>
</div>
</div>
<div class="sect3">
<h4 id="_completing_in_source_code">COMPLETING IN SOURCE CODE</h4>
<div class="paragraph">
<p>Source code files are well structured.  That makes it possible to do
completion in an intelligent way.  In Vim this is called Omni completion.  In
some other editors it&#8217;s called intellisense, but that is a trademark.</p>
</div>
<div class="paragraph">
<p>The key to Omni completion is CTRL-X CTRL-O.  Obviously the O stands for Omni
here, so that you can remember it easier.  Let&#8217;s use an example for editing C
source:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>{
    struct foo *p;
    p-&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The cursor is after "p&#8594;".  Now type CTRL-X CTRL-O.  Vim will offer you a list
of alternatives, which are the items that "struct foo" contains.  That is
quite different from using CTRL-P, which would complete any word, while only
members of "struct foo" are valid here.</p>
</div>
<div class="paragraph">
<p>For Omni completion to work you may need to do some setup.  At least make sure
filetype plugins are enabled.  Your vimrc file should contain a line like
this:
        filetype plugin on
Or:
        filetype plugin indent on</p>
</div>
<div class="paragraph">
<p>For C code you need to create a tags file and set the 'tags' option.  That is
explained |ft-c-omni|.  For other filetypes you may need to do something
similar, look below |compl-omni-filetypes|.  It only works for specific
filetypes.  Check the value of the 'omnifunc' option to find out if it would
work.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_repeating_an_insert">Repeating an insert</h3>
<div class="paragraph">
<p>If you press CTRL-A, the editor inserts the text you typed the last time you
were in Insert mode.
   Assume, for example, that you have a file that begins with the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"file.h"
/* Main program begins */</pre>
</div>
</div>
<div class="paragraph">
<p>You edit this file by inserting "#include " at the beginning of the first
line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#include "file.h"
/* Main program begins */</pre>
</div>
</div>
<div class="paragraph">
<p>You go down to the beginning of the next line using the commands "j^".  You
now start to insert a new "#include" line.  So you type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>i CTRL-A</pre>
</div>
</div>
<div class="paragraph">
<p>The result is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#include "file.h"
#include /* Main program begins */</pre>
</div>
</div>
<div class="paragraph">
<p>The "#include " was inserted because CTRL-A inserts the text of the previous
insert.  Now you type  "main.h"&lt;Enter&gt;  to finish the line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#include "file.h"
#include "main.h"
/* Main program begins */</pre>
</div>
</div>
<div class="paragraph">
<p>The CTRL-@ command does a CTRL-A and then exits Insert mode.  That&#8217;s a quick
way of doing exactly the same insertion again.</p>
</div>
</div>
<div class="sect2">
<h3 id="_copying_from_another_line">Copying from another line</h3>
<div class="paragraph">
<p>The CTRL-Y command inserts the character above the cursor.  This is useful
when you are duplicating a previous line.  For example, you have this line of
C code:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>b_array[i]-&gt;s_next = a_array[i]-&gt;s_next;</pre>
</div>
</div>
<div class="paragraph">
<p>Now you need to type the same line, but with "s_prev" instead of "s_next".
Start the new line, and press CTRL-Y 14 times, until you are at the "n" of
"next":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>b_array[i]-&gt;s_next = a_array[i]-&gt;s_next;
b_array[i]-&gt;s_</pre>
</div>
</div>
<div class="paragraph">
<p>Now you type "prev":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>b_array[i]-&gt;s_next = a_array[i]-&gt;s_next;
b_array[i]-&gt;s_prev</pre>
</div>
</div>
<div class="paragraph">
<p>Continue pressing CTRL-Y until the following "next":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>b_array[i]-&gt;s_next = a_array[i]-&gt;s_next;
b_array[i]-&gt;s_prev = a_array[i]-&gt;s_</pre>
</div>
</div>
<div class="paragraph">
<p>Now type "prev;" to finish it off.</p>
</div>
<div class="paragraph">
<p>The CTRL-E command acts like CTRL-Y except it inserts the character below the
cursor.</p>
</div>
</div>
<div class="sect2">
<h3 id="_inserting_a_register">Inserting a register</h3>
<div class="paragraph">
<p>The command CTRL-R {register} inserts the contents of the register.  This is
useful to avoid having to type a long word.  For example, you need to type
this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>r = VeryLongFunction(a) + VeryLongFunction(b) + VeryLongFunction(c)</pre>
</div>
</div>
<div class="paragraph">
<p>The function name is defined in a different file.  Edit that file and move the
cursor on top of the function name there, and yank it into register v:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"vyiw</pre>
</div>
</div>
<div class="paragraph">
<p>"v is the register specification, "yiw" is yank-inner-word.  Now edit the file
where the new line is to be inserted, and type the first letters:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>r =</pre>
</div>
</div>
<div class="paragraph">
<p>Now use CTRL-R v to insert the function name:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>r = VeryLongFunction</pre>
</div>
</div>
<div class="paragraph">
<p>You continue to type the characters in between the function name, and use
CTRL-R v two times more.
   You could have done the same with completion.  Using a register is useful
when there are many words that start with the same characters.</p>
</div>
<div class="paragraph">
<p>If the register contains characters such as &lt;BS&gt; or other special characters,
they are interpreted as if they had been typed from the keyboard.  If you do
not want this to happen (you really want the &lt;BS&gt; to be inserted in the text),
use the command CTRL-R CTRL-R {register}.</p>
</div>
</div>
<div class="sect2">
<h3 id="_abbreviations">Abbreviations</h3>
<div class="paragraph">
<p>An abbreviation is a short word that takes the place of a long one.  For
example, "ad" stands for "advertisement".  Vim enables you to type an
abbreviation and then will automatically expand it for you.
   To tell Vim to expand "ad" into "advertisement" every time you insert it,
use the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:iabbrev ad advertisement</pre>
</div>
</div>
<div class="paragraph">
<p>Now, when you type "ad", the whole word "advertisement" will be inserted into
the text.  This is triggered by typing a character that can&#8217;t be part of a
word, for example a space:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>What Is Entered         What You See
I saw the a             I saw the a
I saw the ad            I saw the ad
I saw the ad&lt;Space&gt;     I saw the advertisement&lt;Space&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The expansion doesn&#8217;t happen when typing just "ad".  That allows you to type a
word like "add", which will not get expanded.  Only whole words are checked
for abbreviations.</p>
</div>
<div class="sect3">
<h4 id="_abbreviating_several_words">ABBREVIATING SEVERAL WORDS</h4>
<div class="paragraph">
<p>It is possible to define an abbreviation that results in multiple words.  For
example, to define "JB" as "Jack Benny", use the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:iabbrev JB Jack Benny</pre>
</div>
</div>
<div class="paragraph">
<p>As a programmer, I use two rather unusual abbreviations:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:iabbrev #b /****************************************
:iabbrev #e &lt;Space&gt;****************************************/</pre>
</div>
</div>
<div class="paragraph">
<p>These are used for creating boxed comments.  The comment starts with #b, which
draws the top line.  I then type the comment text and use #e to draw the
bottom line.
   Notice that the #e abbreviation begins with a space.  In other words, the
first two characters are space-star.  Usually Vim ignores spaces between the
abbreviation and the expansion.  To avoid that problem, I spell space as seven
characters: &lt;, S, p, a, c, e, &gt;.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
":iabbrev" is a long word to type.  ":iab" works just as well.
That's abbreviating the abbreviate command!</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fixing_typing_mistakes">FIXING TYPING MISTAKES</h4>
<div class="paragraph">
<p>It&#8217;s very common to make the same typing mistake every time.  For example,
typing "teh" instead of "the".  You can fix this with an abbreviation:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:abbreviate teh the</pre>
</div>
</div>
<div class="paragraph">
<p>You can add a whole list of these.  Add one each time you discover a common
mistake.</p>
</div>
</div>
<div class="sect3">
<h4 id="_listing_abbreviations">LISTING ABBREVIATIONS</h4>
<div class="paragraph">
<p>The ":abbreviate" command lists the abbreviations:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:abbreviate
i  #e             ****************************************/
i  #b            /****************************************
i  JB            Jack Benny
i  ad            advertisement
!  teh           the</pre>
</div>
</div>
<div class="paragraph">
<p>The "i" in the first column indicates Insert mode.  These abbreviations are
only active in Insert mode.  Other possible characters are:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>c       Command-line mode                       :cabbrev
!       both Insert and Command-line mode       :abbreviate</pre>
</div>
</div>
<div class="paragraph">
<p>Since abbreviations are not often useful in Command-line mode, you will mostly
use the ":iabbrev" command.  That avoids, for example, that "ad" gets expanded
when typing a command like:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit ad</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_deleting_abbreviations">DELETING ABBREVIATIONS</h4>
<div class="paragraph">
<p>To get rid of an abbreviation, use the ":unabbreviate" command.  Suppose you
have the following abbreviation:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:abbreviate @f fresh</pre>
</div>
</div>
<div class="paragraph">
<p>You can remove it with this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:unabbreviate @f</pre>
</div>
</div>
<div class="paragraph">
<p>While you type this, you will notice that @f is expanded to "fresh".  Don&#8217;t
worry about this, Vim understands it anyway (except when you have an
abbreviation for "fresh", but that&#8217;s very unlikely).
   To remove all the abbreviations:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:abclear</pre>
</div>
</div>
<div class="paragraph">
<p>":unabbreviate" and ":abclear" also come in the variants for Insert mode
(":iunabbreviate and ":iabclear") and Command-line mode (":cunabbreviate" and
":cabclear").</p>
</div>
</div>
<div class="sect3">
<h4 id="_remapping_abbreviations">REMAPPING ABBREVIATIONS</h4>
<div class="paragraph">
<p>There is one thing to watch out for when defining an abbreviation: The
resulting string should not be mapped.  For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:abbreviate @a adder
:imap dd disk-door</pre>
</div>
</div>
<div class="paragraph">
<p>When you now type @a, you will get "adisk-doorer".  That&#8217;s not what you want.
To avoid this, use the ":noreabbrev" command.  It does the same as
":abbreviate", but avoids that the resulting string is used for mappings:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:noreabbrev @a adder</pre>
</div>
</div>
<div class="paragraph">
<p>Fortunately, it&#8217;s unlikely that the result of an abbreviation is mapped.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_entering_special_characters">Entering special characters</h3>
<div class="paragraph">
<p>The CTRL-V command is used to insert the next character literally.  In other
words, any special meaning the character has, it will be ignored.  For
example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-V &lt;Esc&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an escape character.  Thus you don&#8217;t leave Insert mode.  (Don&#8217;t type
the space after CTRL-V, it&#8217;s only to make this easier to read).</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
On MS-Windows CTRL-V is used to paste text.  Use CTRL-Q instead of
CTRL-V.  On Unix, on the other hand, CTRL-Q does not work on some
terminals, because it has a special meaning.</pre>
</div>
</div>
<div class="paragraph">
<p>You can also use the command CTRL-V {digits} to insert a character with the
decimal number {digits}.  For example, the character number 127 is the &lt;Del&gt;
character (but not necessarily the &lt;Del&gt; key!).  To insert &lt;Del&gt; type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-V 127</pre>
</div>
</div>
<div class="paragraph">
<p>You can enter characters up to 255 this way.  When you type fewer than two
digits, a non-digit will terminate the command.  To avoid the need of typing a
non-digit, prepend one or two zeros to make three digits.
   All the next commands insert a &lt;Tab&gt; and then a dot:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-V 9.
CTRL-V 09.
CTRL-V 009.</pre>
</div>
</div>
<div class="paragraph">
<p>To enter a character in hexadecimal, use an "x" after the CTRL-V:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-V x7f</pre>
</div>
</div>
<div class="paragraph">
<p>This also goes up to character 255 (CTRL-V xff).  You can use "o" to type a
character as an octal number and two more methods allow you to type up to
a 16 bit and a 32 bit number (e.g., for a Unicode character):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-V o123
CTRL-V u1234
CTRL-V U12345678</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_digraphs">Digraphs</h3>
<div class="paragraph">
<p>Some characters are not on the keyboard.  For example, the copyright character
().  To type these characters in Vim, you use digraphs, where two characters
represent one.  To enter a , for example, you press three keys:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-K Co</pre>
</div>
</div>
<div class="paragraph">
<p>To find out what digraphs are available, use the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:digraphs</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will display the digraph table.  Here are three lines of it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>AC ~_ 159  NS |  160  !I   161  Ct   162  Pd   163  Cu   164  Ye   165
BB   166  SE   167  ':   168  Co   169  -a   170  &lt;&lt;   171  NO   172
--   173  Rg   174  'm   175  DG   176  +-   177  2S   178  3S   179</pre>
</div>
</div>
<div class="paragraph">
<p>This shows, for example, that the digraph you get by typing CTRL-K Pd is the
character ().  This is character number 163 (decimal).
   Pd is short for Pound.  Most digraphs are selected to give you a hint about
the character they will produce.  If you look through the list you will
understand the logic.
   You can exchange the first and second character, if there is no digraph for
that combination.  Thus CTRL-K dP also works.  Since there is no digraph for
"dP" Vim will also search for a "Pd" digraph.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
The digraphs depend on the character set that Vim assumes you are
using.  Always use ":digraphs" to find out which digraphs are currently
available.</pre>
</div>
</div>
<div class="paragraph">
<p>You can define your own digraphs.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:digraph a" </pre>
</div>
</div>
<div class="paragraph">
<p>This defines that CTRL-K a" inserts an  character.  You can also specify the
character with a decimal number.  This defines the same digraph:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:digraph a" 228</pre>
</div>
</div>
<div class="paragraph">
<p>More information about digraphs here: |digraphs|
   Another way to insert special characters is with a keymap.  More about that
here: |45.5|</p>
</div>
</div>
<div class="sect2">
<h3 id="_normal_mode_commands">Normal mode commands</h3>
<div class="paragraph">
<p>Insert mode offers a limited number of commands.  In Normal mode you have many
more.  When you want to use one, you usually leave Insert mode with &lt;Esc&gt;,
execute the Normal mode command, and re-enter Insert mode with "i" or "a".
   There is a quicker way.  With CTRL-O {command} you can execute any Normal
mode command from Insert mode.  For example, to delete from the cursor to the
end of the line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-O D</pre>
</div>
</div>
<div class="paragraph">
<p>You can execute only one Normal mode command this way.  But you can specify a
register or a count.  A more complicated example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-O "g3dw</pre>
</div>
</div>
<div class="paragraph">
<p>This deletes up to the third word into register g.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_25.txt|  Editing formatted text</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_editing_formatted_text">Editing formatted text</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Text hardly ever comes in one sentence per line.  This chapter is about
breaking sentences to make them fit on a page and other formatting.
Vim also has useful features for editing single-line paragraphs and tables.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Breaking lines</p>
</li>
<li>
<p>Aligning text</p>
</li>
<li>
<p>Indents and tabs</p>
</li>
<li>
<p>Dealing with long lines</p>
</li>
<li>
<p>Editing tables</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_breaking_lines">Breaking lines</h3>
<div class="paragraph">
<p>Vim has a number of functions that make dealing with text easier.  By default,
the editor does not perform automatic line breaks.  In other words, you have
to press &lt;Enter&gt; yourself.  This is useful when you are writing programs where
you want to decide where the line ends.  It is not so good when you are
creating documentation and want the text to be at most 70 character wide.
   If you set the 'textwidth' option, Vim automatically inserts line breaks.
Suppose, for example, that you want a very narrow column of only 30
characters.  You need to execute the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set textwidth=30</pre>
</div>
</div>
<div class="paragraph">
<p>Now you start typing (ruler added):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>         1         2         3
12345678901234567890123456789012345
I taught programming for a whi</pre>
</div>
</div>
<div class="paragraph">
<p>If you type "l" next, this makes the line longer than the 30-character limit.
When Vim sees this, it inserts a line break and you get the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>         1         2         3
12345678901234567890123456789012345
I taught programming for a
whil</pre>
</div>
</div>
<div class="paragraph">
<p>Continuing on, you can type in the rest of the paragraph:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>         1         2         3
12345678901234567890123456789012345
I taught programming for a
while. One time, I was stopped
by the Fort Worth police,
because my homework was too
hard. True story.</pre>
</div>
</div>
<div class="paragraph">
<p>You do not have to type newlines; Vim puts them in automatically.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
The 'wrap' option makes Vim display lines with a line break, but this
doesn't insert a line break in the file.</pre>
</div>
</div>
<div class="sect3">
<h4 id="_reformatting">REFORMATTING</h4>
<div class="paragraph">
<p>The Vim editor is not a word processor.  In a word processor, if you delete
something at the beginning of the paragraph, the line breaks are reworked.  In
Vim they are not; so if you delete the word "programming" from the first line,
all you get is a short line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>         1         2         3
12345678901234567890123456789012345
I taught for a
while. One time, I was stopped
by the Fort Worth police,
because my homework was too
hard. True story.</pre>
</div>
</div>
<div class="paragraph">
<p>This does not look good.  To get the paragraph into shape you use the "gq"
operator.
   Let&#8217;s first use this with a Visual selection.  Starting from the first
line, type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>v4jgq</pre>
</div>
</div>
<div class="paragraph">
<p>"v" to start Visual mode, "4j" to move to the end of the paragraph and then
the "gq" operator.  The result is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>         1         2         3
12345678901234567890123456789012345
I taught for a while. One
time, I was stopped by the
Fort Worth police, because my
homework was too hard. True
story.</pre>
</div>
</div>
<div class="paragraph">
<p>Note: there is a way to do automatic formatting for specific types of text
layouts, see |auto-format|.</p>
</div>
<div class="paragraph">
<p>Since "gq" is an operator, you can use one of the three ways to select the
text it works on: With Visual mode, with a movement and with a text object.
   The example above could also be done with "gq4j".  That&#8217;s less typing, but
you have to know the line count.  A more useful motion command is "}".  This
moves to the end of a paragraph.  Thus "gq}" formats from the cursor to the
end of the current paragraph.
   A very useful text object to use with "gq" is the paragraph.  Try this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gqap</pre>
</div>
</div>
<div class="paragraph">
<p>"ap" stands for "a-paragraph".  This formats the text of one paragraph
(separated by empty lines).  Also the part before the cursor.
   If you have your paragraphs separated by empty lines, you can format the
whole file by typing this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gggqG</pre>
</div>
</div>
<div class="paragraph">
<p>"gg" to move to the first line, "gqG" to format until the last line.
   Warning: If your paragraphs are not properly separated, they will be joined
together.  A common mistake is to have a line with a space or tab.  That&#8217;s a
blank line, but not an empty line.</p>
</div>
<div class="paragraph">
<p>Vim is able to format more than just plain text.  See |fo-table| for how to
change this.  See the 'joinspaces' option to change the number of spaces used
after a full stop.
   It is possible to use an external program for formatting.  This is useful
if your text can&#8217;t be properly formatted with Vim&#8217;s builtin command.  See the
'formatprg' option.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_aligning_text">Aligning text</h3>
<div class="paragraph">
<p>To center a range of lines, use the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:{range}center [width]</pre>
</div>
</div>
<div class="paragraph">
<p>{range} is the usual command-line range.  [width] is an optional line width to
use for centering.  If [width] is not specified, it defaults to the value of
'textwidth'.  (If 'textwidth' is 0, the default is 80.)
   For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:1,5center 40</pre>
</div>
</div>
<div class="paragraph">
<p>results in the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  I taught for a while. One
  time, I was stopped by the
Fort Worth police, because my
 homework was too hard. True
            story.</pre>
</div>
</div>
<div class="sect3">
<h4 id="_right_alignment">RIGHT ALIGNMENT</h4>
<div class="paragraph">
<p>Similarly, the ":right" command right-justifies the text:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:1,5right 37</pre>
</div>
</div>
<div class="paragraph">
<p>gives this result:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    I taught for a while. One
   time, I was stopped by the
Fort Worth police, because my
  homework was too hard. True
                       story.</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_left_alignment">LEFT ALIGNMENT</h4>
<div class="paragraph">
<p>Finally there is this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:{range}left [margin]</pre>
</div>
</div>
<div class="paragraph">
<p>Unlike ":center" and ":right", however, the argument to ":left" is not the
length of the line.  Instead it is the left margin.  If it is omitted, the
text will be put against the left side of the screen (using a zero margin
would do the same).  If it is 5, the text will be indented 5 spaces.  For
example, use these commands:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:1left 5
:2,5left</pre>
</div>
</div>
<div class="paragraph">
<p>This results in the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>     I taught for a while. One
time, I was stopped by the
Fort Worth police, because my
homework was too hard. True
story.</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_justifying_text">JUSTIFYING TEXT</h4>
<div class="paragraph">
<p>Vim has no built-in way of justifying text.  However, there is a neat macro
package that does the job.  To use this package, execute the following
command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:packadd justify</pre>
</div>
</div>
<div class="paragraph">
<p>Or put this line in your |vimrc|:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>packadd! justify</pre>
</div>
</div>
<div class="paragraph">
<p>This Vim script file defines a new visual command "_j".  To justify a block of
text, highlight the text in Visual mode and then execute "_j".
   Look in the file for more explanations.  To go there, do "gf" on this name:
$VIMRUNTIME/pack/dist/opt/justify/plugin/justify.vim.</p>
</div>
<div class="paragraph">
<p>An alternative is to filter the text through an external program.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:%!fmt</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_indents_and_tabs">Indents and tabs</h3>
<div class="paragraph">
<p>Indents can be used to make text stand out from the rest.  The example texts
in this manual, for example, are indented by eight spaces or a tab.  You would
normally enter this by typing a tab at the start of each line.  Take this
text:
        the first line
        the second line</p>
</div>
<div class="paragraph">
<p>This is entered by typing a tab, some text, &lt;Enter&gt;, tab and more text.
   The 'autoindent' option inserts indents automatically:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set autoindent</pre>
</div>
</div>
<div class="paragraph">
<p>When a new line is started it gets the same indent as the previous line.  In
the above example, the tab after the &lt;Enter&gt; is not needed anymore.</p>
</div>
<div class="sect3">
<h4 id="_increasing_indent">INCREASING INDENT</h4>
<div class="paragraph">
<p>To increase the amount of indent in a line, use the "&gt;" operator.  Often this
is used as "&gt;&gt;", which adds indent to the current line.
   The amount of indent added is specified with the 'shiftwidth' option.  The
default value is 8.  To make "&gt;&gt;" insert four spaces worth of indent, for
example, type this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set shiftwidth=4</pre>
</div>
</div>
<div class="paragraph">
<p>When used on the second line of the example text, this is what you get:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>the first line
    the second line</pre>
</div>
</div>
<div class="paragraph">
<p>"4&gt;&gt;" will increase the indent of four lines.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tabstop">TABSTOP</h4>
<div class="paragraph">
<p>If you want to make indents a multiple of 4, you set 'shiftwidth' to 4.  But
when pressing a &lt;Tab&gt; you still get 8 spaces worth of indent.  To change this,
set the 'softtabstop' option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set softtabstop=4</pre>
</div>
</div>
<div class="paragraph">
<p>This will make the &lt;Tab&gt; key insert 4 spaces worth of indent.  If there are
already four spaces, a &lt;Tab&gt; character is used (saving seven characters in the
file).  (If you always want spaces and no tab characters, set the 'expandtab'
option.)</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
You could set the 'tabstop' option to 4.  However, if you edit the
file another time, with 'tabstop' set to the default value of 8, it
will look wrong.  In other programs and when printing the indent will
also be wrong.  Therefore it is recommended to keep 'tabstop' at eight
all the time.  That's the standard value everywhere.</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_changing_tabs">CHANGING TABS</h4>
<div class="paragraph">
<p>You edit a file which was written with a tabstop of 3.  In Vim it looks ugly,
because it uses the normal tabstop value of 8.  You can fix this by setting
'tabstop' to 3.  But you have to do this every time you edit this file.
   Vim can change the use of tabstops in your file.  First, set 'tabstop' to
make the indents look good, then use the ":retab" command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set tabstop=3
:retab 8</pre>
</div>
</div>
<div class="paragraph">
<p>The ":retab" command will change 'tabstop' to 8, while changing the text such
that it looks the same.  It changes spans of white space into tabs and spaces
for this.  You can now write the file.  Next time you edit it the indents will
be right without setting an option.
   Warning: When using ":retab" on a program, it may change white space inside
a string constant.  Therefore it&#8217;s a good habit to use "\t" instead of a
real tab.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dealing_with_long_lines">Dealing with long lines</h3>
<div class="paragraph">
<p>Sometimes you will be editing a file that is wider than the number of columns
in the window.  When that occurs, Vim wraps the lines so that everything fits
on the screen.
   If you switch the 'wrap' option off, each line in the file shows up as one
line on the screen.  Then the ends of the long lines disappear off the screen
to the right.
   When you move the cursor to a character that can&#8217;t be seen, Vim will scroll
the text to show it.  This is like moving a viewport over the text in the
horizontal direction.
   By default, Vim does not display a horizontal scrollbar in the GUI.  If you
want to enable one, use the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set guioptions+=b</pre>
</div>
</div>
<div class="paragraph">
<p>One horizontal scrollbar will appear at the bottom of the Vim window.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t have a scrollbar or don&#8217;t want to use it, use these commands to
scroll the text.  The cursor will stay in the same place, but it&#8217;s moved back
into the visible text if necessary.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>zh              scroll right
4zh             scroll four characters right
zH              scroll half a window width right
ze              scroll right to put the cursor at the end
zl              scroll left
4zl             scroll four characters left
zL              scroll half a window width left
zs              scroll left to put the cursor at the start</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s attempt to show this with one line of text.  The cursor is on the "w" of
"which".  The "current window" above the line indicates the text that is
currently visible.  The "window"s below the text indicate the text that is
visible after the command left of it.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>                      |&lt;-- current window --&gt;|
        some long text, part of which is visible in the window
ze        |&lt;--     window     --&gt;|
zH         |&lt;--     window     --&gt;|
4zh               |&lt;--     window     --&gt;|
zh                   |&lt;--     window     --&gt;|
zl                     |&lt;--     window     --&gt;|
4zl                       |&lt;--     window     --&gt;|
zL                              |&lt;--     window     --&gt;|
zs                             |&lt;--     window     --&gt;|</pre>
</div>
</div>
<div class="sect3">
<h4 id="_moving_with_wrap_off">MOVING WITH WRAP OFF</h4>
<div class="paragraph">
<p>When 'wrap' is off and the text has scrolled horizontally, you can use the
following commands to move the cursor to a character you can see.  Thus text
left and right of the window is ignored.  These never cause the text to
scroll:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>g0              to first visible character in this line
g^              to first non-blank visible character in this line
gm              to middle of screen line
gM              to middle of the text in this line
g$              to last visible character in this line</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>        |&lt;--      window     --&gt;|
some long    text, part of which is visible in one line
         g0  g^    gm      gM g$</pre>
</div>
</div>
<div class="paragraph">
<p>BREAKING AT WORDS                               <strong>edit-no-break</strong></p>
</div>
<div class="paragraph">
<p>When preparing text for use by another program, you might have to make
paragraphs without a line break.  A disadvantage of using 'nowrap' is that you
can&#8217;t see the whole sentence you are working on.  When 'wrap' is on, words are
broken halfway, which makes them hard to read.
   A good solution for editing this kind of paragraph is setting the
'linebreak' option.  Vim then breaks lines at an appropriate place when
displaying the line.  The text in the file remains unchanged.
   Without 'linebreak' text might look like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        +---------------------------------+
        |letter generation program for a b|
        |ank.  They wanted to send out a s|
        |pecial, personalized letter to th|
        |eir richest 1000 customers.  Unfo|
        |rtunately for the programmer, he |
        +---------------------------------+
After:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>:set linebreak</pre>
</div>
</div>
<div class="paragraph">
<p>it looks like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+---------------------------------+
|letter generation program for a  |
|bank.  They wanted to send out a |
|special, personalized letter to  |
|their richest 1000 customers.    |
|Unfortunately for the programmer,|
+---------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>Related options:
'breakat' specifies the characters where a break can be inserted.
'showbreak' specifies a string to show at the start of broken line.
Set 'textwidth' to zero to avoid a paragraph to be split.</p>
</div>
</div>
<div class="sect3">
<h4 id="_moving_by_visible_lines">MOVING BY VISIBLE LINES</h4>
<div class="paragraph">
<p>The "j" and "k" commands move to the next and previous lines.  When used on
a long line, this means moving a lot of screen lines at once.
   To move only one screen line, use the "gj" and "gk" commands.  When a line
doesn&#8217;t wrap they do the same as "j" and "k".  When the line does wrap, they
move to a character displayed one line below or above.
   You might like to use these mappings, which bind these movement commands to
the cursor keys:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map &lt;Up&gt; gk
:map &lt;Down&gt; gj</pre>
</div>
</div>
<div class="paragraph">
<p>TURNING A PARAGRAPH INTO ONE LINE                       <strong>edit-paragraph-join</strong></p>
</div>
<div class="paragraph">
<p>If you want to import text into a program like MS-Word, each paragraph should
be a single line.  If your paragraphs are currently separated with empty
lines, this is how you turn each paragraph into a single line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:g/./,/^$/join</pre>
</div>
</div>
<div class="paragraph">
<p>That looks complicated.  Let&#8217;s break it up in pieces:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:g/./           A ":global" command that finds all lines that contain
                at least one character.
     ,/^$/      A range, starting from the current line (the non-empty
                line) until an empty line.
          join  The ":join" command joins the range of lines together
                into one line.</pre>
</div>
</div>
<div class="paragraph">
<p>Starting with this text, containing eight lines broken at column 30:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+----------------------------------+
|A letter generation program       |
|for a bank.  They wanted to       |
|send out a special,               |
|personalized letter.              |
|                                  |
|To their richest 1000             |
|customers.  Unfortunately for     |
|the programmer,                   |
+----------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>You end up with two lines:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+----------------------------------+
|A letter generation program for a |
|bank.  They wanted to send out a s|
|pecial, personalized letter.      |
|To their richest 1000 customers.  |
|Unfortunately for the programmer, |
+----------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>Note that this doesn&#8217;t work when the separating line is blank but not empty;
when it contains spaces and/or tabs.  This command does work with blank lines:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:g/\S/,/^\s*$/join</pre>
</div>
</div>
<div class="paragraph">
<p>This still requires a blank or empty line at the end of the file for the last
paragraph to be joined.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_editing_tables">Editing tables</h3>
<div class="paragraph">
<p>Suppose you are editing a table with four columns:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>nice table        test 1        test 2      test 3
input A           0.534
input B           0.913</pre>
</div>
</div>
<div class="paragraph">
<p>You need to enter numbers in the third column.  You could move to the second
line, use "A", enter a lot of spaces and type the text.
   For this kind of editing there is a special option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set virtualedit=all</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can move the cursor to positions where there isn&#8217;t any text.  This is
called "virtual space".  Editing a table is a lot easier this way.
   Move the cursor by searching for the header of the last column:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/test 3</pre>
</div>
</div>
<div class="paragraph">
<p>Now press "j" and you are right where you can enter the value for "input A".
Typing "0.693" results in:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>nice table        test 1     test 2      test 3
input A           0.534                  0.693
input B           0.913</pre>
</div>
</div>
<div class="paragraph">
<p>Vim has automatically filled the gap in front of the new text for you.  Now,
to enter the next field in this column use "Bj".  "B" moves back to the start
of a white space separated word.  Then "j" moves to the place where the next
field can be entered.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
You can move the cursor anywhere in the display, also beyond the end
of a line.  But Vim will not insert spaces there, until you insert a
character in that position.</pre>
</div>
</div>
<div class="sect3">
<h4 id="_copying_a_column">COPYING A COLUMN</h4>
<div class="paragraph">
<p>You want to add a column, which should be a copy of the third column and
placed before the "test 1" column.  Do this in seven steps:
1.  Move the cursor to the left upper corner of this column, e.g., with
    "/test 3".
2.  Press CTRL-V to start blockwise Visual mode.
3.  Move the cursor down two lines with "2j".  You are now in "virtual space":
    the "input B" line of the "test 3" column.
4.  Move the cursor right, to include the whole column in the selection, plus
    the space that you want between the columns.  "9l" should do it.
5.  Yank the selected rectangle with "y".
6.  Move the cursor to "test 1", where the new column must be placed.
7.  Press "P".</p>
</div>
<div class="paragraph">
<p>The result should be:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>nice table        test 3    test 1     test 2      test 3
input A           0.693     0.534                  0.693
input B                     0.913</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the whole "test 1" column was shifted right, also the line where
the "test 3" column didn&#8217;t have text.</p>
</div>
<div class="paragraph">
<p>Go back to non-virtual cursor movements with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set virtualedit=</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_virtual_replace_mode">VIRTUAL REPLACE MODE</h4>
<div class="paragraph">
<p>The disadvantage of using 'virtualedit' is that it "feels" different.  You
can&#8217;t recognize tabs or spaces beyond the end of line when moving the cursor
around.  Another method can be used: Virtual Replace mode.
   Suppose you have a line in a table that contains both tabs and other
characters.  Use "rx" on the first tab:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>inp     0.693   0.534   0.693</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>               |
           rx  |
====                V</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>inpx0.693   0.534       0.693</pre>
</div>
</div>
<div class="paragraph">
<p>The layout is messed up.  To avoid that, use the "gr" command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>inp     0.693   0.534   0.693</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>               |
          grx  |
====                V</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>inpx    0.693   0.534   0.693</pre>
</div>
</div>
<div class="paragraph">
<p>What happens is that the "gr" command makes sure the new character takes the
right amount of screen space.  Extra spaces or tabs are inserted to fill the
gap.  Thus what actually happens is that a tab is replaced by "x" and then
blanks added to make the text after it keep its place.  In this case a
tab is inserted.
   When you need to replace more than one character, you use the "R" command
to go to Replace mode (see |04.9|).  This messes up the layout and replaces
the wrong characters:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>inp     0       0.534   0.693</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>                |
         R0.786 |
====                 V</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>inp     0.78634 0.693</pre>
</div>
</div>
<div class="paragraph">
<p>The "gR" command uses Virtual Replace mode.  This preserves the layout:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>inp     0       0.534   0.693</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>                |
        gR0.786 |
====                 V</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>inp     0.786   0.534   0.693</pre>
</div>
</div>
<div class="paragraph">
<p>Next chapter: |usr_26.txt|  Repeating</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_repeating">Repeating</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An editing task is hardly ever unstructured.  A change often needs to be made
several times.  In this chapter a number of useful ways to repeat a change
will be explained.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Repeating with Visual mode</p>
</li>
<li>
<p>Add and subtract</p>
</li>
<li>
<p>Making a change in many files</p>
</li>
<li>
<p>Using Vim from a shell script</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_repeating_with_visual_mode">Repeating with Visual mode</h3>
<div class="paragraph">
<p>Visual mode is very handy for making a change in any sequence of lines.  You
can see the highlighted text, thus you can check if the correct lines are
changed.  But making the selection takes some typing.  The "gv" command
selects the same area again.  This allows you to do another operation on the
same text.
   Suppose you have some lines where you want to change "2001" to "2002" and
"2000" to "2001":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The financial results for 2001 are better
than for 2000.  The income increased by 50%,
even though 2001 had more rain than 2000.
                2000            2001
income          45,403          66,234</pre>
</div>
</div>
<div class="paragraph">
<p>First change "2001" to "2002".  Select the lines in Visual mode, and use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:s/2001/2002/g</pre>
</div>
</div>
<div class="paragraph">
<p>Now use "gv" to reselect the same text.  It doesn&#8217;t matter where the cursor
is.  Then use ":s/2000/2001/g" to make the second change.
   Obviously, you can repeat these changes several times.</p>
</div>
</div>
<div class="sect2">
<h3 id="_add_and_subtract_2">Add and subtract</h3>
<div class="paragraph">
<p>When repeating the change of one number into another, you often have a fixed
offset.  In the example above, one was added to each year.  Instead of typing
a substitute command for each year that appears, the CTRL-A command can be
used.
   Using the same text as above, search for a year:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/19[0-9][0-9]\|20[0-9][0-9]</pre>
</div>
</div>
<div class="paragraph">
<p>Now press CTRL-A.  The year will be increased by one:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The financial results for 2002 are better
than for 2000.  The income increased by 50%,
even though 2001 had more rain than 2000.
                2000            2001
income          45,403          66,234</pre>
</div>
</div>
<div class="paragraph">
<p>Use "n" to find the next year, and press "." to repeat the CTRL-A ("." is a
bit quicker to type).  Repeat "n" and "." for all years that appear.
   Hint: set the 'hlsearch' option to see the matches you are going to change,
then you can look ahead and do it faster.</p>
</div>
<div class="paragraph">
<p>Adding more than one can be done by prepending the number to CTRL-A.  Suppose
you have this list:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>item four</p>
</li>
<li>
<p>item five</p>
</li>
<li>
<p>item six</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Move the cursor to "1." and type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>3 CTRL-A</pre>
</div>
</div>
<div class="paragraph">
<p>The "1." will change to "4.".  Again, you can use "." to repeat this on the
other numbers.</p>
</div>
<div class="paragraph">
<p>Another example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>006     foo bar
007     foo bar</pre>
</div>
</div>
<div class="paragraph">
<p>Using CTRL-A on these numbers results in:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>007     foo bar
010     foo bar</pre>
</div>
</div>
<div class="paragraph">
<p>7 plus one is 10?  What happened here is that Vim recognized "007" as an octal
number, because there is a leading zero.  This notation is often used in C
programs.  If you do not want a number with leading zeros to be handled as
octal, use this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set nrformats-=octal</pre>
</div>
</div>
<div class="paragraph">
<p>The CTRL-X command does subtraction in a similar way.</p>
</div>
</div>
<div class="sect2">
<h3 id="_making_a_change_in_many_files">Making a change in many files</h3>
<div class="paragraph">
<p>Suppose you have a variable called "x_cnt" and you want to change it to
"x_counter".  This variable is used in several of your C files.  You need to
change it in all files.  This is how you do it.
   Put all the relevant files in the argument list:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:args *.c</pre>
</div>
</div>
<div class="paragraph">
<p>This finds all C files and edits the first one.  Now you can perform a
substitution command on all these files:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:argdo %s/\&lt;x_cnt\&gt;/x_counter/ge | update</pre>
</div>
</div>
<div class="paragraph">
<p>The ":argdo" command takes an argument that is another command.  That command
will be executed on all files in the argument list.
   The "%s" substitute command that follows works on all lines.  It finds the
word "x_cnt" with "\&lt;x_cnt\&gt;".  The "\&lt;" and "\&gt;" are used to match the whole
word only, and not "px_cnt" or "x_cnt2".
   The flags for the substitute command include "g" to replace all occurrences
of "x_cnt" in the same line.  The "e" flag is used to avoid an error message
when "x_cnt" does not appear in the file.  Otherwise ":argdo" would abort on
the first file where "x_cnt" was not found.
   The "|" separates two commands.  The following "update" command writes the
file only if it was changed.  If no "x_cnt" was changed to "x_counter" nothing
happens.</p>
</div>
<div class="paragraph">
<p>There is also the ":windo" command, which executes its argument in all
windows.  And ":bufdo" executes its argument on all buffers.  Be careful with
this, because you might have more files in the buffer list than you think.
Check this with the ":buffers" command (or ":ls").</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_vim_from_a_shell_script">Using Vim from a shell script</h3>
<div class="paragraph">
<p>Suppose you have a lot of files in which you need to change the string
"-person-" to "Jones" and then print it.  How do you do that?  One way is to
do a lot of typing.  The other is to write a shell script to do the work.
   The Vim editor does a superb job as a screen-oriented editor when using
Normal mode commands.  For batch processing, however, Normal mode commands do
not result in clear, commented command files; so here you will use Ex mode
instead.  This mode gives you a nice command-line interface that makes it easy
to put into a batch file.  ("Ex command" is just another name for a
command-line (:) command.)
   The Ex mode commands you need are as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>%s/-person-/Jones/g
write tempfile
quit</pre>
</div>
</div>
<div class="paragraph">
<p>You put these commands in the file "change.vim".  Now to run the editor in
batch mode, use this shell script:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>for file in *.txt; do
  vim -e -s $file &lt; change.vim
  lpr -r tempfile
done</pre>
</div>
</div>
<div class="paragraph">
<p>The for-done loop is a shell construct to repeat the two lines in between,
while the $file variable is set to a different file name each time.
   The second line runs the Vim editor in Ex mode (-e argument) on the file
$file and reads commands from the file "change.vim".  The -s argument tells
Vim to operate in silent mode.  In other words, do not keep outputting the
:prompt, or any other prompt for that matter.
   The "lpr -r tempfile" command prints the resulting "tempfile" and deletes
it (that&#8217;s what the -r argument does).</p>
</div>
<div class="sect3">
<h4 id="_reading_from_stdin">READING FROM STDIN</h4>
<div class="paragraph">
<p>Vim can read text on standard input.  Since the normal way is to read commands
there, you must tell Vim to read text instead.  This is done by passing the
"-" argument in place of a file.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ls | vim -</pre>
</div>
</div>
<div class="paragraph">
<p>This allows you to edit the output of the "ls" command, without first saving
the text in a file.
   If you use the standard input to read text from, you can use the "-S"
argument to read a script:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>producer | vim -S change.vim -</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_normal_mode_scripts">NORMAL MODE SCRIPTS</h4>
<div class="paragraph">
<p>If you really want to use Normal mode commands in a script, you can use it
like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim -s script file.txt ...</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
"-s" has a different meaning when it is used without "-e".  Here it
means to source the "script" as Normal mode commands.  When used with
"-e" it means to be silent, and doesn't use the next argument as a
file name.</pre>
</div>
</div>
<div class="paragraph">
<p>The commands in "script" are executed like you typed them.  Don&#8217;t forget that
a line break is interpreted as pressing &lt;Enter&gt;.  In Normal mode that moves
the cursor to the next line.
   To create the script you can edit the script file and type the commands.
You need to imagine what the result would be, which can be a bit difficult.
Another way is to record the commands while you perform them manually.  This
is how you do that:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim -w script file.txt ...</pre>
</div>
</div>
<div class="paragraph">
<p>All typed keys will be written to "script".  If you make a small mistake you
can just continue and remember to edit the script later.
   The "-w" argument appends to an existing script.  That is good when you
want to record the script bit by bit.  If you want to start from scratch and
start all over, use the "-W" argument.  It overwrites any existing file.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_27.txt|  Search commands and patterns</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_search_commands_and_patterns">Search commands and patterns</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In chapter 3 a few simple search patterns were mentioned |03.9|.  Vim can do
much more complex searches.  This chapter explains the most often used ones.
A detailed specification can be found here: |pattern|</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ignoring case</p>
</li>
<li>
<p>Wrapping around the file end</p>
</li>
<li>
<p>Offsets</p>
</li>
<li>
<p>Matching multiple times</p>
</li>
<li>
<p>Alternatives</p>
</li>
<li>
<p>Character ranges</p>
</li>
<li>
<p>Character classes</p>
</li>
<li>
<p>Matching a line break</p>
</li>
<li>
<p>Examples</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_ignoring_case_2">Ignoring case</h3>
<div class="paragraph">
<p>By default, Vim&#8217;s searches are case sensitive.  Therefore, "include",
"INCLUDE", and "Include" are three different words and a search will match
only one of them.
   Now switch on the 'ignorecase' option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set ignorecase</pre>
</div>
</div>
<div class="paragraph">
<p>Search for "include" again, and now it will match "Include", "INCLUDE" and
"InClUDe".  (Set the 'hlsearch' option to quickly see where a pattern
matches.)
   You can switch this off again with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set noignorecase</pre>
</div>
</div>
<div class="paragraph">
<p>But let&#8217;s keep it set, and search for "INCLUDE".  It will match exactly the
same text as "include" did.  Now set the 'smartcase' option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set ignorecase smartcase</pre>
</div>
</div>
<div class="paragraph">
<p>If you have a pattern with at least one uppercase character, the search
becomes case sensitive.  The idea is that you didn&#8217;t have to type that
uppercase character, so you must have done it because you wanted case to
match.  That&#8217;s smart!
    With these two options set you find the following matches:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        pattern                 matches
        word                    word, Word, WORD, WoRd, etc.
        Word                    Word
====         WORD                    WORD
        WoRd                    WoRd</pre>
</div>
</div>
<div class="sect3">
<h4 id="_case_in_one_pattern">CASE IN ONE PATTERN</h4>
<div class="paragraph">
<p>If you want to ignore case for one specific pattern, you can do this by
prepending the "\c" string.  Using "\C" will make the pattern to match case.
This overrules the 'ignorecase' and 'smartcase' options, when "\c" or "\C" is
used their value doesn&#8217;t matter.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>pattern                 matches
\Cword                  word
\CWord                  Word
\cword                  word, Word, WORD, WoRd, etc.
\cWord                  word, Word, WORD, WoRd, etc.</pre>
</div>
</div>
<div class="paragraph">
<p>A big advantage of using "\c" and "\C" is that it sticks with the pattern.
Thus if you repeat a pattern from the search history, the same will happen, no
matter if 'ignorecase' or 'smartcase' was changed.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
The use of "\" items in search patterns depends on the 'magic' option.
In this chapter we will assume 'magic' is on, because that is the
standard and recommended setting.  If you would change 'magic', many
search patterns would suddenly become invalid.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
If your search takes much longer than you expected, you can interrupt
it with CTRL-C on Unix and CTRL-Break on MS-Windows.</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_wrapping_around_the_file_end">Wrapping around the file end</h3>
<div class="paragraph">
<p>By default, a forward search starts searching for the given string at the
current cursor location.  It then proceeds to the end of the file.  If it has
not found the string by that time, it starts from the beginning and searches
from the start of the file to the cursor location.
   Keep in mind that when repeating the "n" command to search for the next
match, you eventually get back to the first match.  If you don&#8217;t notice this
you keep searching forever!  To give you a hint, Vim displays this message:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>search hit BOTTOM, continuing at TOP</pre>
</div>
</div>
<div class="paragraph">
<p>If you use the "?" command, to search in the other direction, you get this
message:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>search hit TOP, continuing at BOTTOM</pre>
</div>
</div>
<div class="paragraph">
<p>Still, you don&#8217;t know when you are back at the first match.  One way to see
this is by switching on the 'ruler' option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set ruler</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will display the cursor position in the lower righthand corner of the
window (in the status line if there is one).  It looks like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>101,29       84%</pre>
</div>
</div>
<div class="paragraph">
<p>The first number is the line number of the cursor.  Remember the line number
where you started, so that you can check if you passed this position again.</p>
</div>
<div class="sect3">
<h4 id="_not_wrapping">NOT WRAPPING</h4>
<div class="paragraph">
<p>To turn off search wrapping, use the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set nowrapscan</pre>
</div>
</div>
<div class="paragraph">
<p>Now when the search hits the end of the file, an error message displays:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E385: search hit BOTTOM without match for: forever</pre>
</div>
</div>
<div class="paragraph">
<p>Thus you can find all matches by going to the start of the file with "gg" and
keep searching until you see this message.
   If you search in the other direction, using "?", you get:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E384: search hit TOP without match for: forever</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_offsets">Offsets</h3>
<div class="paragraph">
<p>By default, the search command leaves the cursor positioned on the beginning
of the pattern.  You can tell Vim to leave it some other place by specifying
an offset.  For the forward search command "/", the offset is specified by
appending a slash (/) and the offset:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/default/2</pre>
</div>
</div>
<div class="paragraph">
<p>This command searches for the pattern "default" and then moves to the
beginning of the second line past the pattern.  Using this command on the
paragraph above, Vim finds the word "default" in the first line.  Then the
cursor is moved two lines down and lands on "an offset".</p>
</div>
<div class="paragraph">
<p>If the offset is a simple number, the cursor will be placed at the beginning
of the line that many lines from the match.  The offset number can be positive
or negative.  If it is positive, the cursor moves down that many lines; if
negative, it moves up.</p>
</div>
<div class="sect3">
<h4 id="_character_offsets">CHARACTER OFFSETS</h4>
<div class="paragraph">
<p>The "e" offset indicates an offset from the end of the match.  It moves the
cursor onto the last character of the match.  The command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/const/e</pre>
</div>
</div>
<div class="paragraph">
<p>puts the cursor on the "t" of "const".
   From that position, adding a number moves forward that many characters.
This command moves to the character just after the match:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/const/e+1</pre>
</div>
</div>
<div class="paragraph">
<p>A positive number moves the cursor to the right, a negative number moves it to
the left.  For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/const/e-1</pre>
</div>
</div>
<div class="paragraph">
<p>moves the cursor to the "s" of "const".</p>
</div>
<div class="paragraph">
<p>If the offset begins with "b", the cursor moves to the beginning of the
pattern.  That&#8217;s not very useful, since leaving out the "b" does the same
thing.  It does get useful when a number is added or subtracted.  The cursor
then goes forward or backward that many characters.  For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/const/b+2</pre>
</div>
</div>
<div class="paragraph">
<p>Moves the cursor to the beginning of the match and then two characters to the
right.  Thus it lands on the "n".</p>
</div>
</div>
<div class="sect3">
<h4 id="_repeating_2">REPEATING</h4>
<div class="paragraph">
<p>To repeat searching for the previously used search pattern, but with a
different offset, leave out the pattern:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/that
//e</pre>
</div>
</div>
<div class="paragraph">
<p>Is equal to:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/that/e</pre>
</div>
</div>
<div class="paragraph">
<p>To repeat with the same offset:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/</pre>
</div>
</div>
<div class="paragraph">
<p>"n" does the same thing.  To repeat while removing a previously used offset:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>//</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_searching_backwards">SEARCHING BACKWARDS</h4>
<div class="paragraph">
<p>The "?" command uses offsets in the same way, but you must use "?" to separate
the offset from the pattern, instead of "/":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>?const?e-2</pre>
</div>
</div>
<div class="paragraph">
<p>The "b" and "e" keep their meaning, they don&#8217;t change direction with the use
of "?".</p>
</div>
</div>
<div class="sect3">
<h4 id="_start_position">START POSITION</h4>
<div class="paragraph">
<p>When starting a search, it normally starts at the cursor position.  When you
specify a line offset, this can cause trouble.  For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/const/-2</pre>
</div>
</div>
<div class="paragraph">
<p>This finds the next word "const" and then moves two lines up.  If you
use "n" to search again, Vim could start at the current position and find the
same "const" match.  Then using the offset again, you would be back where you
started.  You would be stuck!
   It could be worse: Suppose there is another match with "const" in the next
line.  Then repeating the forward search would find this match and move two
lines up.  Thus you would actually move the cursor back!</p>
</div>
<div class="paragraph">
<p>When you specify a character offset, Vim will compensate for this.  Thus the
search starts a few characters forward or backward, so that the same match
isn&#8217;t found again.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_matching_multiple_times">Matching multiple times</h3>
<div class="paragraph">
<p>The "*" item specifies that the item before it can match any number of times.
Thus:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/a*</pre>
</div>
</div>
<div class="paragraph">
<p>matches "a", "aa", "aaa", etc.  But also "" (the empty string), because zero
times is included.
   The "<strong>" only applies to the item directly before it.  Thus "ab</strong>" matches
"a", "ab", "abb", "abbb", etc.  To match a whole string multiple times, it
must be grouped into one item.  This is done by putting "\(" before it and
"\)" after it.  Thus this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/\(ab\)*</pre>
</div>
</div>
<div class="paragraph">
<p>Matches: "ab", "abab", "ababab", etc.  And also "".</p>
</div>
<div class="paragraph">
<p>To avoid matching the empty string, use "\+".  This makes the previous item
match one or more times. &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/ab\+</pre>
</div>
</div>
<div class="paragraph">
<p>Matches "ab", "abb", "abbb", etc.  It does not match "a" when no "b" follows.</p>
</div>
<div class="paragraph">
<p>To match an optional item, use "\=".  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/folders\=</pre>
</div>
</div>
<div class="paragraph">
<p>Matches "folder" and "folders".</p>
</div>
<div class="sect3">
<h4 id="_specific_counts">SPECIFIC COUNTS</h4>
<div class="paragraph">
<p>To match a specific number of items use the form "\{n,m}".  "n" and "m" are
numbers.  The item before it will be matched "n" to "m" times |inclusive|.
Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/ab\{3,5}</pre>
</div>
</div>
<div class="paragraph">
<p>matches "abbb", "abbbb" and "abbbbb".
  When "n" is omitted, it defaults to zero.  When "m" is omitted it defaults
to infinity.  When ",m" is omitted, it matches exactly "n" times.
Examples:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>pattern         match count
\{,4}           0, 1, 2, 3 or 4
\{3,}           3, 4, 5, etc.
\{0,1}          0 or 1, same as \=
\{0,}           0 or more, same as *
\{1,}           1 or more, same as \+
\{3}            3</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_matching_as_little_as_possible">MATCHING AS LITTLE AS POSSIBLE</h4>
<div class="paragraph">
<p>The items so far match as many characters as they can find.  To match as few
as possible, use "\{-n,m}".  It works the same as "\{n,m}", except that the
minimal amount possible is used.
   For example, use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/ab\{-1,3}</pre>
</div>
</div>
<div class="paragraph">
<p>Will match "ab" in "abbb".  Actually, it will never match more than one b,
because there is no reason to match more.  It requires something else to force
it to match more than the lower limit.
   The same rules apply to removing "n" and "m".  It&#8217;s even possible to remove
both of the numbers, resulting in "\{-}".  This matches the item before it
zero or more times, as few as possible.  The item by itself always matches
zero times.  It is useful when combined with something else.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/a.\{-}b</pre>
</div>
</div>
<div class="paragraph">
<p>This matches "axb" in "axbxb".  If this pattern would be used:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/a.*b</pre>
</div>
</div>
<div class="paragraph">
<p>It would try to match as many characters as possible with ".*", thus it
matches "axbxb" as a whole.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_alternatives">Alternatives</h3>
<div class="paragraph">
<p>The "or" operator in a pattern is "\|".  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/foo\|bar</pre>
</div>
</div>
<div class="paragraph">
<p>This matches "foo" or "bar".  More alternatives can be concatenated:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/one\|two\|three</pre>
</div>
</div>
<div class="paragraph">
<p>Matches "one", "two" and "three".
   To match multiple times, the whole thing must be placed in "\(" and "\)":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/\(foo\|bar\)\+</pre>
</div>
</div>
<div class="paragraph">
<p>This matches "foo", "foobar", "foofoo", "barfoobar", etc.
   Another example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/end\(if\|while\|for\)</pre>
</div>
</div>
<div class="paragraph">
<p>This matches "endif", "endwhile" and "endfor".</p>
</div>
<div class="paragraph">
<p>A related item is "\&amp;".  This requires that both alternatives match in the
same place.  The resulting match uses the last alternative.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/forever\&amp;...</pre>
</div>
</div>
<div class="paragraph">
<p>This matches "for" in "forever".  It will not match "fortuin", for example.</p>
</div>
</div>
<div class="sect2">
<h3 id="_character_ranges">Character ranges</h3>
<div class="paragraph">
<p>To match "a", "b" or "c" you could use "/a\|b\|c".  When you want to match all
letters from "a" to "z" this gets very long.  There is a shorter method:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/[a-z]</pre>
</div>
</div>
<div class="paragraph">
<p>The [] construct matches a single character.  Inside you specify which
characters to match.  You can include a list of characters, like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/[0123456789abcdef]</pre>
</div>
</div>
<div class="paragraph">
<p>This will match any of the characters included.  For consecutive characters
you can specify the range.  "0-3" stands for "0123".  "w-z" stands for "wxyz".
Thus the same command as above can be shortened to:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/[0-9a-f]</pre>
</div>
</div>
<div class="paragraph">
<p>To match the "-" character itself make it the first or last one in the range.
These special characters are accepted to make it easier to use them inside a
[] range (they can actually be used anywhere in the search pattern):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>\e      &lt;Esc&gt;
\t      &lt;Tab&gt;
\r      &lt;CR&gt;
\b      &lt;BS&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>There are a few more special cases for [] ranges, see |/[]| for the whole
story.</p>
</div>
<div class="sect3">
<h4 id="_complemented_range">COMPLEMENTED RANGE</h4>
<div class="paragraph">
<p>To avoid matching a specific character, use "^" at the start of the range.
The [] item then matches everything but the characters included.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/"[^"]*"</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>"        a double quote
 [^"]    any character that is not a double quote
     *   as many as possible
      "  a double quote again</pre>
</div>
</div>
<div class="paragraph">
<p>This matches "foo" and "3!x", including the double quotes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_predefined_ranges">PREDEFINED RANGES</h4>
<div class="paragraph">
<p>A number of ranges are used very often.  Vim provides a shortcut for these.
For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/\a</pre>
</div>
</div>
<div class="paragraph">
<p>Finds alphabetic characters.  This is equal to using "/[a-zA-Z]".  Here are a
few more of these:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>item    matches                 equivalent
\d      digit                   [0-9]
\D      non-digit               [^0-9]
\x      hex digit               [0-9a-fA-F]
\X      non-hex digit           [^0-9a-fA-F]
\s      white space             [       ]     (&lt;Tab&gt; and &lt;Space&gt;)
\S      non-white characters    [^      ]     (not &lt;Tab&gt; and &lt;Space&gt;)
\l      lowercase alpha         [a-z]
\L      non-lowercase alpha     [^a-z]
\u      uppercase alpha         [A-Z]
\U      non-uppercase alpha     [^A-Z]</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
Using these predefined ranges works a lot faster than the character
range it stands for.
These items can not be used inside [].  Thus "[\d\l]" does NOT work to
match a digit or lowercase alpha.  Use "\(\d\|\l\)" instead.</pre>
</div>
</div>
<div class="paragraph">
<p>See |/\s| for the whole list of these ranges.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_character_classes">Character classes</h3>
<div class="paragraph">
<p>The character range matches a fixed set of characters.  A character class is
similar, but with an essential difference: The set of characters can be
redefined without changing the search pattern.
   For example, search for this pattern:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/\f\+</pre>
</div>
</div>
<div class="paragraph">
<p>The "\f" items stands for file name characters.  Thus this matches a sequence
of characters that can be a file name.
   Which characters can be part of a file name depends on the system you are
using.  On MS-Windows, the backslash is included, on Unix it is not.  This is
specified with the 'isfname' option.  The default value for Unix is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set isfname
isfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=</pre>
</div>
</div>
<div class="paragraph">
<p>For other systems the default value is different.  Thus you can make a search
pattern with "\f" to match a file name, and it will automatically adjust to
the system you are using it on.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
Actually, Unix allows using just about any character in a file name,
including white space.  Including these characters in 'isfname' would
be theoretically correct.  But it would make it impossible to find the
end of a file name in text.  Thus the default value of 'isfname' is a
compromise.</pre>
</div>
</div>
<div class="paragraph">
<p>The character classes are:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>item    matches                         option
\i      identifier characters           'isident'
\I      like \i, excluding digits
\k      keyword characters              'iskeyword'
\K      like \k, excluding digits
\p      printable characters            'isprint'
\P      like \p, excluding digits
\f      file name characters            'isfname'
\F      like \f, excluding digits</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_matching_a_line_break">Matching a line break</h3>
<div class="paragraph">
<p>Vim can find a pattern that includes a line break.  You need to specify where
the line break happens, because all items mentioned so far don&#8217;t match a line
break.
   To check for a line break in a specific place, use the "\n" item:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/one\ntwo</pre>
</div>
</div>
<div class="paragraph">
<p>This will match at a line that ends in "one" and the next line starts with
"two".  To match "one two" as well, you need to match a space or a line
break.  The item to use for it is "\_s":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/one\_stwo</pre>
</div>
</div>
<div class="paragraph">
<p>To allow any amount of white space:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/one\_s\+two</pre>
</div>
</div>
<div class="paragraph">
<p>This also matches when "one  " is at the end of a line and "   two" at the
start of the next one.</p>
</div>
<div class="paragraph">
<p>"\s" matches white space, "_s" matches white space or a line break.
Similarly, "\a" matches an alphabetic character, and "\_a" matches an
alphabetic character or a line break.  The other character classes and ranges
can be modified in the same way by inserting a "_".</p>
</div>
<div class="paragraph">
<p>Many other items can be made to match a line break by prepending "_".  For
example: "\_." matches any character or a line break.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
"\_.*" matches everything until the end of the file.  Be careful with
this, it can make a search command very slow.</pre>
</div>
</div>
<div class="paragraph">
<p>Another example is "\_[]", a character range that includes a line break:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/"\_[^"]*"</pre>
</div>
</div>
<div class="paragraph">
<p>This finds a text in double quotes that may be split up in several lines.</p>
</div>
</div>
<div class="sect2">
<h3 id="_examples">Examples</h3>
<div class="paragraph">
<p>Here are a few search patterns you might find useful.  This shows how the
items mentioned above can be combined.</p>
</div>
<div class="sect3">
<h4 id="_finding_a_california_license_plate">FINDING A CALIFORNIA LICENSE PLATE</h4>
<div class="paragraph">
<p>A sample license plate number is "1MGU103".  It has one digit, three uppercase
letters and three digits.  Directly putting this into a search pattern:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/\d\u\u\u\d\d\d</pre>
</div>
</div>
<div class="paragraph">
<p>Another way is to specify that there are three digits and letters with a
count:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/\d\u\{3}\d\{3}</pre>
</div>
</div>
<div class="paragraph">
<p>Using [] ranges instead:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/[0-9][A-Z]\{3}[0-9]\{3}</pre>
</div>
</div>
<div class="paragraph">
<p>Which one of these you should use?  Whichever one you can remember.  The
simple way you can remember is much faster than the fancy way that you can&#8217;t.
If you can remember them all, then avoid the last one, because it&#8217;s both more
typing and slower to execute.</p>
</div>
</div>
<div class="sect3">
<h4 id="_finding_an_identifier">FINDING AN IDENTIFIER</h4>
<div class="paragraph">
<p>In C programs (and many other computer languages) an identifier starts with a
letter and further consists of letters and digits.  Underscores can be used
too.  This can be found with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/\&lt;\h\w*\&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>"\&lt;" and "\&gt;" are used to find only whole words.  "\h" stands for "[A-Za-z_]"
and "\w" for "[0-9A-Za-z_]".</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
"\&lt;" and "\&gt;" depend on the 'iskeyword' option.  If it includes "-",
for example, then "ident-" is not matched.  In this situation use:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>/\w\@&lt;!\h\w*\w\@!</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>This checks if "\w" does not match before or after the identifier.
See |/\@&lt;!| and |/\@!|.</pre>
</div>
</div>
<div class="paragraph">
<p>Next chapter: |usr_28.txt|  Folding</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_folding">Folding</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Structured text can be separated in sections.  And sections in sub-sections.
Folding allows you to display a section as one line, providing an overview.
This chapter explains the different ways this can be done.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>What is folding?</p>
</li>
<li>
<p>Manual folding</p>
</li>
<li>
<p>Working with folds</p>
</li>
<li>
<p>Saving and restoring folds</p>
</li>
<li>
<p>Folding by indent</p>
</li>
<li>
<p>Folding with markers</p>
</li>
<li>
<p>Folding by syntax</p>
</li>
<li>
<p>Folding by expression</p>
</li>
<li>
<p>Folding unchanged lines</p>
</li>
<li>
<p>Which fold method to use?</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_what_is_folding">What is folding?</h3>
<div class="paragraph">
<p>Folding is used to show a range of lines in the buffer as a single line on the
screen.  Like a piece of paper which is folded to make it shorter:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+------------------------+
| line 1                 |
| line 2                 |
| line 3                 |
|_______________________ |
\                        \
 \________________________\
 / folded lines           /
/________________________/
| line 12                |
| line 13                |
| line 14                |
+------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>The text is still in the buffer, unchanged.  Only the way lines are displayed
is affected by folding.</p>
</div>
<div class="paragraph">
<p>The advantage of folding is that you can get a better overview of the
structure of text, by folding lines of a section and replacing it with a line
that indicates that there is a section.</p>
</div>
</div>
<div class="sect2">
<h3 id="_manual_folding">Manual folding</h3>
<div class="paragraph">
<p>Try it out: Position the cursor in a paragraph and type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>zfap</pre>
</div>
</div>
<div class="paragraph">
<p>You will see that the paragraph is replaced by a highlighted line.  You have
created a fold.  |zf| is an operator and |ap| a text object selection.  You
can use the |zf| operator with any movement command to create a fold for the
text that it moved over.  |zf| also works in Visual mode.</p>
</div>
<div class="paragraph">
<p>To view the text again, open the fold by typing:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>zo</pre>
</div>
</div>
<div class="paragraph">
<p>And you can close the fold again with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>zc</pre>
</div>
</div>
<div class="paragraph">
<p>All the folding commands start with "z".  With some fantasy, this looks like a
folded piece of paper, seen from the side.  The letter after the "z" has a
mnemonic meaning to make it easier to remember the commands:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>zf      F-old creation
zo      O-pen a fold
zc      C-lose a fold</pre>
</div>
</div>
<div class="paragraph">
<p>Folds can be nested: A region of text that contains folds can be folded
again.  For example, you can fold each paragraph in this section, and then
fold all the sections in this chapter.  Try it out.  You will notice that
opening the fold for the whole chapter will restore the nested folds as they
were, some may be open and some may be closed.</p>
</div>
<div class="paragraph">
<p>Suppose you have created several folds, and now want to view all the text.
You could go to each fold and type "zo".  To do this faster, use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>zr</pre>
</div>
</div>
<div class="paragraph">
<p>This will R-educe the folding.  The opposite is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>zm</pre>
</div>
</div>
<div class="paragraph">
<p>This folds M-ore.  You can repeat "zr" and "zm" to open and close nested folds
of several levels.</p>
</div>
<div class="paragraph">
<p>If you have nested several levels deep, you can open all of them with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>zR</pre>
</div>
</div>
<div class="paragraph">
<p>This R-educes folds until there are none left.  And you can close all folds
with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>zM</pre>
</div>
</div>
<div class="paragraph">
<p>This folds M-ore and M-ore.</p>
</div>
<div class="paragraph">
<p>You can quickly disable the folding with the |zn| command.  Then |zN| brings
back the folding as it was.  |zi| toggles between the two.  This is a useful
way of working:
- create folds to get overview on your file
- move around to where you want to do your work
- do |zi| to look at the text and edit it
- do |zi| again to go back to moving around</p>
</div>
<div class="paragraph">
<p>More about manual folding in the reference manual: |fold-manual|</p>
</div>
</div>
<div class="sect2">
<h3 id="_working_with_folds">Working with folds</h3>
<div class="paragraph">
<p>When some folds are closed, movement commands like "j" and "k" move over a
fold like it was a single, empty line.  This allows you to quickly move around
over folded text.</p>
</div>
<div class="paragraph">
<p>You can yank, delete and put folds as if it was a single line.  This is very
useful if you want to reorder functions in a program.  First make sure that
each fold contains a whole function (or a bit less) by selecting the right
'foldmethod'.  Then delete the function with "dd", move the cursor and put it
with "p".  If some lines of the function are above or below the fold, you can
use Visual selection:
- put the cursor on the first line to be moved
- hit "V" to start Visual mode
- put the cursor on the last line to be moved
- hit "d" to delete the selected lines.
- move the cursor to the new position and "p"ut the lines there.</p>
</div>
<div class="paragraph">
<p>It is sometimes difficult to see or remember where a fold is located, thus
where a |zo| command would actually work.  To see the defined folds:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set foldcolumn=4</pre>
</div>
</div>
<div class="paragraph">
<p>This will show a small column on the left of the window to indicate folds.
A "+" is shown for a closed fold.  A "-" is shown at the start of each open
fold and "|" at following lines of the fold.</p>
</div>
<div class="paragraph">
<p>You can use the mouse to open a fold by clicking on the "+" in the foldcolumn.
Clicking on the "-" or a "|" below it will close an open fold.</p>
</div>
<div class="paragraph">
<p>To open all folds at the cursor line use |zO|.
To close all folds at the cursor line use |zC|.
To delete a fold at the cursor line use |zd|.
To delete all folds at the cursor line use |zD|.</p>
</div>
<div class="paragraph">
<p>When in Insert mode, the fold at the cursor line is never closed.  That allows
you to see what you type!</p>
</div>
<div class="paragraph">
<p>Folds are opened automatically when jumping around or moving the cursor left
or right.  For example, the "0" command opens the fold under the cursor
(if 'foldopen' contains "hor", which is the default).  The 'foldopen' option
can be changed to open folds for specific commands.  If you want the line
under the cursor always to be open, do this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set foldopen=all</pre>
</div>
</div>
<div class="paragraph">
<p>Warning: You won&#8217;t be able to move onto a closed fold then.  You might want to
use this only temporarily and then set it back to the default:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set foldopen&amp;</pre>
</div>
</div>
<div class="paragraph">
<p>You can make folds close automatically when you move out of it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set foldclose=all</pre>
</div>
</div>
<div class="paragraph">
<p>This will re-apply 'foldlevel' to all folds that don&#8217;t contain the cursor.
You have to try it out if you like how this feels.  Use |zm| to fold more and
|zr| to fold less (reduce folds).</p>
</div>
<div class="paragraph">
<p>The folding is local to the window.  This allows you to open two windows on
the same buffer, one with folds and one without folds.  Or one with all folds
closed and one with all folds open.</p>
</div>
</div>
<div class="sect2">
<h3 id="_saving_and_restoring_folds">Saving and restoring folds</h3>
<div class="paragraph">
<p>When you abandon a file (starting to edit another one), the state of the folds
is lost.  If you come back to the same file later, all manually opened and
closed folds are back to their default.  When folds have been created
manually, all folds are gone!  To save the folds use the |:mkview| command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:mkview</pre>
</div>
</div>
<div class="paragraph">
<p>This will store the settings and other things that influence the view on the
file.  You can change what is stored with the 'viewoptions' option.
When you come back to the same file later, you can load the view again:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:loadview</pre>
</div>
</div>
<div class="paragraph">
<p>You can store up to ten views on one file.  For example, to save the current
setup as the third view and load the second view:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:mkview 3
:loadview 2</pre>
</div>
</div>
<div class="paragraph">
<p>Note that when you insert or delete lines the views might become invalid.
Also check out the 'viewdir' option, which specifies where the views are
stored.  You might want to delete old views now and then.</p>
</div>
</div>
<div class="sect2">
<h3 id="_folding_by_indent">Folding by indent</h3>
<div class="paragraph">
<p>Defining folds with |zf| is a lot of work.  If your text is structured by
giving lower level items a larger indent, you can use the indent folding
method.  This will create folds for every sequence of lines with the same
indent.  Lines with a larger indent will become nested folds.  This works well
with many programming languages.</p>
</div>
<div class="paragraph">
<p>Try this by setting the 'foldmethod' option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set foldmethod=indent</pre>
</div>
</div>
<div class="paragraph">
<p>Then you can use the |zm| and |zr| commands to fold more and reduce folding.
It&#8217;s easy to see on this example text:</p>
</div>
<div class="paragraph">
<p>This line is not indented
        This line is indented once
                This line is indented twice
                This line is indented twice
        This line is indented once
This line is not indented
        This line is indented once
        This line is indented once</p>
</div>
<div class="paragraph">
<p>Note that the relation between the amount of indent and the fold depth depends
on the 'shiftwidth' option.  Each 'shiftwidth' worth of indent adds one to the
depth of the fold.  This is called a fold level.</p>
</div>
<div class="paragraph">
<p>When you use the |zr| and |zm| commands you actually increase or decrease the
'foldlevel' option.  You could also set it directly:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set foldlevel=3</pre>
</div>
</div>
<div class="paragraph">
<p>This means that all folds with three times a 'shiftwidth' indent or more will
be closed.  The lower the foldlevel, the more folds will be closed.  When
'foldlevel' is zero, all folds are closed.  |zM| does set 'foldlevel' to zero.
The opposite command |zR| sets 'foldlevel' to the deepest fold level that is
present in the file.</p>
</div>
<div class="paragraph">
<p>Thus there are two ways to open and close the folds:
(A) By setting the fold level.
    This gives a very quick way of "zooming out" to view the structure of the
    text, move the cursor, and "zoom in" on the text again.</p>
</div>
<div class="paragraph">
<p>(B) By using |zo| and |zc| commands to open or close specific folds.
    This allows opening only those folds that you want to be open, while other
    folds remain closed.</p>
</div>
<div class="paragraph">
<p>This can be combined: You can first close most folds by using |zm| a few times
and then open a specific fold with |zo|.  Or open all folds with |zR| and
then close specific folds with |zc|.</p>
</div>
<div class="paragraph">
<p>But you cannot manually define folds when 'foldmethod' is "indent", as that
would conflict with the relation between the indent and the fold level.</p>
</div>
<div class="paragraph">
<p>More about folding by indent in the reference manual: |fold-indent|</p>
</div>
</div>
<div class="sect2">
<h3 id="_folding_with_markers">Folding with markers</h3>
<div class="paragraph">
<p>Markers in the text are used to specify the start and end of a fold region.
This gives precise control over which lines are included in a fold.  The
disadvantage is that the text needs to be modified.</p>
</div>
<div class="paragraph">
<p>Try it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set foldmethod=marker</pre>
</div>
</div>
<div class="paragraph">
<p>Example text, as it could appear in a C program:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/* foobar () {{{ */
int foobar()
{
        /* return a value {{{ */
        return 42;
        /* }}} */
}
/* }}} */</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the folded line will display the text before the marker.  This is
very useful to tell what the fold contains.</p>
</div>
<div class="paragraph">
<p>It&#8217;s quite annoying when the markers don&#8217;t pair up correctly after moving some
lines around.  This can be avoided by using numbered markers.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/* global variables {{{1 */
int varA, varB;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>/* functions {{{1 */
/* funcA() {{{2 */
void funcA() {}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>/* funcB() {{{2 */
void funcB() {}
/* }}}1 */</pre>
</div>
</div>
<div class="paragraph">
<p>At every numbered marker a fold at the specified level begins.  This will make
any fold at a higher level stop here.  You can just use numbered start markers
to define all folds.  Only when you want to explicitly stop a fold before
another starts you need to add an end marker.</p>
</div>
<div class="paragraph">
<p>More about folding with markers in the reference manual: |fold-marker|</p>
</div>
</div>
<div class="sect2">
<h3 id="_folding_by_syntax">Folding by syntax</h3>
<div class="paragraph">
<p>For each language Vim uses a different syntax file.  This defines the colors
for various items in the file.  If you are reading this in Vim, in a terminal
that supports colors, the colors you see are made with the "help" syntax file.
   In the syntax files it is possible to add syntax items that have the "fold"
argument.  These define a fold region.  This requires writing a syntax file
and adding these items in it.  That&#8217;s not so easy to do.  But once it&#8217;s done,
all folding happens automatically.
   Here we&#8217;ll assume you are using an existing syntax file.  Then there is
nothing more to explain.  You can open and close folds as explained above.
The folds will be created and deleted automatically when you edit the file.</p>
</div>
<div class="paragraph">
<p>More about folding by syntax in the reference manual: |fold-syntax|</p>
</div>
</div>
<div class="sect2">
<h3 id="_folding_by_expression">Folding by expression</h3>
<div class="paragraph">
<p>This is similar to folding by indent, but instead of using the indent of a
line a user function is called to compute the fold level of a line.  You can
use this for text where something in the text indicates which lines belong
together.  An example is an e-mail message where the quoted text is indicated
by a "&gt;" before the line.  To fold these quotes use this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set foldmethod=expr
:set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\"g\"),'[^&gt;].*','',''))</pre>
</div>
</div>
<div class="paragraph">
<p>You can try it out on this text:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>quoted text he wrote
quoted text he wrote
&gt; double quoted text I wrote
&gt; double quoted text I wrote</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Explanation for the 'foldexpr' used in the example (inside out):
   getline(v:lnum)                      gets the current line
   substitute(&#8230;&#8203;,'\\s','','g')         removes all white space from the line
   substitute(&#8230;&#8203;,'[^&gt;].*','','')       removes everything after leading '&gt;'s
   strlen(&#8230;&#8203;)                          counts the length of the string, which
                                        is the number of '&gt;'s found</p>
</div>
<div class="paragraph">
<p>Note that a backslash must be inserted before every space, double quote and
backslash for the ":set" command.  If this confuses you, do &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set foldexpr</pre>
</div>
</div>
<div class="paragraph">
<p>to check the actual resulting value.  To correct a complicated expression, use
the command-line completion:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set foldexpr=&lt;Tab&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Where &lt;Tab&gt; is a real Tab.  Vim will fill in the previous value, which you can
then edit.</p>
</div>
<div class="paragraph">
<p>When the expression gets more complicated you should put it in a function and
set 'foldexpr' to call that function.</p>
</div>
<div class="paragraph">
<p>More about folding by expression in the reference manual: |fold-expr|</p>
</div>
</div>
<div class="sect2">
<h3 id="_folding_unchanged_lines">Folding unchanged lines</h3>
<div class="paragraph">
<p>This is useful when you set the 'diff' option in the same window.  The
|vimdiff| command does this for you.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1</pre>
</div>
</div>
<div class="paragraph">
<p>Do this in every window that shows a different version of the same file.  You
will clearly see the differences between the files, while the text that didn&#8217;t
change is folded.</p>
</div>
<div class="paragraph">
<p>For more details see |fold-diff|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_which_fold_method_to_use">Which fold method to use?</h3>
<div class="paragraph">
<p>All these possibilities make you wonder which method you should choose.
Unfortunately, there is no golden rule.  Here are some hints.</p>
</div>
<div class="paragraph">
<p>If there is a syntax file with folding for the language you are editing, that
is probably the best choice.  If there isn&#8217;t one, you might try to write it.
This requires a good knowledge of search patterns.  It&#8217;s not easy, but when
it&#8217;s working you will not have to define folds manually.</p>
</div>
<div class="paragraph">
<p>Typing commands to manually fold regions can be used for unstructured text.
Then use the |:mkview| command to save and restore your folds.</p>
</div>
<div class="paragraph">
<p>The marker method requires you to change the file.  If you are sharing the
files with other people or you have to meet company standards, you might not
be allowed to add them.
   The main advantage of markers is that you can put them exactly where you
want them.  That avoids that a few lines are missed when you cut and paste
folds.  And you can add a comment about what is contained in the fold.</p>
</div>
<div class="paragraph">
<p>Folding by indent is something that works in many files, but not always very
well.  Use it when you can&#8217;t use one of the other methods.  However, it is
very useful for outlining.  Then you specifically use one 'shiftwidth' for
each nesting level.</p>
</div>
<div class="paragraph">
<p>Folding with expressions can make folds in almost any structured text.  It is
quite simple to specify, especially if the start and end of a fold can easily
be recognized.
   If you use the "expr" method to define folds, but they are not exactly how
you want them, you could switch to the "manual" method.  This will not remove
the defined folds.  Then you can delete or add folds manually.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_29.txt|  Moving through programs</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_moving_through_programs">Moving through programs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The creator of Vim is a computer programmer.  It&#8217;s no surprise that Vim
contains many features to aid in writing programs.  Jump around to find where
identifiers are defined and used.  Preview declarations in a separate window.
There is more in the next chapter.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using tags</p>
</li>
<li>
<p>The preview window</p>
</li>
<li>
<p>Moving through a program</p>
</li>
<li>
<p>Finding global identifiers</p>
</li>
<li>
<p>Finding local identifiers</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_using_tags">Using tags</h3>
<div class="paragraph">
<p>What is a tag?  It is a location where an identifier is defined.  An example
is a function definition in a C or C++ program.  A list of tags is kept in a
tags file.  This can be used by Vim to directly jump from any place to the
tag, the place where an identifier is defined.
   To generate the tags file for all C files in the current directory, use the
following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ctags *.c</pre>
</div>
</div>
<div class="paragraph">
<p>"ctags" is a separate program.  Most Unix systems already have it installed.
If you do not have it yet, you can find Exuberant ctags here:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http://ctags.sf.net</pre>
</div>
</div>
<div class="paragraph">
<p>Now when you are in Vim and you want to go to a function definition, you can
jump to it by using the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tag startlist</pre>
</div>
</div>
<div class="paragraph">
<p>This command will find the function "startlist" even if it is in another file.
   The CTRL-] command jumps to the tag of the word that is under the cursor.
This makes it easy to explore a tangle of C code.  Suppose, for example, that
you are in the function "write_block".  You can see that it calls
"write_line".  But what does "write_line" do?  By placing the cursor on the
call to "write_line" and pressing CTRL-], you jump to the definition of this
function.
   The "write_line" function calls "write_char".  You need to figure out what
it does.  So you position the cursor over the call to "write_char" and press
CTRL-].  Now you are at the definition of "write_char".</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+-------------------------------------+
|void write_block(char **s; int cnt)  |
|{                                    |
|   int i;                            |
|   for (i = 0; i &lt; cnt; ++i)         |
|      write_line(s[i]);              |
|}          |                         |
+-----------|-------------------------+
            |
     CTRL-] |
            |    +----------------------------+
            +--&gt; |void write_line(char *s)    |
                 |{                           |
                 |   while (*s != 0)          |
                 |      write_char(*s++);     |
                 |}       |                   |
                 +--------|-------------------+
                          |
                   CTRL-] |
                          |    +------------------------------------+
                          +--&gt; |void write_char(char c)             |
                               |{                                   |
                               |    putchar((int)(unsigned char)c); |
                               |}                                   |
                               +------------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>The ":tags" command shows the list of tags that you traversed through:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tags
  # TO tag         FROM line  in file/text
  1  1 write_line          8  write_block.c
  2  1 write_char          7  write_line.c
&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Now to go back.  The CTRL-T command goes to the preceding tag.  In the example
above you get back to the "write_line" function, in the call to "write_char".
   This command takes a count argument that indicates how many tags to jump
back.  You have gone forward, and now back.  Let&#8217;s go forward again.  The
following command goes to the tag on top of the list:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tag</pre>
</div>
</div>
<div class="paragraph">
<p>You can prefix it with a count and jump forward that many tags.  For example:
":3tag".  CTRL-T also can be preceded with a count.
   These commands thus allow you to go down a call tree with CTRL-] and back
up again with CTRL-T.  Use ":tags" to find out where you are.</p>
</div>
<div class="sect3">
<h4 id="_split_windows">SPLIT WINDOWS</h4>
<div class="paragraph">
<p>The ":tag" command replaces the file in the current window with the one
containing the new function.  But suppose you want to see not only the old
function but also the new one?  You can split the window using the ":split"
command followed by the ":tag" command.  Vim has a shorthand command that does
both:
        :stag tagname</p>
</div>
<div class="paragraph">
<p>To split the current window and jump to the tag under the cursor use this
command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-W ]</pre>
</div>
</div>
<div class="paragraph">
<p>If a count is specified, the new window will be that many lines high.</p>
</div>
</div>
<div class="sect3">
<h4 id="_more_tags_files">MORE TAGS FILES</h4>
<div class="paragraph">
<p>When you have files in many directories, you can create a tags file in each of
them.  Vim will then only be able to jump to tags within that directory.
   To find more tags files, set the 'tags' option to include all the relevant
tags files.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set tags=./tags,./../tags,./*/tags</pre>
</div>
</div>
<div class="paragraph">
<p>This finds a tags file in the same directory as the current file, one
directory level higher and in all subdirectories.
   This is quite a number of tags files, but it may still not be enough.  For
example, when editing a file in "~/proj/src", you will not find the tags file
"~/proj/sub/tags".  For this situation Vim offers to search a whole directory
tree for tags files.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set tags=~/proj/**/tags</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_one_tags_file">ONE TAGS FILE</h4>
<div class="paragraph">
<p>When Vim has to search many places for tags files, you can hear the disk
rattling.  It may get a bit slow.  In that case it&#8217;s better to spend this
time while generating one big tags file.  You might do this overnight.
   This requires the Exuberant ctags program, mentioned above.  It offers an
argument to search a whole directory tree:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>cd ~/proj
ctags -R .</pre>
</div>
</div>
<div class="paragraph">
<p>The nice thing about this is that Exuberant ctags recognizes various file
types.  Thus this doesn&#8217;t work just for C and C++ programs, also for Eiffel
and even Vim scripts.  See the ctags documentation to tune this.
   Now you only need to tell Vim where your big tags file is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set tags=~/proj/tags</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_matches">MULTIPLE MATCHES</h4>
<div class="paragraph">
<p>When a function is defined multiple times (or a method in several classes),
the ":tag" command will jump to the first one.  If there is a match in the
current file, that one is used first.
   You can now jump to other matches for the same tag with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tnext</pre>
</div>
</div>
<div class="paragraph">
<p>Repeat this to find further matches.  If there are many, you can select which
one to jump to:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tselect tagname</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will present you with a list of choices:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  # pri kind tag               file
  1 F   f    mch_init          os_amiga.c
               mch_init()
  2 F   f    mch_init          os_mac.c
               mch_init()
  3 F   f    mch_init          os_msdos.c
               mch_init(void)
  4 F   f    mch_init          os_riscos.c
               mch_init()
Enter nr of choice (&lt;CR&gt; to abort):</pre>
</div>
</div>
<div class="paragraph">
<p>You can now enter the number (in the first column) of the match that you would
like to jump to.  The information in the other columns give you a good idea of
where the match is defined.</p>
</div>
<div class="paragraph">
<p>To move between the matching tags, these commands can be used:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tfirst                 go to first match
:[count]tprevious       go to [count] previous match
:[count]tnext           go to [count] next match
:tlast                  go to last match</pre>
</div>
</div>
<div class="paragraph">
<p>If [count] is omitted then one is used.</p>
</div>
</div>
<div class="sect3">
<h4 id="_guessing_tag_names">GUESSING TAG NAMES</h4>
<div class="paragraph">
<p>Command line completion is a good way to avoid typing a long tag name.  Just
type the first bit and press &lt;Tab&gt;:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tag write_&lt;Tab&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>You will get the first match.  If it&#8217;s not the one you want, press &lt;Tab&gt; until
you find the right one.
   Sometimes you only know part of the name of a function.  Or you have many
tags that start with the same string, but end differently.  Then you can tell
Vim to use a pattern to find the tag.
   Suppose you want to jump to a tag that contains "block".  First type
this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tag /block</pre>
</div>
</div>
<div class="paragraph">
<p>Now use command line completion: press &lt;Tab&gt;.  Vim will find all tags that
contain "block" and use the first match.
   The "/" before a tag name tells Vim that what follows is not a literal tag
name, but a pattern.  You can use all the items for search patterns here.  For
example, suppose you want to select a tag that starts with "write_":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tselect /^write_</pre>
</div>
</div>
<div class="paragraph">
<p>The "^" specifies that the tag starts with "write_".  Otherwise it would also
be found halfway a tag name.  Similarly "$" at the end makes sure the pattern
matches until the end of a tag.</p>
</div>
</div>
<div class="sect3">
<h4 id="_a_tags_browser">A TAGS BROWSER</h4>
<div class="paragraph">
<p>Since CTRL-] takes you to the definition of the identifier under the cursor,
you can use a list of identifier names as a table of contents.  Here is an
example.
   First create a list of identifiers (this requires Exuberant ctags):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ctags --c-types=f -f functions *.c</pre>
</div>
</div>
<div class="paragraph">
<p>Now start Vim without a file, and edit this file in Vim, in a vertically split
window:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim
:vsplit functions</pre>
</div>
</div>
<div class="paragraph">
<p>The window contains a list of all the functions.  There is some more stuff,
but you can ignore that.  Do ":setlocal ts=99" to clean it up a bit.
   In this window, define a mapping:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:nnoremap &lt;buffer&gt; &lt;CR&gt; 0ye&lt;C-W&gt;w:tag &lt;C-R&gt;"&lt;CR&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Move the cursor to the line that contains the function you want to go to.
Now press &lt;Enter&gt;.  Vim will go to the other window and jump to the selected
function.</p>
</div>
</div>
<div class="sect3">
<h4 id="_related_items">RELATED ITEMS</h4>
<div class="paragraph">
<p>To make case in tag names be ignored, you can set 'ignorecase' while leaving
'tagcase' as "followic", or set 'tagcase' to "ignore".</p>
</div>
<div class="paragraph">
<p>The 'tagbsearch' option tells if the tags file is sorted or not.  The default
is to assume a sorted tags file, which makes a tags search a lot faster, but
doesn&#8217;t work if the tags file isn&#8217;t sorted.</p>
</div>
<div class="paragraph">
<p>The 'taglength' option can be used to tell Vim the number of significant
characters in a tag.</p>
</div>
<div class="paragraph">
<p>Cscope is a free program.  It does not only find places where an identifier is
declared, but also where it is used.  See |cscope|.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_preview_window">The preview window</h3>
<div class="paragraph">
<p>When you edit code that contains a function call, you need to use the correct
arguments.  To know what values to pass you can look at how the function is
defined.  The tags mechanism works very well for this.  Preferably the
definition is displayed in another window.  For this the preview window can be
used.
   To open a preview window to display the function "write_char":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:ptag write_char</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will open a window, and jumps to the tag "write_char".  Then it takes you
back to the original position.  Thus you can continue typing without the need
to use a CTRL-W command.
   If the name of a function appears in the text, you can get its definition
in the preview window with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-W }</pre>
</div>
</div>
<div class="paragraph">
<p>There is a script that automatically displays the text where the word under
the cursor was defined.  See |CursorHold-example|.</p>
</div>
<div class="paragraph">
<p>To close the preview window use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:pclose</pre>
</div>
</div>
<div class="paragraph">
<p>To edit a specific file in the preview window, use ":pedit".  This can be
useful to edit a header file, for example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:pedit defs.h</pre>
</div>
</div>
<div class="paragraph">
<p>Finally, ":psearch" can be used to find a word in the current file and any
included files and display the match in the preview window.  This is
especially useful when using library functions, for which you do not have a
tags file.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:psearch popen</pre>
</div>
</div>
<div class="paragraph">
<p>This will show the "stdio.h" file in the preview window, with the function
prototype for popen():</p>
</div>
<div class="literalblock">
<div class="content">
<pre>FILE    *popen __P((const char *, const char *));</pre>
</div>
</div>
<div class="paragraph">
<p>You can specify the height of the preview window, when it is opened, with the
'previewheight' option.</p>
</div>
</div>
<div class="sect2">
<h3 id="_moving_through_a_program">Moving through a program</h3>
<div class="paragraph">
<p>Since a program is structured, Vim can recognize items in it.  Specific
commands can be used to move around.
   C programs often contain constructs like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#ifdef USE_POPEN
    fd = popen("ls", "r")
#else
    fd = fopen("tmp", "w")
#endif</pre>
</div>
</div>
<div class="paragraph">
<p>But then much longer, and possibly nested.  Position the cursor on the
"#ifdef" and press %.  Vim will jump to the "#else".  Pressing % again takes
you to the "#endif".  Another % takes you to the "#ifdef" again.
   When the construct is nested, Vim will find the matching items.  This is a
good way to check if you didn&#8217;t forget an "#endif".
   When you are somewhere inside a "#if" - "#endif", you can jump to the start
of it with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[#</pre>
</div>
</div>
<div class="paragraph">
<p>If you are not after a "#if" or "#ifdef" Vim will beep.  To jump forward to
the next "#else" or "#endif" use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>]#</pre>
</div>
</div>
<div class="paragraph">
<p>These two commands skip any "#if" - "#endif" blocks that they encounter.
Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#if defined(HAS_INC_H)
    a = a + inc();
# ifdef USE_THEME
    a += 3;
# endif
    set_width(a);</pre>
</div>
</div>
<div class="paragraph">
<p>With the cursor in the last line, "[#" moves to the first line.  The "#ifdef"
- "#endif" block in the middle is skipped.</p>
</div>
<div class="sect3">
<h4 id="_moving_in_code_blocks">MOVING IN CODE BLOCKS</h4>
<div class="paragraph">
<p>In C code blocks are enclosed in {}.  These can get pretty long.  To move to
the start of the outer block use the "[[" command.  Use "][" to find the end.
This assumes that the "{" and "}" are in the first column.
   The "[{" command moves to the start of the current block.  It skips over
pairs of {} at the same level.  "]}" jumps to the end.
   An overview:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>                function(int a)
   +-&gt;          {
   |                if (a)
   |       +-&gt;      {
[[ |       |            for (;;)               --+
   |       |      +-&gt;   {                        |
   |    [{ |      |         foo(32);             |     --+
   |       |   [{ |         if (bar(a))  --+     | ]}    |
   +--     |      +--           break;     | ]}  |       |
           |            }                &lt;-+     |       | ][
           +--          foobar(a)                |       |
                    }                          &lt;-+       |
                }                                      &lt;-+</pre>
</div>
</div>
<div class="paragraph">
<p>When writing C++ or Java, the outer {} block is for the class.  The next level
of {} is for a method.  When somewhere inside a class use "[m" to find the
previous start of a method.  "]m" finds the next start of a method.</p>
</div>
<div class="paragraph">
<p>Additionally, "[]" moves backward to the end of a function and "]]" moves
forward to the start of the next function.  The end of a function is defined
by a "}" in the first column.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>                        int func1(void)
                        {
                                return 1;
          +----------&gt;  }
          |
      []  |             int func2(void)
          |        +-&gt;  {
          |    [[  |            if (flag)
start     +--      +--                  return flag;
          |    ][  |            return 2;
          |        +-&gt;  }
      ]]  |
          |             int func3(void)
          +----------&gt;  {
                                return 3;
                        }</pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t forget you can also use "%" to move between matching (), {} and [].
That also works when they are many lines apart.</p>
</div>
</div>
<div class="sect3">
<h4 id="_moving_in_braces">MOVING IN BRACES</h4>
<div class="paragraph">
<p>The "[(" and "])" commands work similar to "[{" and "]}", except that they
work on () pairs instead of {} pairs.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>                                  [(
&lt;                   &lt;--------------------------------
                              &lt;-------
                if (a == b &amp;&amp; (c == d || (e &gt; f)) &amp;&amp; x &gt; y)
                                  --------------&gt;
                          --------------------------------&gt; &gt;
                                       ])</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_moving_in_comments">MOVING IN COMMENTS</h4>
<div class="paragraph">
<p>To move back to the start of a comment use "[/".  Move forward to the end of a
comment with "]/".  This only works for /* - */ comments.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>   +-&gt;     +-&gt; /*
   |    [/ |    * A comment about      --+
[/ |       +--  * wonderful life.        | ]/
   |            */                     &lt;-+
   |
   +--          foo = bar * 3;         --+
                                         | ]/
                /* a short comment */  &lt;-+</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_finding_global_identifiers">Finding global identifiers</h3>
<div class="paragraph">
<p>You are editing a C program and wonder if a variable is declared as "int" or
"unsigned".  A quick way to find this is with the "[I" command.
   Suppose the cursor is on the word "column".  Type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[I</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will list the matching lines it can find.  Not only in the current file,
but also in all included files (and files included in them, etc.).  The result
looks like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>structs.h
 1:   29     unsigned     column;    /* column number */</pre>
</div>
</div>
<div class="paragraph">
<p>The advantage over using tags or the preview window is that included files are
searched.  In most cases this results in the right declaration to be found.
Also when the tags file is out of date.  Also when you don&#8217;t have tags for the
included files.
   However, a few things must be right for "[I" to do its work.  First of all,
the 'include' option must specify how a file is included.  The default value
works for C and C++.  For other languages you will have to change it.</p>
</div>
<div class="sect3">
<h4 id="_locating_included_files">LOCATING INCLUDED FILES</h4>
<div class="literalblock">
<div class="content">
<pre>   Vim will find included files in the places specified with the 'path'
option.  If a directory is missing, some include files will not be found.  You
can discover this with this command:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>:checkpath</pre>
</div>
</div>
<div class="paragraph">
<p>It will list the include files that could not be found.  Also files included
by the files that could be found.  An example of the output:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>--- Included files not found in path ---
&lt;io.h&gt;
vim.h --&gt;
  &lt;functions.h&gt;
  &lt;clib/exec_protos.h&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The "io.h" file is included by the current file and can&#8217;t be found.  "vim.h"
can be found, thus ":checkpath" goes into this file and checks what it
includes.  The "functions.h" and "clib/exec_protos.h" files, included by
"vim.h" are not found.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
Vim is not a compiler.  It does not recognize "#ifdef" statements.
This means every "#include" statement is used, also when it comes
after "#if NEVER".</pre>
</div>
</div>
<div class="paragraph">
<p>To fix the files that could not be found, add a directory to the 'path'
option.  A good place to find out about this is the Makefile.  Look out for
lines that contain "-I" items, like "-I/usr/local/X11".  To add this directory
use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set path+=/usr/local/X11</pre>
</div>
</div>
<div class="paragraph">
<p>When there are many subdirectories, you can use the "*" wildcard.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set path+=/usr/*/include</pre>
</div>
</div>
<div class="paragraph">
<p>This would find files in "/usr/local/include" as well as "/usr/X11/include".</p>
</div>
<div class="paragraph">
<p>When working on a project with a whole nested tree of included files, the "**"
items is useful.  This will search down in all subdirectories.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set path+=/projects/invent/**/include</pre>
</div>
</div>
<div class="paragraph">
<p>This will find files in the directories:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/projects/invent/include
/projects/invent/main/include
/projects/invent/main/os/include
etc.</pre>
</div>
</div>
<div class="paragraph">
<p>There are even more possibilities.  Check out the 'path' option for info.
   If you want to see which included files are actually found, use this
command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:checkpath!</pre>
</div>
</div>
<div class="paragraph">
<p>You will get a (very long) list of included files, the files they include, and
so on.  To shorten the list a bit, Vim shows "(Already listed)" for files that
were found before and doesn&#8217;t list the included files in there again.</p>
</div>
</div>
<div class="sect3">
<h4 id="_jumping_to_a_match">JUMPING TO A MATCH</h4>
<div class="paragraph">
<p>"[I" produces a list with only one line of text.  When you want to have a
closer look at the first item, you can jump to that line with the command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[&lt;Tab&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>You can also use "[ CTRL-I", since CTRL-I is the same as pressing &lt;Tab&gt;.</p>
</div>
<div class="paragraph">
<p>The list that "[I" produces has a number at the start of each line.  When you
want to jump to another item than the first one, type the number first:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>3[&lt;Tab&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Will jump to the third item in the list.  Remember that you can use CTRL-O to
jump back to where you started from.</p>
</div>
</div>
<div class="sect3">
<h4 id="_related_commands">RELATED COMMANDS</h4>
<div class="literalblock">
<div class="content">
<pre>[i              only lists the first match
]I              only lists items below the cursor
]i              only lists the first item below the cursor</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_finding_defined_identifiers">FINDING DEFINED IDENTIFIERS</h4>
<div class="paragraph">
<p>The "[I" command finds any identifier.  To find only macros, defined with
"#define" use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[D</pre>
</div>
</div>
<div class="paragraph">
<p>Again, this searches in included files.  The 'define' option specifies what a
line looks like that defines the items for "[D".  You could change it to make
it work with other languages than C or C++.
   The commands related to "[D" are:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[d              only lists the first match
]D              only lists items below the cursor
]d              only lists the first item below the cursor</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_finding_local_identifiers">Finding local identifiers</h3>
<div class="paragraph">
<p>The "[I" command searches included files.  To search in the current file only,
and jump to the first place where the word under the cursor is used:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gD</pre>
</div>
</div>
<div class="paragraph">
<p>Hint: Goto Definition.  This command is very useful to find a variable or
function that was declared locally ("static", in C terms).  Example (cursor on
"counter"):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>   +-&gt;   static int counter = 0;
   |
   |     int get_counter(void)
gD |     {
   |         ++counter;
   +--       return counter;
         }</pre>
</div>
</div>
<div class="paragraph">
<p>To restrict the search even further, and look only in the current function,
use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gd</pre>
</div>
</div>
<div class="paragraph">
<p>This will go back to the start of the current function and find the first
occurrence of the word under the cursor.  Actually, it searches backwards to
an empty line above a "{" in the first column.  From there it searches forward
for the identifier.  Example (cursor on "idx"):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        int find_entry(char *name)
        {
   +-&gt;      int idx;
   |
gd |        for (idx = 0; idx &lt; table_len; ++idx)
   |            if (strcmp(table[idx].name, name) == 0)
   +--              return idx;
        }</pre>
</div>
</div>
<div class="paragraph">
<p>Next chapter: |usr_30.txt|  Editing programs</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_editing_programs">Editing programs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vim has various commands that aid in writing computer programs.  Compile a
program and directly jump to reported errors.  Automatically set the indent
for many languages and format comments.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Compiling</p>
</li>
<li>
<p>Indenting C files</p>
</li>
<li>
<p>Automatic indenting</p>
</li>
<li>
<p>Other indenting</p>
</li>
<li>
<p>Tabs and spaces</p>
</li>
<li>
<p>Formatting comments</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_compiling">Compiling</h3>
<div class="paragraph">
<p>Vim has a set of so called "quickfix" commands.  They enable you to compile a
program from within Vim and then go through the errors generated and fix them
(hopefully).  You can then recompile and fix any new errors that are found
until finally your program compiles without any error.</p>
</div>
<div class="paragraph">
<p>The following command runs the program "make" (supplying it with any argument
you give) and captures the results:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:make {arguments}</pre>
</div>
</div>
<div class="paragraph">
<p>If errors were generated, they are captured and the editor positions you where
the first error occurred.
   Take a look at an example ":make" session.  (Typical :make sessions generate
far more errors and fewer stupid ones.)  After typing ":make" the screen looks
like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:!make | &amp;tee /tmp/vim215953.err
gcc -g -Wall -o prog main.c sub.c
main.c: In function 'main':
main.c:6: too many arguments to function 'do_sub'
main.c: At top level:
main.c:10: parse error before '}'
make: *** [prog] Error 1</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>2 returned
"main.c" 11L, 111C
(3 of 6): too many arguments to function 'do_sub'
Press ENTER or type command to continue</pre>
</div>
</div>
<div class="paragraph">
<p>From this you can see that you have errors in the file "main.c".  When you
press &lt;Enter&gt;, Vim displays the file "main.c", with the cursor positioned on
line 6, the first line with an error.  You did not need to specify the file or
the line number, Vim knew where to go by looking in the error messages.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>          +---------------------------------------------------+
          |int main()                                         |
          |{                                                  |
          |       int i=3;                                    |
cursor -&gt; |       do_sub("foo");                              |
          |       ++i;                                        |
          |       return (0);                                 |
          |}                                                  |
          |}                                                  |
          | ~                                                 |
          |(3 of 12): too many arguments to function 'do_sub' |
          +---------------------------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>The following command goes to where the next error occurs:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:cnext</pre>
</div>
</div>
<div class="paragraph">
<p>Vim jumps to line 10, the last line in the file, where there is an extra '}'.
   When there is not enough room, Vim will shorten the error message.  To see
the whole message use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:cc</pre>
</div>
</div>
<div class="paragraph">
<p>You can get an overview of all the error messages with the ":clist" command.
The output looks like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :clist
&lt;       3 main.c: 6:too many arguments to function 'do_sub'
        5 main.c: 10:parse error before '}'</pre>
</div>
</div>
<div class="paragraph">
<p>Only the lines where Vim recognized a file name and line number are listed
here.  It assumes those are the interesting lines and the rest is just boring
messages.  However, sometimes unrecognized lines do contain something you want
to see.  Output from the linker, for example, about an undefined function.
To see all the messages add a "!" to the command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :clist!
&lt;       1 gcc -g -Wall -o prog main.c sub.c
        2 main.c: In function 'main':
        3 main.c:6: too many arguments to function 'do_sub'
        4 main.c: At top level:
        5 main.c:10: parse error before '}'
        6 make: *** [prog] Error 1</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will highlight the current error.  To go back to the previous error, use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:cprevious</pre>
</div>
</div>
<div class="paragraph">
<p>Other commands to move around in the error list:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:cfirst         to first error
:clast          to last error
:cc 3           to error nr 3</pre>
</div>
</div>
<div class="sect3">
<h4 id="_using_another_compiler">USING ANOTHER COMPILER</h4>
<div class="paragraph">
<p>The name of the program to run when the ":make" command is executed is defined
by the 'makeprg' option.  Usually this is set to "make", but Visual C++ users
should set this to "nmake" by executing the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set makeprg=nmake</pre>
</div>
</div>
<div class="paragraph">
<p>You can also include arguments in this option.  Special characters need to
be escaped with a backslash.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set makeprg=nmake\ -f\ project.mak</pre>
</div>
</div>
<div class="paragraph">
<p>You can include special Vim keywords in the command specification.  The %
character expands to the name of the current file.  So if you execute the
command:
        :set makeprg=make\ %:S</p>
</div>
<div class="paragraph">
<p>When you are editing main.c, then ":make" executes the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>make main.c</pre>
</div>
</div>
<div class="paragraph">
<p>This is not too useful, so you will refine the command a little and use the :r
(root) modifier:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set makeprg=make\ %:r:S.o</pre>
</div>
</div>
<div class="paragraph">
<p>Now the command executed is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>make main.o</pre>
</div>
</div>
<div class="paragraph">
<p>More about these modifiers here: |filename-modifiers|.</p>
</div>
</div>
<div class="sect3">
<h4 id="_old_error_lists">OLD ERROR LISTS</h4>
<div class="paragraph">
<p>Suppose you ":make" a program.  There is a warning message in one file and an
error message in another.  You fix the error and use ":make" again to check if
it was really fixed.  Now you want to look at the warning message.  It doesn&#8217;t
show up in the last error list, since the file with the warning wasn&#8217;t
compiled again.  You can go back to the previous error list with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:colder</pre>
</div>
</div>
<div class="paragraph">
<p>Then use ":clist" and ":cc {nr}" to jump to the place with the warning.
   To go forward to the next error list:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:cnewer</pre>
</div>
</div>
<div class="paragraph">
<p>Vim remembers ten error lists.</p>
</div>
</div>
<div class="sect3">
<h4 id="_switching_compilers">SWITCHING COMPILERS</h4>
<div class="paragraph">
<p>You have to tell Vim what format the error messages are that your compiler
produces.  This is done with the 'errorformat' option.  The syntax of this
option is quite complicated and it can be made to fit almost any compiler.
You can find the explanation here: |errorformat|.</p>
</div>
<div class="paragraph">
<p>You might be using various different compilers.  Setting the 'makeprg' option,
and especially the 'errorformat' each time is not easy.  Vim offers a simple
method for this.  For example, to switch to using the Microsoft Visual C++
compiler:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:compiler msvc</pre>
</div>
</div>
<div class="paragraph">
<p>This will find the Vim script for the "msvc" compiler and set the appropriate
options.
   You can write your own compiler files.  See |write-compiler-plugin|.</p>
</div>
</div>
<div class="sect3">
<h4 id="_output_redirection">OUTPUT REDIRECTION</h4>
<div class="paragraph">
<p>The ":make" command redirects the output of the executed program to an error
file.  How this works depends on various things, such as the 'shell'.  If your
":make" command doesn&#8217;t capture the output, check the 'makeef' and
'shellpipe' options.  The 'shellquote' and 'shellxquote' options might also
matter.</p>
</div>
<div class="paragraph">
<p>In case you can&#8217;t get ":make" to redirect the file for you, an alternative is
to compile the program in another window and redirect the output into a file.
Then have Vim read this file with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:cfile {filename}</pre>
</div>
</div>
<div class="paragraph">
<p>Jumping to errors will work like with the ":make" command.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_indenting_c_style_text">Indenting C style text</h3>
<div class="paragraph">
<p>A program is much easier to understand when the lines have been properly
indented.  Vim offers various ways to make this less work.  For C or C style
programs like Java or C++, set the 'cindent' option.  Vim knows a lot about C
programs and will try very hard to automatically set the indent for you.  Set
the 'shiftwidth' option to the amount of spaces you want for a deeper level.
Four spaces will work fine.  One ":set" command will do it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set cindent shiftwidth=4</pre>
</div>
</div>
<div class="paragraph">
<p>With this option enabled, when you type something such as "if (x)", the next
line will automatically be indented an additional level.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>                            if (flag)
Automatic indent   ---&gt;         do_the_work();
Automatic unindent &lt;--      if (other_flag) {
Automatic indent   ---&gt;         do_file();
keep indent                     do_some_more();
Automatic unindent &lt;--      }</pre>
</div>
</div>
<div class="paragraph">
<p>When you type something in curly braces ({}), the text will be indented at the
start and unindented at the end.  The unindenting will happen after typing the
'}', since Vim can&#8217;t guess what you are going to type.</p>
</div>
<div class="paragraph">
<p>One side effect of automatic indentation is that it helps you catch errors in
your code early.  When you type a } to finish a function, only to find that
the automatic indentation gives it more indent than what you expected, there
is probably a } missing.  Use the "%" command to find out which { matches the
} you typed.
   A missing ) and ; also cause extra indent.  Thus if you get more white
space than you would expect, check the preceding lines.</p>
</div>
<div class="paragraph">
<p>When you have code that is badly formatted, or you inserted and deleted lines,
you need to re-indent the lines.  The "=" operator does this.  The simplest
form is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>==</pre>
</div>
</div>
<div class="paragraph">
<p>This indents the current line.  Like with all operators, there are three ways
to use it.  In Visual mode "=" indents the selected lines.  A useful text
object is "a{".  This selects the current {} block.  Thus, to re-indent the
code block the cursor is in:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>=a{</pre>
</div>
</div>
<div class="paragraph">
<p>I you have really badly indented code, you can re-indent the whole file with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gg=G</pre>
</div>
</div>
<div class="paragraph">
<p>However, don&#8217;t do this in files that have been carefully indented manually.
The automatic indenting does a good job, but in some situations you might want
to overrule it.</p>
</div>
<div class="sect3">
<h4 id="_setting_indent_style">SETTING INDENT STYLE</h4>
<div class="paragraph">
<p>Different people have different styles of indentation.  By default Vim does a
pretty good job of indenting in a way that 90% of programmers do.  There are
different styles, however; so if you want to, you can customize the
indentation style with the 'cinoptions' option.
   By default 'cinoptions' is empty and Vim uses the default style.  You can
add various items where you want something different.  For example, to make
curly braces be placed like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if (flag)
  {
    i = 8;
    j = 0;
  }</pre>
</div>
</div>
<div class="paragraph">
<p>Use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set cinoptions+={2</pre>
</div>
</div>
<div class="paragraph">
<p>There are many of these items.  See |cinoptions-values|.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_automatic_indenting">Automatic indenting</h3>
<div class="paragraph">
<p>You don&#8217;t want to switch on the 'cindent' option manually every time you edit
a C file.  This is how you make it work automatically:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:filetype indent on</pre>
</div>
</div>
<div class="paragraph">
<p>Actually, this does a lot more than switching on 'cindent' for C files.  First
of all, it enables detecting the type of a file.  That&#8217;s the same as what is
used for syntax highlighting.
   When the filetype is known, Vim will search for an indent file for this
type of file.  The Vim distribution includes a number of these for various
programming languages.  This indent file will then prepare for automatic
indenting specifically for this file.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t like the automatic indenting, you can switch it off again:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:filetype indent off</pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t like the indenting for one specific type of file, this is how you
avoid it.  Create a file with just this one line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let b:did_indent = 1</pre>
</div>
</div>
<div class="paragraph">
<p>Now you need to write this in a file with a specific name:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>{directory}/indent/{filetype}.vim</pre>
</div>
</div>
<div class="paragraph">
<p>The html is the name of the file type, such as "cpp" or "java".  You can
see the exact name that Vim detected with this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set filetype</pre>
</div>
</div>
<div class="paragraph">
<p>In this file the output is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>filetype=help</pre>
</div>
</div>
<div class="paragraph">
<p>Thus you would use "help" for html.
   For the {directory} part you need to use your runtime directory.  Look at
the output of this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set runtimepath</pre>
</div>
</div>
<div class="paragraph">
<p>Now use the first item, the name before the first comma.  Thus if the output
looks like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>runtimepath=~/.vim,/usr/local/share/vim/vim60/runtime,~/.vim/after</pre>
</div>
</div>
<div class="paragraph">
<p>You use "~/.vim" for {directory}.  Then the resulting file name is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>~/.vim/indent/help.vim</pre>
</div>
</div>
<div class="paragraph">
<p>Instead of switching the indenting off, you could write your own indent file.
How to do that is explained here: |indent-expression|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_other_indenting">Other indenting</h3>
<div class="paragraph">
<p>The most simple form of automatic indenting is with the 'autoindent' option.
It uses the indent from the previous line.  A bit smarter is the 'smartindent'
option.  This is useful for languages where no indent file is available.
'smartindent' is not as smart as 'cindent', but smarter than 'autoindent'.
   With 'smartindent' set, an extra level of indentation is added for each {
and removed for each }.  An extra level of indentation will also be added for
any of the words in the 'cinwords' option.  Lines that begin with # are
treated specially: all indentation is removed.  This is done so that
preprocessor directives will all start in column 1.  The indentation is
restored for the next line.</p>
</div>
<div class="sect3">
<h4 id="_correcting_indents">CORRECTING INDENTS</h4>
<div class="paragraph">
<p>When you are using 'autoindent' or 'smartindent' to get the indent of the
previous line, there will be many times when you need to add or remove one
'shiftwidth' worth of indent.  A quick way to do this is using the CTRL-D and
CTRL-T commands in Insert mode.
   For example, you are typing a shell script that is supposed to look like
this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if test -n a; then
   echo a
   echo "-------"
fi</pre>
</div>
</div>
<div class="paragraph">
<p>Start off by setting these options:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set autoindent shiftwidth=3</pre>
</div>
</div>
<div class="paragraph">
<p>You start by typing the first line, &lt;Enter&gt; and the start of the second line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if test -n a; then
echo</pre>
</div>
</div>
<div class="paragraph">
<p>Now you see that you need an extra indent.  Type CTRL-T.  The result:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if test -n a; then
   echo</pre>
</div>
</div>
<div class="paragraph">
<p>The CTRL-T command, in Insert mode, adds one 'shiftwidth' to the indent, no
matter where in the line you are.
   You continue typing the second line, &lt;Enter&gt; and the third line.  This time
the indent is OK.  Then &lt;Enter&gt; and the last line.  Now you have this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if test -n a; then
   echo a
   echo "-------"
   fi</pre>
</div>
</div>
<div class="paragraph">
<p>To remove the superfluous indent in the last line press CTRL-D.  This deletes
one 'shiftwidth' worth of indent, no matter where you are in the line.
   When you are in Normal mode, you can use the "&gt;&gt;" and "&lt;&lt;" commands to
shift lines.  "&gt;" and "&lt;" are operators, thus you have the usual three ways to
specify the lines you want to indent.  A useful combination is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&gt;i{</pre>
</div>
</div>
<div class="paragraph">
<p>This adds one indent to the current block of lines, inside {}.  The { and }
lines themselves are left unmodified.  "&gt;a{" includes them.  In this example
the cursor is on "printf":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>original text           after "&gt;i{"             after "&gt;a{"</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>if (flag)               if (flag)               if (flag)
{                       {                           {
printf("yes");              printf("yes");          printf("yes");
flag = 0;                   flag = 0;               flag = 0;
}                       }                           }</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tabs_and_spaces">Tabs and spaces</h3>
<div class="paragraph">
<p>'tabstop' is set to eight by default.  Although you can change it, you quickly
run into trouble later.  Other programs won&#8217;t know what tabstop value you
used.  They probably use the default value of eight, and your text suddenly
looks very different.  Also, most printers use a fixed tabstop value of eight.
Thus it&#8217;s best to keep 'tabstop' alone.  (If you edit a file which was written
with a different tabstop setting, see |25.3| for how to fix that.)
   For indenting lines in a program, using a multiple of eight spaces makes
you quickly run into the right border of the window.  Using a single space
doesn&#8217;t provide enough visual difference.  Many people prefer to use four
spaces, a good compromise.
   Since a &lt;Tab&gt; is eight spaces and you want to use an indent of four spaces,
you can&#8217;t use a &lt;Tab&gt; character to make your indent.  There are two ways to
handle this:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use a mix of &lt;Tab&gt; and space characters.  Since a &lt;Tab&gt; takes the place of
eight spaces, you have fewer characters in your file.  Inserting a &lt;Tab&gt;
is quicker than eight spaces.  Backspacing works faster as well.</p>
</li>
<li>
<p>Use spaces only.  This avoids the trouble with programs that use a
different tabstop value.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Fortunately, Vim supports both methods quite well.</p>
</div>
<div class="sect3">
<h4 id="_spaces_and_tabs">SPACES AND TABS</h4>
<div class="paragraph">
<p>If you are using a combination of tabs and spaces, you just edit normally.
The Vim defaults do a fine job of handling things.
   You can make life a little easier by setting the 'softtabstop' option.
This option tells Vim to make the &lt;Tab&gt; key look and feel as if tabs were set
at the value of 'softtabstop', but actually use a combination of tabs and
spaces.
   After you execute the following command, every time you press the &lt;Tab&gt; key
the cursor moves to the next 4-column boundary:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set softtabstop=4</pre>
</div>
</div>
<div class="paragraph">
<p>When you start in the first column and press &lt;Tab&gt;, you get 4 spaces inserted
in your text.  The second time, Vim takes out the 4 spaces and puts in a &lt;Tab&gt;
(thus taking you to column 8).  Thus Vim uses as many &lt;Tab&gt;s as possible, and
then fills up with spaces.
   When backspacing it works the other way around.  A &lt;BS&gt; will always delete
the amount specified with 'softtabstop'.  Then &lt;Tab&gt;s are used as many as
possible and spaces to fill the gap.
   The following shows what happens pressing &lt;Tab&gt; a few times, and then using
&lt;BS&gt;.  A "." stands for a space and "------&#8594;" for a &lt;Tab&gt;.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>type                      result
&lt;Tab&gt;                     ....
&lt;Tab&gt;&lt;Tab&gt;                -------&gt;
&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;           -------&gt;....
&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;&lt;BS&gt;       -------&gt;
&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;&lt;BS&gt;&lt;BS&gt;   ....</pre>
</div>
</div>
<div class="paragraph">
<p>An alternative is to use the 'smarttab' option.  When it&#8217;s set, Vim uses
'shiftwidth' for a &lt;Tab&gt; typed in the indent of a line, and a real &lt;Tab&gt; when
typed after the first non-blank character.  However, &lt;BS&gt; doesn&#8217;t work like
with 'softtabstop'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_just_spaces">JUST SPACES</h4>
<div class="paragraph">
<p>If you want absolutely no tabs in your file, you can set the 'expandtab'
option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set expandtab</pre>
</div>
</div>
<div class="paragraph">
<p>When this option is set, the &lt;Tab&gt; key inserts a series of spaces.  Thus you
get the same amount of white space as if a &lt;Tab&gt; character was inserted, but
there isn&#8217;t a real &lt;Tab&gt; character in your file.
   The backspace key will delete each space by itself.  Thus after typing one
&lt;Tab&gt; you have to press the &lt;BS&gt; key up to eight times to undo it.  If you are
in the indent, pressing CTRL-D will be a lot quicker.</p>
</div>
<div class="paragraph">
<p>CHANGING TABS IN SPACES (AND BACK)</p>
</div>
<div class="paragraph">
<p>Setting 'expandtab' does not affect any existing tabs.  In other words, any
tabs in the document remain tabs.  If you want to convert tabs to spaces, use
the ":retab" command.  Use these commands:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set expandtab
:%retab</pre>
</div>
</div>
<div class="paragraph">
<p>Now Vim will have changed all indents to use spaces instead of tabs.  However,
all tabs that come after a non-blank character are kept.  If you want these to
be converted as well, add a !:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:%retab!</pre>
</div>
</div>
<div class="paragraph">
<p>This is a little bit dangerous, because it can also change tabs inside a
string.  To check if these exist, you could use this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/"[^"\t]*\t[^"]*"</pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s recommended not to use hard tabs inside a string.  Replace them with
"\t" to avoid trouble.</p>
</div>
<div class="paragraph">
<p>The other way around works just as well:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set noexpandtab
:%retab!</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_formatting_comments">Formatting comments</h3>
<div class="paragraph">
<p>One of the great things about Vim is that it understands comments.  You can
ask Vim to format a comment and it will do the right thing.
   Suppose, for example, that you have the following comment:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/*
 * This is a test
 * of the text formatting.
 */</pre>
</div>
</div>
<div class="paragraph">
<p>You then ask Vim to format it by positioning the cursor at the start of the
comment and type:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gq]/</pre>
</div>
</div>
<div class="paragraph">
<p>"gq" is the operator to format text.  "]/" is the motion that takes you to the
end of a comment.  The result is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/*
 * This is a test of the text formatting.
 */</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that Vim properly handled the beginning of each line.
  An alternative is to select the text that is to be formatted in Visual mode
and type "gq".</p>
</div>
<div class="paragraph">
<p>To add a new line to the comment, position the cursor on the middle line and
press "o".  The result looks like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/*
 * This is a test of the text formatting.
 *
 */</pre>
</div>
</div>
<div class="paragraph">
<p>Vim has automatically inserted a star and a space for you.  Now you can type
the comment text.  When it gets longer than 'textwidth', Vim will break the
line.  Again, the star is inserted automatically:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/*
 * This is a test of the text formatting.
 * Typing a lot of text here will make Vim
 * break
 */</pre>
</div>
</div>
<div class="paragraph">
<p>For this to work some flags must be present in 'formatoptions':</p>
</div>
<div class="literalblock">
<div class="content">
<pre>r       insert the star when typing &lt;Enter&gt; in Insert mode
o       insert the star when using "o" or "O" in Normal mode
c       break comment text according to 'textwidth'</pre>
</div>
</div>
<div class="paragraph">
<p>See |fo-table| for more flags.</p>
</div>
<div class="sect3">
<h4 id="_defining_a_comment">DEFINING A COMMENT</h4>
<div class="paragraph">
<p>The 'comments' option defines what a comment looks like.  Vim distinguishes
between a single-line comment and a comment that has a different start, end
and middle part.
   Many single-line comments start with a specific character.  In C // is
used, in Makefiles #, in Vim scripts ".  For example, to make Vim understand
C comments:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set comments=://</pre>
</div>
</div>
<div class="paragraph">
<p>The colon separates the flags of an item from the text by which the comment is
recognized.  The general form of an item in 'comments' is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>{flags}:{text}</pre>
</div>
</div>
<div class="paragraph">
<p>The {flags} part can be empty, as in this case.
   Several of these items can be concatenated, separated by commas.  This
allows recognizing different types of comments at the same time.  For example,
let&#8217;s edit an e-mail message.  When replying, the text that others wrote is
preceded with "&gt;" and "!" characters.  This command would work:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set comments=n:&gt;,n:!</pre>
</div>
</div>
<div class="paragraph">
<p>There are two items, one for comments starting with "&gt;" and one for comments
that start with "!".  Both use the flag "n".  This means that these comments
nest.  Thus a line starting with "&gt;" may have another comment after the "&gt;".
This allows formatting a message like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&gt; ! Did you see that site?
&gt; ! It looks really great.
&gt; I don't like it.  The
&gt; colors are terrible.
What is the URL of that
site?</pre>
</div>
</div>
<div class="paragraph">
<p>Try setting 'textwidth' to a different value, e.g., 80, and format the text by
Visually selecting it and typing "gq".  The result is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&gt; ! Did you see that site?  It looks really great.
&gt; I don't like it.  The colors are terrible.
What is the URL of that site?</pre>
</div>
</div>
<div class="paragraph">
<p>You will notice that Vim did not move text from one type of comment to
another.  The "I" in the second line would have fit at the end of the first
line, but since that line starts with "&gt; !" and the second line with "&gt;", Vim
knows that this is a different kind of comment.</p>
</div>
</div>
<div class="sect3">
<h4 id="_a_three_part_comment">A THREE PART COMMENT</h4>
<div class="paragraph">
<p>A C comment starts with "/<strong>", has "</strong>" in the middle and "*/" at the end.  The
entry in 'comments' for this looks like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set comments=s1:/*,mb:*,ex:*/</pre>
</div>
</div>
<div class="paragraph">
<p>The start is defined with "s1:/<strong>".  The "s" indicates the start of a
three-piece comment.  The colon separates the flags from the text by which the
comment is recognized: "/</strong>".  There is one flag: "1".  This tells Vim that the
middle part has an offset of one space.
   The middle part "mb:*" starts with "m", which indicates it is a middle
part.  The "b" flag means that a blank must follow the text.  Otherwise Vim
would consider text like "<strong>pointer" also to be the middle of a comment.
   The end part "ex:</strong>/" has the "e" for identification.  The "x" flag has a
special meaning.  It means that after Vim automatically inserted a star,
typing / will remove the extra space.</p>
</div>
<div class="paragraph">
<p>For more details see |format-comments|.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_31.txt|  Exploiting the GUI</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exploiting_the_gui">Exploiting the GUI</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vim works well in a terminal, but the GUI has a few extra items.  A file
browser can be used for commands that use a file.  A dialog to make a choice
between alternatives.  Use keyboard shortcuts to access menu items quickly.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The file browser</p>
</li>
<li>
<p>Confirmation</p>
</li>
<li>
<p>Menu shortcuts</p>
</li>
<li>
<p>Vim window position and size</p>
</li>
<li>
<p>Various</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_the_file_browser_2">The file browser</h3>
<div class="paragraph">
<p>When using the File/Open&#8230;&#8203; menu you get a file browser.  This makes it easier
to find the file you want to edit.  But what if you want to split a window to
edit another file?  There is no menu entry for this.  You could first use
Window/Split and then File/Open&#8230;&#8203;, but that&#8217;s more work.
   Since you are typing most commands in Vim, opening the file browser with a
typed command is possible as well.  To make the split command use the file
browser, prepend "browse":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:browse split</pre>
</div>
</div>
<div class="paragraph">
<p>Select a file and then the ":split" command will be executed with it.  If you
cancel the file dialog nothing happens, the window isn&#8217;t split.
   You can also specify a file name argument.  This is used to tell the file
browser where to start.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:browse split /etc</pre>
</div>
</div>
<div class="paragraph">
<p>The file browser will pop up, starting in the directory "/etc".</p>
</div>
<div class="paragraph">
<p>The ":browse" command can be prepended to just about any command that opens a
file.
   If no directory is specified, Vim will decide where to start the file
browser.  By default it uses the same directory as the last time.  Thus when
you used ":browse split" and selected a file in "/usr/local/share", the next
time you use a ":browse" it will start in "/usr/local/share" again.
   This can be changed with the 'browsedir' option.  It can have one of three
values:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>last            Use the last directory browsed (default)
buffer          Use the same directory as the current buffer
current         use the current directory</pre>
</div>
</div>
<div class="paragraph">
<p>For example, when you are in the directory "/usr", editing the file
"/usr/local/share/readme", then the command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set browsedir=buffer
:browse edit</pre>
</div>
</div>
<div class="paragraph">
<p>Will start the browser in "/usr/local/share".  Alternatively:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set browsedir=current
:browse edit</pre>
</div>
</div>
<div class="paragraph">
<p>Will start the browser in "/usr".</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
To avoid using the mouse, most file browsers offer using key presses
to navigate.  Since this is different for every system, it is not
explained here.  Vim uses a standard browser when possible, your
system documentation should contain an explanation on the keyboard
shortcuts somewhere.</pre>
</div>
</div>
<div class="paragraph">
<p>When you are not using the GUI version, you could use the file explorer window
to select files like in a file browser.  However, this doesn&#8217;t work for the
":browse" command.  See |netrw-browse|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_confirmation">Confirmation</h3>
<div class="paragraph">
<p>Vim protects you from accidentally overwriting a file and other ways to lose
changes.  If you do something that might be a bad thing to do, Vim produces an
error message and suggests appending ! if you really want to do it.
   To avoid retyping the command with the !, you can make Vim give you a
dialog.  You can then press "OK" or "Cancel" to tell Vim what you want.
   For example, you are editing a file and made changes to it.  You start
editing another file with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:confirm edit foo.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will pop up a dialog that looks something like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+-----------------------------------+
|                                   |
|   ?   Save changes to "bar.txt"?  |
|                                   |
|   YES   NO             CANCEL     |
+-----------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>Now make your choice.  If you do want to save the changes, select "YES".  If
you want to lose the changes for ever: "NO".  If you forgot what you were
doing and want to check what really changed use "CANCEL".  You will be back in
the same file, with the changes still there.</p>
</div>
<div class="paragraph">
<p>Just like ":browse", the ":confirm" command can be prepended to most commands
that edit another file.  They can also be combined:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:confirm browse edit</pre>
</div>
</div>
<div class="paragraph">
<p>This will produce a dialog when the current buffer was changed.  Then it will
pop up a file browser to select the file to edit.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
In the dialog you can use the keyboard to select the choice.
Typically the &lt;Tab&gt; key and the cursor keys change the choice.
Pressing &lt;Enter&gt; selects the choice.  This depends on the system
though.</pre>
</div>
</div>
<div class="paragraph">
<p>When you are not using the GUI, the ":confirm" command works as well.  Instead
of popping up a dialog, Vim will print the message at the bottom of the Vim
window and ask you to press a key to make a choice. &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :confirm edit main.c
&lt;       Save changes to "Untitled"?
        [Y]es, (N)o, (C)ancel:</pre>
</div>
</div>
<div class="paragraph">
<p>You can now press the single key for the choice.  You don&#8217;t have to press
&lt;Enter&gt;, unlike other typing on the command line.</p>
</div>
</div>
<div class="sect2">
<h3 id="_menu_shortcuts">Menu shortcuts</h3>
<div class="paragraph">
<p>The keyboard is used for all Vim commands.  The menus provide a simple way to
select commands, without knowing what they are called.  But you have to move
your hand from the keyboard and grab the mouse.
   Menus can often be selected with keys as well.  This depends on your
system, but most often it works this way.  Use the &lt;Alt&gt; key in combination
with the underlined letter of a menu.  For example, &lt;A-w&gt; (&lt;Alt&gt; and w) pops
up the Window menu.
   In the Window menu, the "split" item has the p underlined.  To select it,
let go of the &lt;Alt&gt; key and press p.</p>
</div>
<div class="paragraph">
<p>After the first selection of a menu with the &lt;Alt&gt; key, you can use the cursor
keys to move through the menus.  &lt;Right&gt; selects a submenu and &lt;left&gt; closes
it.  &lt;Esc&gt; also closes a menu.  &lt;Enter&gt; selects a menu item.</p>
</div>
<div class="paragraph">
<p>There is a conflict between using the &lt;Alt&gt; key to select menu items, and
using &lt;Alt&gt; key combinations for mappings.  The 'winaltkeys' option tells Vim
what it should do with the &lt;Alt&gt; key.
   The default value "menu" is the smart choice: If the key combination is a
menu shortcut it can&#8217;t be mapped.  All other keys are available for mapping.
   The value "no" doesn&#8217;t use any &lt;Alt&gt; keys for the menus.  Thus you must use
the mouse for the menus, and all &lt;Alt&gt; keys can be mapped.
   The value "yes" means that Vim will use any &lt;Alt&gt; keys for the menus.  Some
&lt;Alt&gt; key combinations may also do other things than selecting a menu.</p>
</div>
</div>
<div class="sect2">
<h3 id="_vim_window_position_and_size">Vim window position and size</h3>
<div class="paragraph">
<p>To see the current Vim window position on the screen use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:winpos</pre>
</div>
</div>
<div class="paragraph">
<p>This will only work in the GUI.  The output may look like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Window position: X 272, Y 103</pre>
</div>
</div>
<div class="paragraph">
<p>The position is given in screen pixels.  Now you can use the numbers to move
Vim somewhere else.  For example, to move it to the left a hundred pixels:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:winpos 172 103</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
There may be a small offset between the reported position and where
the window moves.  This is because of the border around the window.
This is added by the window manager.</pre>
</div>
</div>
<div class="paragraph">
<p>You can use this command in your startup script to position the window at a
specific position.</p>
</div>
<div class="paragraph">
<p>The size of the Vim window is computed in characters.  Thus this depends on
the size of the font being used.  You can see the current size with this
command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set lines columns</pre>
</div>
</div>
<div class="paragraph">
<p>To change the size set the 'lines' and/or 'columns' options to a new value:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set lines=50
:set columns=80</pre>
</div>
</div>
<div class="paragraph">
<p>Obtaining the size works in a terminal just like in the GUI.  Setting the size
is not possible in most terminals.</p>
</div>
<div class="paragraph">
<p>You can start the X-Windows version of gvim with an argument to specify the
size and position of the window:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gvim -geometry {width}x{height}+{x_offset}+{y_offset}</pre>
</div>
</div>
<div class="paragraph">
<p>{width} and {height} are in characters, {x_offset} and {y_offset} are in
pixels.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gvim -geometry 80x25+100+300</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_various_2">Various</h3>
<div class="paragraph">
<p>You can use gvim to edit an e-mail message.  In your e-mail program you must
select gvim to be the editor for messages.  When you try that, you will
see that it doesn&#8217;t work: The mail program thinks that editing is finished,
while gvim is still running!
   What happens is that gvim disconnects from the shell it was started in.
That is fine when you start gvim in a terminal, so that you can do other work
in that terminal.  But when you really want to wait for gvim to finish, you
must prevent it from disconnecting.  The "-f" argument does this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gvim -f file.txt</pre>
</div>
</div>
<div class="paragraph">
<p>The "-f" stands for foreground.  Now Vim will block the shell it was started
in until you finish editing and exit.</p>
</div>
<div class="sect3">
<h4 id="_delayed_start_of_the_gui">DELAYED START OF THE GUI</h4>
<div class="paragraph">
<p>On Unix it&#8217;s possible to first start Vim in a terminal.  That&#8217;s useful if you
do various tasks in the same shell.  If you are editing a file and decide you
want to use the GUI after all, you can start it with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:gui</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will open the GUI window and no longer use the terminal.  You can continue
using the terminal for something else.  The "-f" argument is used here to run
the GUI in the foreground.  You can also use ":gui -f".</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_gvim_startup_file">THE GVIM STARTUP FILE</h4>
<div class="paragraph">
<p>When gvim starts, it reads the gvimrc file.  That&#8217;s similar to the vimrc file
used when starting Vim.  The gvimrc file can be used for settings and commands
that are only to be used when the GUI is going to be started.  For example,
you can set the 'lines' option to set a different window size:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set lines=55</pre>
</div>
</div>
<div class="paragraph">
<p>You don&#8217;t want to do this in a terminal, since its size is fixed (except for
an xterm that supports resizing).
   The gvimrc file is searched for in the same locations as the vimrc file.
Normally its name is "~/.gvimrc" for Unix and "$VIM/_gvimrc" for MS-Windows.
The $MYGVIMRC environment variable is set to it, thus you can use this command
to edit the file, if you have one:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit $MYGVIMRC</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>   If for some reason you don't want to use the normal gvimrc file, you can
specify another one with the "-U" argument:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>gvim -U thisrc ...</pre>
</div>
</div>
<div class="paragraph">
<p>That allows starting gvim for different kinds of editing.  You could set
another font size, for example.
   To completely skip reading a gvimrc file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gvim -U NONE ...</pre>
</div>
</div>
<div class="paragraph">
<p>Next chapter: |usr_32.txt|  The undo tree</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_undo_tree">The undo tree</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vim provides multi-level undo.  If you undo a few changes and then make a new
change you create a branch in the undo tree.  This text is about moving
through the branches.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Undo up to a file write</p>
</li>
<li>
<p>Numbering changes</p>
</li>
<li>
<p>Jumping around the tree</p>
</li>
<li>
<p>Time travelling</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_undo_up_to_a_file_write">Undo up to a file write</h3>
<div class="paragraph">
<p>Sometimes you make several changes, and then discover you want to go back to
when you have last written the file.  You can do that with this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:earlier 1f</pre>
</div>
</div>
<div class="paragraph">
<p>The "f" stands for "file" here.</p>
</div>
<div class="paragraph">
<p>You can repeat this command to go further back in the past.  Or use a count
different from 1 to go back faster.</p>
</div>
<div class="paragraph">
<p>If you go back too far, go forward again with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:later 1f</pre>
</div>
</div>
<div class="paragraph">
<p>Note that these commands really work in time sequence.  This matters if you
made changes after undoing some changes.  It&#8217;s explained in the next section.</p>
</div>
<div class="paragraph">
<p>Also note that we are talking about text writes here.  For writing the undo
information in a file see |undo-persistence|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_numbering_changes">Numbering changes</h3>
<div class="paragraph">
<p>In section |02.5| we only discussed one line of undo/redo.  But it is also
possible to branch off.  This happens when you undo a few changes and then
make a new change.  The new changes become a branch in the undo tree.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with the text "one".  The first change to make is to append
" too".  And then move to the first 'o' and change it into 'w'.  We then have
two changes, numbered 1 and 2, and three states of the text:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  one
   |
change 1
   |
one too
   |
change 2
   |
one two</pre>
</div>
</div>
<div class="paragraph">
<p>If we now undo one change, back to "one too", and change "one" to "me" we
create a branch in the undo tree:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>       one
        |
     change 1
        |
     one too
     /     \
change 2  change 3
   |         |
one two    me too</pre>
</div>
</div>
<div class="paragraph">
<p>You can now use the |u| command to undo.  If you do this twice you get to
"one".  Use |CTRL-R| to redo, and you will go to "one too".  One more |CTRL-R|
takes you to "me too".  Thus undo and redo go up and down in the tree, using
the branch that was last used.</p>
</div>
<div class="paragraph">
<p>What matters here is the order in which the changes are made.  Undo and redo
are not considered changes in this context.  After each change you have a new
state of the text.</p>
</div>
<div class="paragraph">
<p>Note that only the changes are numbered, the text shown in the tree above has
no identifier.  They are mostly referred to by the number of the change above
it.  But sometimes by the number of one of the changes below it, especially
when moving up in the tree, so that you know which change was just undone.</p>
</div>
</div>
<div class="sect2">
<h3 id="_jumping_around_the_tree">Jumping around the tree</h3>
<div class="paragraph">
<p>So how do you get to "one two" now?  You can use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:undo 2</pre>
</div>
</div>
<div class="paragraph">
<p>The text is now "one two", you are below change 2.  You can use the |:undo|
command to jump to below any change in the tree.</p>
</div>
<div class="paragraph">
<p>Now make another change: change "one" to "not":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>       one
        |
     change 1
        |
     one too
     /     \
change 2  change 3
   |         |
one two    me too
   |
change 4
   |
not two</pre>
</div>
</div>
<div class="paragraph">
<p>Now you change your mind and want to go back to "me too".  Use the |g-|
command.  This moves back in time.  Thus it doesn&#8217;t walk the tree upwards or
downwards, but goes to the change made before.</p>
</div>
<div class="paragraph">
<p>You can repeat |g-| and you will see the text change:
        me too
        one two
        one too
        one</p>
</div>
<div class="paragraph">
<p>Use |g+| to move forward in time:
        one
        one too
        one two
        me too
        not two</p>
</div>
<div class="paragraph">
<p>Using |:undo| is useful if you know what change you want to jump to.  |g-| and
|g+| are useful if you don&#8217;t know exactly what the change number is.</p>
</div>
<div class="paragraph">
<p>You can type a count before |g-| and |g+| to repeat them.</p>
</div>
</div>
<div class="sect2">
<h3 id="_time_travelling">Time travelling</h3>
<div class="paragraph">
<p>When you have been working on text for a while the tree grows to become big.
Then you may want to go to the text of some minutes ago.</p>
</div>
<div class="paragraph">
<p>To see what branches there are in the undo tree use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :undolist
&lt;       number changes  time
             3       2  16 seconds ago
             4       3  5 seconds ago</pre>
</div>
</div>
<div class="paragraph">
<p>Here you can see the number of the leaves in each branch and when the change
was made.  Assuming we are below change 4, at "not two", you can go back ten
seconds with this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:earlier 10s</pre>
</div>
</div>
<div class="paragraph">
<p>Depending on how much time you took for the changes you end up at a certain
position in the tree.  The |:earlier| command argument can be "m" for minutes,
"h" for hours and "d" for days.  To go all the way back use a big number:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:earlier 100d</pre>
</div>
</div>
<div class="paragraph">
<p>To travel forward in time again use the |:later| command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:later 1m</pre>
</div>
</div>
<div class="paragraph">
<p>The arguments are "s", "m" and "h", just like with |:earlier|.</p>
</div>
<div class="paragraph">
<p>If you want even more details, or want to manipulate the information, you can
use the |undotree()| function.  To see what it returns:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:echo undotree()</pre>
</div>
</div>
<div class="paragraph">
<p>Next chapter: |usr_40.txt|  Make new commands</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_make_new_commands">Make new commands</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vim is an extensible editor.  You can take a sequence of commands you use
often and turn it into a new command.  Or redefine an existing command.
Autocommands make it possible to execute commands automatically.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Key mapping</p>
</li>
<li>
<p>Defining command-line commands</p>
</li>
<li>
<p>Autocommands</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_key_mapping">Key mapping</h3>
<div class="paragraph">
<p>A simple mapping was explained in section |05.3|.  The principle is that one
sequence of key strokes is translated into another sequence of key strokes.
This is a simple, yet powerful mechanism.
   The simplest form is that one key is mapped to a sequence of keys.  Since
the function keys, except &lt;F1&gt;, have no predefined meaning in Vim, these are
good choices to map.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map &lt;F2&gt; GoDate: &lt;Esc&gt;:read !date&lt;CR&gt;kJ</pre>
</div>
</div>
<div class="paragraph">
<p>This shows how three modes are used.  After going to the last line with "G",
the "o" command opens a new line and starts Insert mode.  The text "Date: " is
inserted and &lt;Esc&gt; takes you out of insert mode.
   Notice the use of special keys inside &lt;&gt;.  This is called angle bracket
notation.  You type these as separate characters, not by pressing the key
itself.  This makes the mappings better readable and you can copy and paste
the text without problems.
   The ":" character takes Vim to the command line.  The ":read !date" command
reads the output from the "date" command and appends it below the current
line.  The &lt;CR&gt; is required to execute the ":read" command.
   At this point of execution the text looks like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Date:
Fri Jun 15 12:54:34 CEST 2001</pre>
</div>
</div>
<div class="paragraph">
<p>Now "kJ" moves the cursor up and joins the lines together.
   To decide which key or keys you use for mapping, see |map-which-keys|.</p>
</div>
<div class="sect3">
<h4 id="_mapping_and_modes">MAPPING AND MODES</h4>
<div class="paragraph">
<p>The ":map" command defines remapping for keys in Normal mode.  You can also
define mappings for other modes.  For example, ":imap" applies to Insert mode.
You can use it to insert a date below the cursor:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:imap &lt;F2&gt; &lt;CR&gt;Date: &lt;Esc&gt;:read !date&lt;CR&gt;kJ</pre>
</div>
</div>
<div class="paragraph">
<p>It looks a lot like the mapping for &lt;F2&gt; in Normal mode, only the start is
different.  The &lt;F2&gt; mapping for Normal mode is still there.  Thus you can map
the same key differently for each mode.
   Notice that, although this mapping starts in Insert mode, it ends in Normal
mode.  If you want it to continue in Insert mode, append an "a" to the
mapping.</p>
</div>
<div class="paragraph">
<p>Here is an overview of map commands and in which mode they work:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map            Normal, Visual and Operator-pending
:vmap           Visual
:nmap           Normal
:omap           Operator-pending
:map!           Insert and Command-line
:imap           Insert
:cmap           Command-line</pre>
</div>
</div>
<div class="paragraph">
<p>Operator-pending mode is when you typed an operator character, such as "d" or
"y", and you are expected to type the motion command or a text object.  Thus
when you type "dw", the "w" is entered in operator-pending mode.</p>
</div>
<div class="paragraph">
<p>Suppose that you want to define &lt;F7&gt; so that the command d&lt;F7&gt; deletes a C
program block (text enclosed in curly braces, {}).  Similarly y&lt;F7&gt; would yank
the program block into the unnamed register.  Therefore, what you need to do
is to define &lt;F7&gt; to select the current program block.  You can do this with
the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:omap &lt;F7&gt; a{</pre>
</div>
</div>
<div class="paragraph">
<p>This causes &lt;F7&gt; to perform a select block "a{" in operator-pending mode, just
like you typed it.  This mapping is useful if typing a { on your keyboard is a
bit difficult.</p>
</div>
</div>
<div class="sect3">
<h4 id="_listing_mappings">LISTING MAPPINGS</h4>
<div class="paragraph">
<p>To see the currently defined mappings, use ":map" without arguments.  Or one
of the variants that include the mode in which they work.  The output could
look like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>   _g            :call MyGrep(1)&lt;CR&gt;
v  &lt;F2&gt;          :s/^/&gt; /&lt;CR&gt;:noh&lt;CR&gt;``
n  &lt;F2&gt;          :.,$s/^/&gt; /&lt;CR&gt;:noh&lt;CR&gt;``
   &lt;xHome&gt;       &lt;Home&gt;
   &lt;xEnd&gt;        &lt;End&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The first column of the list shows in which mode the mapping is effective.
This is "n" for Normal mode, "i" for Insert mode, etc.  A blank is used for a
mapping defined with ":map", thus effective in both Normal and Visual mode.
   One useful purpose of listing the mapping is to check if special keys in &lt;&gt;
form have been recognized (this only works when color is supported).  For
example, when &lt;Esc&gt; is displayed in color, it stands for the escape character.
When it has the same color as the other text, it is five characters.</p>
</div>
</div>
<div class="sect3">
<h4 id="_remapping">REMAPPING</h4>
<div class="paragraph">
<p>The result of a mapping is inspected for other mappings in it.  For example,
the mappings for &lt;F2&gt; above could be shortened to:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map &lt;F2&gt; G&lt;F3&gt;
:imap &lt;F2&gt; &lt;Esc&gt;&lt;F3&gt;
:map &lt;F3&gt;  oDate: &lt;Esc&gt;:read !date&lt;CR&gt;kJ</pre>
</div>
</div>
<div class="paragraph">
<p>For Normal mode &lt;F2&gt; is mapped to go to the last line, and then behave like
&lt;F3&gt; was pressed.  In Insert mode &lt;F2&gt; stops Insert mode with &lt;Esc&gt; and then
also uses &lt;F3&gt;.  Then &lt;F3&gt; is mapped to do the actual work.</p>
</div>
<div class="paragraph">
<p>Suppose you hardly ever use Ex mode, and want to use the "Q" command to format
text (this was so in old versions of Vim).  This mapping will do it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map Q gq</pre>
</div>
</div>
<div class="paragraph">
<p>But, in rare cases you need to use Ex mode anyway.  Let&#8217;s map "gQ" to Q, so
that you can still go to Ex mode:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map gQ Q</pre>
</div>
</div>
<div class="paragraph">
<p>What happens now is that when you type "gQ" it is mapped to "Q".  So far so
good.  But then "Q" is mapped to "gq", thus typing "gQ" results in "gq", and
you don&#8217;t get to Ex mode at all.
   To avoid keys to be mapped again, use the ":noremap" command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:noremap gQ Q</pre>
</div>
</div>
<div class="paragraph">
<p>Now Vim knows that the "Q" is not to be inspected for mappings that apply to
it.  There is a similar command for every mode:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:noremap        Normal, Visual and Operator-pending
:vnoremap       Visual
:nnoremap       Normal
:onoremap       Operator-pending
:noremap!       Insert and Command-line
:inoremap       Insert
:cnoremap       Command-line</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_recursive_mapping">RECURSIVE MAPPING</h4>
<div class="paragraph">
<p>When a mapping triggers itself, it will run forever.  This can be used to
repeat an action an unlimited number of times.
   For example, you have a list of files that contain a version number in the
first line.  You edit these files with "vim *.txt".  You are now editing the
first file.  Define this mapping:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map ,, :s/5.1/5.2/&lt;CR&gt;:wnext&lt;CR&gt;,,</pre>
</div>
</div>
<div class="paragraph">
<p>Now you type ",,".  This triggers the mapping.  It replaces "5.1" with "5.2"
in the first line.  Then it does a ":wnext" to write the file and edit the
next one.  The mapping ends in ",,".  This triggers the same mapping again,
thus doing the substitution, etc.
   This continues until there is an error.  In this case it could be a file
where the substitute command doesn&#8217;t find a match for "5.1".  You can then
make a change to insert "5.1" and continue by typing ",," again.  Or the
":wnext" fails, because you are in the last file in the list.
   When a mapping runs into an error halfway, the rest of the mapping is
discarded.  CTRL-C interrupts the mapping (CTRL-Break on MS-Windows).</p>
</div>
</div>
<div class="sect3">
<h4 id="_delete_a_mapping">DELETE A MAPPING</h4>
<div class="paragraph">
<p>To remove a mapping use the ":unmap" command.  Again, the mode the unmapping
applies to depends on the command used:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:unmap          Normal, Visual and Operator-pending
:vunmap         Visual
:nunmap         Normal
:ounmap         Operator-pending
:unmap!         Insert and Command-line
:iunmap         Insert
:cunmap         Command-line</pre>
</div>
</div>
<div class="paragraph">
<p>There is a trick to define a mapping that works in Normal and Operator-pending
mode, but not in Visual mode.  First define it for all three modes, then
delete it for Visual mode:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map &lt;C-A&gt; /---&gt;&lt;CR&gt;
:vunmap &lt;C-A&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the five characters "&lt;C-A&gt;" stand for the single key CTRL-A.</p>
</div>
<div class="paragraph">
<p>To remove all mappings use the |:mapclear| command.  You can guess the
variations for different modes by now.  Be careful with this command, it can&#8217;t
be undone.</p>
</div>
</div>
<div class="sect3">
<h4 id="_special_characters">SPECIAL CHARACTERS</h4>
<div class="paragraph">
<p>The ":map" command can be followed by another command.  A | character
separates the two commands.  This also means that a | character can&#8217;t be used
inside a map command.  To include one, use &lt;Bar&gt; (five characters).  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map &lt;F8&gt; :write &lt;Bar&gt; !checkin %:S&lt;CR&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The same problem applies to the ":unmap" command, with the addition that you
have to watch out for trailing white space.  These two commands are different:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:unmap a | unmap b
:unmap a| unmap b</pre>
</div>
</div>
<div class="paragraph">
<p>The first command tries to unmap "a ", with a trailing space.</p>
</div>
<div class="paragraph">
<p>When using a space inside a mapping, use &lt;Space&gt; (seven characters):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map &lt;Space&gt; W</pre>
</div>
</div>
<div class="paragraph">
<p>This makes the spacebar move a blank-separated word forward.</p>
</div>
<div class="paragraph">
<p>It is not possible to put a comment directly after a mapping, because the "
character is considered to be part of the mapping.  You can use |", this
starts a new, empty command with a comment.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map &lt;Space&gt; W|     " Use spacebar to move forward a word</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mappings_and_abbreviations">MAPPINGS AND ABBREVIATIONS</h4>
<div class="paragraph">
<p>Abbreviations are a lot like Insert mode mappings.  The arguments are handled
in the same way.  The main difference is the way they are triggered.  An
abbreviation is triggered by typing a non-word character after the word.  A
mapping is triggered when typing the last character.
   Another difference is that the characters you type for an abbreviation are
inserted in the text while you type them.  When the abbreviation is triggered
these characters are deleted and replaced by what the abbreviation produces.
When typing the characters for a mapping, nothing is inserted until you type
the last character that triggers it.  If the 'showcmd' option is set, the
typed characters are displayed in the last line of the Vim window.
   An exception is when a mapping is ambiguous.  Suppose you have done two
mappings:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:imap aa foo
:imap aaa bar</pre>
</div>
</div>
<div class="paragraph">
<p>Now, when you type "aa", Vim doesn&#8217;t know if it should apply the first or the
second mapping.  It waits for another character to be typed.  If it is an "a",
the second mapping is applied and results in "bar".  If it is a space, for
example, the first mapping is applied, resulting in "foo", and then the space
is inserted.</p>
</div>
<div class="paragraph">
<p>ADDITIONALLY&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>The &lt;script&gt; keyword can be used to make a mapping local to a script.  See
|:map-&lt;script&gt;|.</p>
</div>
<div class="paragraph">
<p>The &lt;buffer&gt; keyword can be used to make a mapping local to a specific buffer.
See |:map-&lt;buffer&gt;|</p>
</div>
<div class="paragraph">
<p>The &lt;unique&gt; keyword can be used to make defining a new mapping fail when it
already exists.  Otherwise a new mapping simply overwrites the old one.  See
|:map-&lt;unique&gt;|.</p>
</div>
<div class="paragraph">
<p>To make a key do nothing, map it to &lt;Nop&gt; (five characters).  This will make
the &lt;F7&gt; key do nothing at all:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map &lt;F7&gt; &lt;Nop&gt;| map! &lt;F7&gt; &lt;Nop&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>There must be no space after &lt;Nop&gt;.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_command_line_commands">Defining command-line commands</h3>
<div class="paragraph">
<p>The Vim editor enables you to define your own commands.  You execute these
commands just like any other Command-line mode command.
   To define a command, use the ":command" command, as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:command DeleteFirst 1delete</pre>
</div>
</div>
<div class="paragraph">
<p>Now when you execute the command ":DeleteFirst" Vim executes ":1delete", which
deletes the first line.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
User-defined commands must start with a capital letter.  You cannot
use ":X", ":Next" and ":Print".  The underscore cannot be used!  You
can use digits, but this is discouraged.</pre>
</div>
</div>
<div class="paragraph">
<p>To list the user-defined commands, execute the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:command</pre>
</div>
</div>
<div class="paragraph">
<p>Just like with the builtin commands, the user defined commands can be
abbreviated.  You need to type just enough to distinguish the command from
another.  Command line completion can be used to get the full name.</p>
</div>
<div class="sect3">
<h4 id="_number_of_arguments">NUMBER OF ARGUMENTS</h4>
<div class="paragraph">
<p>User-defined commands can take a series of arguments.  The number of arguments
must be specified by the -nargs option.  For instance, the example
:DeleteFirst command takes no arguments, so you could have defined it as
follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:command -nargs=0 DeleteFirst 1delete</pre>
</div>
</div>
<div class="paragraph">
<p>However, because zero arguments is the default, you do not need to add
"-nargs=0".  The other values of -nargs are as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>-nargs=0        No arguments
-nargs=1        One argument
-nargs=*        Any number of arguments
-nargs=?        Zero or one argument
-nargs=+        One or more arguments</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_the_arguments">USING THE ARGUMENTS</h4>
<div class="paragraph">
<p>Inside the command definition, the arguments are represented by the
&lt;args&gt; keyword.  For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:command -nargs=+ Say :echo "&lt;args&gt;"</pre>
</div>
</div>
<div class="paragraph">
<p>Now when you type &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:Say Hello World</pre>
</div>
</div>
<div class="paragraph">
<p>Vim echoes "Hello World".  However, if you add a double quote, it won&#8217;t work.
For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:Say he said "hello"</pre>
</div>
</div>
<div class="paragraph">
<p>To get special characters turned into a string, properly escaped to use as an
expression, use "&lt;q-args&gt;":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:command -nargs=+ Say :echo &lt;q-args&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Now the above ":Say" command will result in this to be executed:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:echo "he said \"hello\""</pre>
</div>
</div>
<div class="paragraph">
<p>The &lt;f-args&gt; keyword contains the same information as the &lt;args&gt; keyword,
except in a format suitable for use as function call arguments.  For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:command -nargs=* DoIt :call AFunction(&lt;f-args&gt;)
:DoIt a b c</pre>
</div>
</div>
<div class="paragraph">
<p>Executes the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:call AFunction("a", "b", "c")</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_line_range">LINE RANGE</h4>
<div class="paragraph">
<p>Some commands take a range as their argument.  To tell Vim that you are
defining such a command, you need to specify a -range option.  The values for
this option are as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>-range          Range is allowed; default is the current line.
-range=%        Range is allowed; default is the whole file.
-range={count}  Range is allowed; the last number in it is used as a
                single number whose default is {count}.</pre>
</div>
</div>
<div class="paragraph">
<p>When a range is specified, the keywords &lt;line1&gt; and &lt;line2&gt; get the values of
the first and last line in the range.  For example, the following command
defines the SaveIt command, which writes out the specified range to the file
"save_file":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:command -range=% SaveIt :&lt;line1&gt;,&lt;line2&gt;write! save_file</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_other_options">OTHER OPTIONS</h4>
<div class="paragraph">
<p>Some of the other options and keywords are as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>-count={number}         The command can take a count whose default is
                        {number}.  The resulting count can be used
                        through the &lt;count&gt; keyword.
-bang                   You can use a !.  If present, using &lt;bang&gt; will
                        result in a !.
-register               You can specify a register.  (The default is
                        the unnamed register.)
                        The register specification is available as
                        &lt;reg&gt; (a.k.a. &lt;register&gt;).
-complete={type}        Type of command-line completion used.  See
                        |:command-completion| for the list of possible
                        values.
-bar                    The command can be followed by | and another
                        command, or " and a comment.
-buffer                 The command is only available for the current
                        buffer.</pre>
</div>
</div>
<div class="paragraph">
<p>Finally, you have the &lt;lt&gt; keyword.  It stands for the character &lt;.  Use this
to escape the special meaning of the &lt;&gt; items mentioned.</p>
</div>
</div>
<div class="sect3">
<h4 id="_redefining_and_deleting">REDEFINING AND DELETING</h4>
<div class="paragraph">
<p>To redefine the same command use the ! argument:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:command -nargs=+ Say :echo "&lt;args&gt;"
:command! -nargs=+ Say :echo &lt;q-args&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>To delete a user command use ":delcommand".  It takes a single argument, which
is the name of the command.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:delcommand SaveIt</pre>
</div>
</div>
<div class="paragraph">
<p>To delete all the user commands:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:comclear</pre>
</div>
</div>
<div class="paragraph">
<p>Careful, this can&#8217;t be undone!</p>
</div>
<div class="paragraph">
<p>More details about all this in the reference manual: |user-commands|.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_autocommands">Autocommands</h3>
<div class="paragraph">
<p>An autocommand is a command that is executed automatically in response to some
event, such as a file being read or written or a buffer change.  Through the
use of autocommands you can train Vim to edit compressed files, for example.
That is used in the |gzip| plugin.
   Autocommands are very powerful.  Use them with care and they will help you
avoid typing many commands.  Use them carelessly and they will cause a lot of
trouble.</p>
</div>
<div class="paragraph">
<p>Suppose you want to replace a datestamp on the end of a file every time it is
written.  First you define a function:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:function DateInsert()
:  $delete
:  read !date
:endfunction</pre>
</div>
</div>
<div class="paragraph">
<p>You want this function to be called each time, just before a buffer is written
to a file.  This will make that happen:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd BufWritePre *  call DateInsert()</pre>
</div>
</div>
<div class="paragraph">
<p>"BufWritePre" is the event for which this autocommand is triggered: Just
before (pre) writing a buffer to a file.  The "*" is a pattern to match with
the file name.  In this case it matches all files.
   With this command enabled, when you do a ":write", Vim checks for any
matching BufWritePre autocommands and executes them, and then it
performs the ":write".
   The general form of the :autocmd command is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd [group] {events} {file_pattern} [nested] {command}</pre>
</div>
</div>
<div class="paragraph">
<p>The [group] name is optional.  It is used in managing and calling the commands
(more on this later).  The {events} parameter is a list of events (comma
separated) that trigger the command.
   {file_pattern} is a filename, usually with wildcards.  For example, using
"*.txt" makes the autocommand be used for all files whose name end in ".txt".
The optional [nested] flag allows for nesting of autocommands (see below), and
finally, {command} is the command to be executed.</p>
</div>
<div class="sect3">
<h4 id="_events">EVENTS</h4>
<div class="paragraph">
<p>One of the most useful events is BufReadPost.  It is triggered after a new
file is being edited.  It is commonly used to set option values.  For example,
you know that "*.gsm" files are GNU assembly language.  To get the syntax file
right, define this autocommand:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd BufReadPost *.gsm  set filetype=asm</pre>
</div>
</div>
<div class="paragraph">
<p>If Vim is able to detect the type of file, it will set the 'filetype' option
for you.  This triggers the Filetype event.  Use this to do something when a
certain type of file is edited.  For example, to load a list of abbreviations
for text files:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd Filetype text  source ~/.vim/abbrevs.vim</pre>
</div>
</div>
<div class="paragraph">
<p>When starting to edit a new file, you could make Vim insert a skeleton:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd BufNewFile *.[ch]  0read ~/skeletons/skel.c</pre>
</div>
</div>
<div class="paragraph">
<p>See |autocmd-events| for a complete list of events.</p>
</div>
</div>
<div class="sect3">
<h4 id="_patterns">PATTERNS</h4>
<div class="paragraph">
<p>The {file_pattern} argument can actually be a comma-separated list of file
patterns.  For example: "<strong>.c,</strong>.h" matches files ending in ".c" and ".h".
   The usual file wildcards can be used.  Here is a summary of the most often
used ones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Match any character any number of times
?               Match any character once
[abc]           Match the character a, b or c</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Matches a dot
a{b,c}          Matches "ab" and "ac"</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>When the pattern includes a slash (/) Vim will compare directory names.
Without the slash only the last part of a file name is used.  For example,
"<strong>.txt" matches "/home/biep/readme.txt".  The pattern "/home/biep/</strong>" would
also match it.  But "home/foo/*.txt" wouldn&#8217;t.
   When including a slash, Vim matches the pattern against both the full path
of the file ("/home/biep/readme.txt") and the relative path (e.g.,
"biep/readme.txt").</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
When working on a system that uses a backslash as file separator, such
as MS-Windows, you still use forward slashes in autocommands.  This
makes it easier to write the pattern, since a backslash has a special
meaning.  It also makes the autocommands portable.</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_deleting_2">DELETING</h4>
<div class="paragraph">
<p>To delete an autocommand, use the same command as what it was defined with,
but leave out the {command} at the end and use a !.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd! FileWritePre *</pre>
</div>
</div>
<div class="paragraph">
<p>This will delete all autocommands for the "FileWritePre" event that use the
"*" pattern.</p>
</div>
</div>
<div class="sect3">
<h4 id="_listing">LISTING</h4>
<div class="paragraph">
<p>To list all the currently defined autocommands, use this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd</pre>
</div>
</div>
<div class="paragraph">
<p>The list can be very long, especially when filetype detection is used.  To
list only part of the commands, specify the group, event and/or pattern.  For
example, to list all BufNewFile autocommands:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd BufNewFile</pre>
</div>
</div>
<div class="paragraph">
<p>To list all autocommands for the pattern "*.c":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd * *.c</pre>
</div>
</div>
<div class="paragraph">
<p>Using "*" for the event will list all the events.  To list all autocommands
for the cprograms group:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd cprograms</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_groups">GROUPS</h4>
<div class="paragraph">
<p>The {group} item, used when defining an autocommand, groups related autocommands
together.  This can be used to delete all the autocommands in a certain group,
for example.
   When defining several autocommands for a certain group, use the ":augroup"
command.  For example, let&#8217;s define autocommands for C programs:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:augroup cprograms
:  autocmd BufReadPost *.c,*.h :set sw=4 sts=4
:  autocmd BufReadPost *.cpp   :set sw=3 sts=3
:augroup END</pre>
</div>
</div>
<div class="paragraph">
<p>This will do the same as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd cprograms BufReadPost *.c,*.h :set sw=4 sts=4
:autocmd cprograms BufReadPost *.cpp   :set sw=3 sts=3</pre>
</div>
</div>
<div class="paragraph">
<p>To delete all autocommands in the "cprograms" group:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd! cprograms</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_nesting">NESTING</h4>
<div class="paragraph">
<p>Generally, commands executed as the result of an autocommand event will not
trigger any new events.  If you read a file in response to a FileChangedShell
event, it will not trigger the autocommands that would set the syntax, for
example.  To make the events triggered, add the "nested" argument:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd FileChangedShell * nested  edit</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_executing_autocommands">EXECUTING AUTOCOMMANDS</h4>
<div class="paragraph">
<p>It is possible to trigger an autocommand by pretending an event has occurred.
This is useful to have one autocommand trigger another one.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd BufReadPost *.new  execute "doautocmd BufReadPost " . expand("&lt;afile&gt;:r")</pre>
</div>
</div>
<div class="paragraph">
<p>This defines an autocommand that is triggered when a new file has been edited.
The file name must end in ".new".  The ":execute" command uses expression
evaluation to form a new command and execute it.  When editing the file
"tryout.c.new" the executed command will be:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:doautocmd BufReadPost tryout.c</pre>
</div>
</div>
<div class="paragraph">
<p>The expand() function takes the "&lt;afile&gt;" argument, which stands for the file
name the autocommand was executed for, and takes the root of the file name
with ":r".</p>
</div>
<div class="paragraph">
<p>":doautocmd" executes on the current buffer.  The ":doautoall" command works
like "doautocmd" except it executes on all the buffers.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_normal_mode_commands">USING NORMAL MODE COMMANDS</h4>
<div class="paragraph">
<p>The commands executed by an autocommand are Command-line commands.  If you
want to use a Normal mode command, the ":normal" command can be used.
Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd BufReadPost *.log normal G</pre>
</div>
</div>
<div class="paragraph">
<p>This will make the cursor jump to the last line of *.log files when you start
to edit it.
   Using the ":normal" command is a bit tricky.  First of all, make sure its
argument is a complete command, including all the arguments.  When you use "i"
to go to Insert mode, there must also be a &lt;Esc&gt; to leave Insert mode again.
If you use a "/" to start a search pattern, there must be a &lt;CR&gt; to execute
it.
   The ":normal" command uses all the text after it as commands.  Thus there
can be no | and another command following.  To work around this, put the
":normal" command inside an ":execute" command.  This also makes it possible
to pass unprintable characters in a convenient way.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:autocmd BufReadPost *.chg execute "normal ONew entry:\&lt;Esc&gt;" |
        \ 1read !date</pre>
</div>
</div>
<div class="paragraph">
<p>This also shows the use of a backslash to break a long command into more
lines.  This can be used in Vim scripts (not at the command line).</p>
</div>
<div class="paragraph">
<p>When you want the autocommand do something complicated, which involves jumping
around in the file and then returning to the original position, you may want
to restore the view on the file.  See |restore-position| for an example.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ignoring_events">IGNORING EVENTS</h4>
<div class="paragraph">
<p>At times, you will not want to trigger an autocommand.  The 'eventignore'
option contains a list of events that will be totally ignored.  For example,
the following causes events for entering and leaving a window to be ignored:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set eventignore=WinEnter,WinLeave</pre>
</div>
</div>
<div class="paragraph">
<p>To ignore all events, use the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set eventignore=all</pre>
</div>
</div>
<div class="paragraph">
<p>To set it back to the normal behavior, make 'eventignore' empty:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set eventignore=</pre>
</div>
</div>
<div class="paragraph">
<p>Next chapter: |usr_41.txt|  Write a Vim script</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_write_a_vim_script">Write a Vim script</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Vim script language is used for the startup vimrc file, syntax files, and
many other things.  This chapter explains the items that can be used in a Vim
script.  There are a lot of them, thus this is a long chapter.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Introduction</p>
</li>
<li>
<p>Variables</p>
</li>
<li>
<p>Expressions</p>
</li>
<li>
<p>Conditionals</p>
</li>
<li>
<p>Executing an expression</p>
</li>
<li>
<p>Using functions</p>
</li>
<li>
<p>Defining a function</p>
</li>
<li>
<p>Lists and Dictionaries</p>
</li>
<li>
<p>Exceptions</p>
</li>
<li>
<p>Various remarks</p>
</li>
<li>
<p>Writing a plugin</p>
</li>
<li>
<p>Writing a filetype plugin</p>
</li>
<li>
<p>Writing a compiler plugin</p>
</li>
<li>
<p>Writing a plugin that loads quickly</p>
</li>
<li>
<p>Writing library scripts</p>
</li>
<li>
<p>Distributing Vim scripts</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_introduction">Introduction</h3>
<div class="paragraph">
<p>Your first experience with Vim scripts is the vimrc file.  Vim reads it when
it starts up and executes the commands.  You can set options to values you
prefer.  And you can use any colon command in it (commands that start with a
":"; these are sometimes referred to as Ex commands or command-line commands).
   Syntax files are also Vim scripts.  As are files that set options for a
specific file type.  A complicated macro can be defined by a separate Vim
script file.  You can think of other uses yourself.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with a simple example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let i = 1
:while i &lt; 5
:  echo "count is" i
:  let i += 1
:endwhile</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
The ":" characters are not really needed here.  You only need to use
them when you type a command.  In a Vim script file they can be left
out.  We will use them here anyway to make clear these are colon
commands and make them stand out from Normal mode commands.
Note:
You can try out the examples by yanking the lines from the text here
and executing them with :@"</pre>
</div>
</div>
<div class="paragraph">
<p>The output of the example code is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>count is 1
count is 2
count is 3
count is 4</pre>
</div>
</div>
<div class="paragraph">
<p>In the first line the ":let" command assigns a value to a variable.  The
generic form is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let {variable} = {expression}</pre>
</div>
</div>
<div class="paragraph">
<p>In this case the variable name is "i" and the expression is a simple value,
the number one.
   The ":while" command starts a loop.  The generic form is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:while {condition}
:  {statements}
:endwhile</pre>
</div>
</div>
<div class="paragraph">
<p>The statements until the matching ":endwhile" are executed for as long as the
condition is true.  The condition used here is the expression "i &lt; 5".  This
is true when the variable i is smaller than five.
        Note:
        If you happen to write a while loop that keeps on running, you can
        interrupt it by pressing CTRL-C (CTRL-Break on MS-Windows).</p>
</div>
<div class="paragraph">
<p>The ":echo" command prints its arguments.  In this case the string "count is"
and the value of the variable i.  Since i is one, this will print:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>count is 1</pre>
</div>
</div>
<div class="paragraph">
<p>Then there is the ":let i += 1" command.  This does the same thing as
":let i = i + 1".  This adds one to the variable i and assigns the new value
to the same variable.</p>
</div>
<div class="paragraph">
<p>The example was given to explain the commands, but would you really want to
make such a loop, it can be written much more compact:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:for i in range(1, 4)
:  echo "count is" i
:endfor</pre>
</div>
</div>
<div class="paragraph">
<p>We won&#8217;t explain how |:for| and |range()| work until later.  Follow the links
if you are impatient.</p>
</div>
<div class="sect3">
<h4 id="_four_kinds_of_numbers">FOUR KINDS OF NUMBERS</h4>
<div class="paragraph">
<p>Numbers can be decimal, hexadecimal, octal or binary.  A hexadecimal number
starts with "0x" or "0X".  For example "0x1f" is decimal 31.  An octal number
starts with a zero.  "017" is decimal 15.  A binary number starts with "0b" or
"0B".  For example "0b101" is decimal 5.  Careful: don&#8217;t put a zero before a
decimal number, it will be interpreted as an octal number!
   The ":echo" command always prints decimal numbers.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :echo 0x7f 036
&lt;       127 30</pre>
</div>
</div>
<div class="paragraph">
<p>A number is made negative with a minus sign.  This also works for hexadecimal,
octal and binary numbers.  A minus sign is also used for subtraction.  Compare
this with the previous example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :echo 0x7f -036
&lt;       97</pre>
</div>
</div>
<div class="paragraph">
<p>White space in an expression is ignored.  However, it&#8217;s recommended to use it
for separating items, to make the expression easier to read.  For example, to
avoid the confusion with a negative number above, put a space between the
minus sign and the following number:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:echo 0x7f - 036</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_variables">Variables</h3>
<div class="paragraph">
<p>A variable name consists of ASCII letters, digits and the underscore.  It
cannot start with a digit.  Valid variable names are:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        counter
        _aap3
        very_long_variable_name_with_underscores
        FuncLength
====         LENGTH</pre>
</div>
</div>
<div class="paragraph">
<p>Invalid names are "foo+bar" and "6var".
   These variables are global.  To see a list of currently defined variables
use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let</pre>
</div>
</div>
<div class="paragraph">
<p>You can use global variables everywhere.  This also means that when the
variable "count" is used in one script file, it might also be used in another
file.  This leads to confusion at least, and real problems at worst.  To avoid
this, you can use a variable local to a script file by prepending "s:".  For
example, one script contains this code:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let s:count = 1
:while s:count &lt; 5
:  source other.vim
:  let s:count += 1
:endwhile</pre>
</div>
</div>
<div class="paragraph">
<p>Since "s:count" is local to this script, you can be sure that sourcing the
"other.vim" script will not change this variable.  If "other.vim" also uses an
"s:count" variable, it will be a different copy, local to that script.  More
about script-local variables here: |script-variable|.</p>
</div>
<div class="paragraph">
<p>There are more kinds of variables, see |internal-variables|.  The most often
used ones are:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>b:name          variable local to a buffer
w:name          variable local to a window
g:name          global variable (also in a function)
v:name          variable predefined by Vim</pre>
</div>
</div>
<div class="sect3">
<h4 id="_deleting_variables">DELETING VARIABLES</h4>
<div class="paragraph">
<p>Variables take up memory and show up in the output of the ":let" command.  To
delete a variable use the ":unlet" command.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:unlet s:count</pre>
</div>
</div>
<div class="paragraph">
<p>This deletes the script-local variable "s:count" to free up the memory it
uses.  If you are not sure if the variable exists, and don&#8217;t want an error
message when it doesn&#8217;t, append !:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:unlet! s:count</pre>
</div>
</div>
<div class="paragraph">
<p>When a script finishes, the local variables used there will not be
automatically freed.  The next time the script executes, it can still use the
old value.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:if !exists("s:call_count")
:  let s:call_count = 0
:endif
:let s:call_count = s:call_count + 1
:echo "called" s:call_count "times"</pre>
</div>
</div>
<div class="paragraph">
<p>The "exists()" function checks if a variable has already been defined.  Its
argument is the name of the variable you want to check.  Not the variable
itself!  If you would do this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:if !exists(s:call_count)</pre>
</div>
</div>
<div class="paragraph">
<p>Then the value of s:call_count will be used as the name of the variable that
exists() checks.  That&#8217;s not what you want.
   The exclamation mark ! negates a value.  When the value was true, it
becomes false.  When it was false, it becomes true.  You can read it as "not".
Thus "if !exists()" can be read as "if not exists()".
   What Vim calls true is anything that is not zero.  Zero is false.
        Note:
        Vim automatically converts a string to a number when it is looking for
        a number.  When using a string that doesn&#8217;t start with a digit the
        resulting number is zero.  Thus look out for this:
                :if "true"
&lt;       The "true" will be interpreted as a zero, thus as false!</p>
</div>
</div>
<div class="sect3">
<h4 id="_string_variables_and_constants">STRING VARIABLES AND CONSTANTS</h4>
<div class="paragraph">
<p>So far only numbers were used for the variable value.  Strings can be used as
well.  Numbers and strings are the basic types of variables that Vim supports.
The type is dynamic, it is set each time when assigning a value to the
variable with ":let".  More about types in |41.8|.
   To assign a string value to a variable, you need to use a string constant.
There are two types of these.  First the string in double quotes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :let name = "peter"
        :echo name
&lt;       peter</pre>
</div>
</div>
<div class="paragraph">
<p>If you want to include a double quote inside the string, put a backslash in
front of it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :let name = "\"peter\""
        :echo name
&lt;       "peter"</pre>
</div>
</div>
<div class="paragraph">
<p>To avoid the need for a backslash, you can use a string in single quotes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :let name = '"peter"'
        :echo name
&lt;       "peter"</pre>
</div>
</div>
<div class="paragraph">
<p>Inside a single-quote string all the characters are as they are.  Only the
single quote itself is special: you need to use two to get one.  A backslash
is taken literally, thus you can&#8217;t use it to change the meaning of the
character after it.
   In double-quote strings it is possible to use special characters.  Here are
a few useful ones:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>\t              &lt;Tab&gt;
\n              &lt;NL&gt;, line break
\r              &lt;CR&gt;, &lt;Enter&gt;
\e              &lt;Esc&gt;
\b              &lt;BS&gt;, backspace
\"              "
\\              \, backslash
\&lt;Esc&gt;          &lt;Esc&gt;
\&lt;C-W&gt;          CTRL-W</pre>
</div>
</div>
<div class="paragraph">
<p>The last two are just examples.  The  "\&lt;name&gt;" form can be used to include
the special key "name".
   See |expr-quote| for the full list of special items in a string.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_expressions">Expressions</h3>
<div class="paragraph">
<p>Vim has a rich, yet simple way to handle expressions.  You can read the
definition here: |expression-syntax|.  Here we will show the most common
items.
   The numbers, strings and variables mentioned above are expressions by
themselves.  Thus everywhere an expression is expected, you can use a number,
string or variable.  Other basic items in an expression are:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$NAME           environment variable
&amp;name           option
@r              register</pre>
</div>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:echo "The value of 'tabstop' is" &amp;ts
:echo "Your home directory is" $HOME
:if @a &gt; 5</pre>
</div>
</div>
<div class="paragraph">
<p>The &amp;name form can be used to save an option value, set it to a new value,
do something and restore the old value.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let save_ic = &amp;ic
:set noic
:/The Start/,$delete
:let &amp;ic = save_ic</pre>
</div>
</div>
<div class="paragraph">
<p>This makes sure the "The Start" pattern is used with the 'ignorecase' option
off.  Still, it keeps the value that the user had set.  (Another way to do
this would be to add "\C" to the pattern, see |/\C|.)</p>
</div>
<div class="sect3">
<h4 id="_mathematics">MATHEMATICS</h4>
<div class="paragraph">
<p>It becomes more interesting if we combine these basic items.  Let&#8217;s start with
mathematics on numbers:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>a + b           add
a - b           subtract
a * b           multiply
a / b           divide
a % b           modulo</pre>
</div>
</div>
<div class="paragraph">
<p>The usual precedence is used.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :echo 10 + 5 * 2
&lt;       20</pre>
</div>
</div>
<div class="paragraph">
<p>Grouping is done with parentheses.  No surprises here.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :echo (10 + 5) * 2
&lt;       30</pre>
</div>
</div>
<div class="paragraph">
<p>Strings can be concatenated with ".".  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :echo "foo" . "bar"
&lt;       foobar</pre>
</div>
</div>
<div class="paragraph">
<p>When the ":echo" command gets multiple arguments, it separates them with a
space.  In the example the argument is a single expression, thus no space is
inserted.</p>
</div>
<div class="paragraph">
<p>Borrowed from the C language is the conditional expression:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>a ? b : c</pre>
</div>
</div>
<div class="paragraph">
<p>If "a" evaluates to true "b" is used, otherwise "c" is used.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :let i = 4
        :echo i &gt; 5 ? "i is big" : "i is small"
&lt;       i is small</pre>
</div>
</div>
<div class="paragraph">
<p>The three parts of the constructs are always evaluated first, thus you could
see it work as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(a) ? (b) : (c)</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conditionals">Conditionals</h3>
<div class="paragraph">
<p>The ":if" commands executes the following statements, until the matching
":endif", only when a condition is met.  The generic form is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:if {condition}
   {statements}
:endif</pre>
</div>
</div>
<div class="paragraph">
<p>Only when the expression {condition} evaluates to true (non-zero) will the
{statements} be executed.  These must still be valid commands.  If they
contain garbage, Vim won&#8217;t be able to find the ":endif".
   You can also use ":else".  The generic form for this is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:if {condition}
   {statements}
:else
   {statements}
:endif</pre>
</div>
</div>
<div class="paragraph">
<p>The second {statements} is only executed if the first one isn&#8217;t.
   Finally, there is ":elseif":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:if {condition}
   {statements}
:elseif {condition}
   {statements}
:endif</pre>
</div>
</div>
<div class="paragraph">
<p>This works just like using ":else" and then "if", but without the need for an
extra ":endif".
   A useful example for your vimrc file is checking the 'term' option and
doing something depending upon its value:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:if &amp;term == "xterm"
:  " Do stuff for xterm
:elseif &amp;term == "vt100"
:  " Do stuff for a vt100 terminal
:else
:  " Do something for other terminals
:endif</pre>
</div>
</div>
<div class="sect3">
<h4 id="_logic_operations">LOGIC OPERATIONS</h4>
<div class="paragraph">
<p>We already used some of them in the examples.  These are the most often used
ones:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>a == b          equal to
a != b          not equal to
a &gt;  b          greater than
a &gt;= b          greater than or equal to
a &lt;  b          less than
a &lt;= b          less than or equal to</pre>
</div>
</div>
<div class="paragraph">
<p>The result is one if the condition is met and zero otherwise.  An example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:if v:version &gt;= 700
:  echo "congratulations"
:else
:  echo "you are using an old version, upgrade!"
:endif</pre>
</div>
</div>
<div class="paragraph">
<p>Here "v:version" is a variable defined by Vim, which has the value of the Vim
version.  600 is for version 6.0.  Version 6.1 has the value 601.  This is
very useful to write a script that works with multiple versions of Vim.
|v:version|</p>
</div>
<div class="paragraph">
<p>The logic operators work both for numbers and strings.  When comparing two
strings, the mathematical difference is used.  This compares byte values,
which may not be right for some languages.
   When comparing a string with a number, the string is first converted to a
number.  This is a bit tricky, because when a string doesn&#8217;t look like a
number, the number zero is used.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:if 0 == "one"
:  echo "yes"
:endif</pre>
</div>
</div>
<div class="paragraph">
<p>This will echo "yes", because "one" doesn&#8217;t look like a number, thus it is
converted to the number zero.</p>
</div>
<div class="paragraph">
<p>For strings there are two more items:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>a =~ b          matches with
a !~ b          does not match with</pre>
</div>
</div>
<div class="paragraph">
<p>The left item "a" is used as a string.  The right item "b" is used as a
pattern, like what&#8217;s used for searching.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:if str =~ " "
:  echo "str contains a space"
:endif
:if str !~ '\.$'
:  echo "str does not end in a full stop"
:endif</pre>
</div>
</div>
<div class="paragraph">
<p>Notice the use of a single-quote string for the pattern.  This is useful,
because backslashes would need to be doubled in a double-quote string and
patterns tend to contain many backslashes.</p>
</div>
<div class="paragraph">
<p>The 'ignorecase' option is used when comparing strings.  When you don&#8217;t want
that, append "<mark>" to match case and "?" to ignore case.  Thus "==?" compares
two strings to be equal while ignoring case.  And "!~</mark>" checks if a pattern
doesn&#8217;t match, also checking the case of letters.  For the full table see
|expr-==|.</p>
</div>
</div>
<div class="sect3">
<h4 id="_more_looping">MORE LOOPING</h4>
<div class="paragraph">
<p>The ":while" command was already mentioned.  Two more statements can be used
in between the ":while" and the ":endwhile":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:continue               Jump back to the start of the while loop; the
                        loop continues.
:break                  Jump forward to the ":endwhile"; the loop is
                        discontinued.</pre>
</div>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:while counter &lt; 40
:  call do_something()
:  if skip_flag
:    continue
:  endif
:  if finished_flag
:    break
:  endif
:  sleep 50m
:endwhile</pre>
</div>
</div>
<div class="paragraph">
<p>The ":sleep" command makes Vim take a nap.  The "50m" specifies fifty
milliseconds.  Another example is ":sleep 4", which sleeps for four seconds.</p>
</div>
<div class="paragraph">
<p>Even more looping can be done with the ":for" command, see below in |41.8|.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_executing_an_expression">Executing an expression</h3>
<div class="paragraph">
<p>So far the commands in the script were executed by Vim directly.  The
":execute" command allows executing the result of an expression.  This is a
very powerful way to build commands and execute them.
   An example is to jump to a tag, which is contained in a variable:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:execute "tag " . tag_name</pre>
</div>
</div>
<div class="paragraph">
<p>The "." is used to concatenate the string "tag " with the value of variable
"tag_name".  Suppose "tag_name" has the value "get_cmd", then the command that
will be executed is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tag get_cmd</pre>
</div>
</div>
<div class="paragraph">
<p>The ":execute" command can only execute colon commands.  The ":normal" command
executes Normal mode commands.  However, its argument is not an expression but
the literal command characters.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:normal gg=G</pre>
</div>
</div>
<div class="paragraph">
<p>This jumps to the first line and formats all lines with the "=" operator.
   To make ":normal" work with an expression, combine ":execute" with it.
Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:execute "normal " . normal_commands</pre>
</div>
</div>
<div class="paragraph">
<p>The variable "normal_commands" must contain the Normal mode commands.
   Make sure that the argument for ":normal" is a complete command.  Otherwise
Vim will run into the end of the argument and abort the command.  For example,
if you start Insert mode, you must leave Insert mode as well.  This works:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:execute "normal Inew text \&lt;Esc&gt;"</pre>
</div>
</div>
<div class="paragraph">
<p>This inserts "new text " in the current line.  Notice the use of the special
key "\&lt;Esc&gt;".  This avoids having to enter a real &lt;Esc&gt; character in your
script.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t want to execute a string but evaluate it to get its expression
value, you can use the eval() function:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let optname = "path"
:let optval = eval('&amp;' . optname)</pre>
</div>
</div>
<div class="paragraph">
<p>A "&amp;" character is prepended to "path", thus the argument to eval() is
"&amp;path".  The result will then be the value of the 'path' option.
   The same thing can be done with:
        :exe 'let optval = &amp;' . optname</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_functions">Using functions</h3>
<div class="paragraph">
<p>Vim defines many functions and provides a large amount of functionality that
way.  A few examples will be given in this section.  You can find the whole
list here: |functions|.</p>
</div>
<div class="paragraph">
<p>A function is called with the ":call" command.  The parameters are passed in
between parentheses separated by commas.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:call search("Date: ", "W")</pre>
</div>
</div>
<div class="paragraph">
<p>This calls the search() function, with arguments "Date: " and "W".  The
search() function uses its first argument as a search pattern and the second
one as flags.  The "W" flag means the search doesn&#8217;t wrap around the end of
the file.</p>
</div>
<div class="paragraph">
<p>A function can be called in an expression.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let line = getline(".")
:let repl = substitute(line, '\a', "*", "g")
:call setline(".", repl)</pre>
</div>
</div>
<div class="paragraph">
<p>The getline() function obtains a line from the current buffer.  Its argument
is a specification of the line number.  In this case "." is used, which means
the line where the cursor is.
   The substitute() function does something similar to the ":substitute"
command.  The first argument is the string on which to perform the
substitution.  The second argument is the pattern, the third the replacement
string.  Finally, the last arguments are the flags.
   The setline() function sets the line, specified by the first argument, to a
new string, the second argument.  In this example the line under the cursor is
replaced with the result of the substitute().  Thus the effect of the three
statements is equal to:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:substitute/\a/*/g</pre>
</div>
</div>
<div class="paragraph">
<p>Using the functions becomes more interesting when you do more work before and
after the substitute() call.</p>
</div>
<div class="paragraph">
<p>FUNCTIONS                                               <strong>function-list</strong></p>
</div>
<div class="paragraph">
<p>There are many functions.  We will mention them here, grouped by what they are
used for.  You can find an alphabetical list here: |functions|.  Use CTRL-] on
the function name to jump to detailed help on it.</p>
</div>
<div class="paragraph">
<p>String manipulation:                                    <strong>string-functions</strong>
        nr2char()               get a character by its number value
        list2str()              get a character string from a list of numbers
        char2nr()               get number value of a character
        str2list()              get list of numbers from a string
        str2nr()                convert a string to a Number
        str2float()             convert a string to a Float
        printf()                format a string according to % items
        escape()                escape characters in a string with a '\'
        shellescape()           escape a string for use with a shell command
        fnameescape()           escape a file name for use with a Vim command
        tr()                    translate characters from one set to another
        strtrans()              translate a string to make it printable
        tolower()               turn a string to lowercase
        toupper()               turn a string to uppercase
        match()                 position where a pattern matches in a string
        matchend()              position where a pattern match ends in a string
        matchstr()              match of a pattern in a string
        matchstrpos()           match and positions of a pattern in a string
        matchlist()             like matchstr() and also return submatches
        stridx()                first index of a short string in a long string
        strridx()               last index of a short string in a long string
        strlen()                length of a string in bytes
        strchars()              length of a string in characters
        strwidth()              size of string when displayed
        strdisplaywidth()       size of string when displayed, deals with tabs
        substitute()            substitute a pattern match with a string
        submatch()              get a specific match in ":s" and substitute()
        strpart()               get part of a string using byte index
        strcharpart()           get part of a string using char index
        strgetchar()            get character from a string using char index
        expand()                expand special keywords
        expandcmd()             expand a command like done for <code>:edit</code>
        iconv()                 convert text from one encoding to another
        byteidx()               byte index of a character in a string
        byteidxcomp()           like byteidx() but count composing characters
        repeat()                repeat a string multiple times
        eval()                  evaluate a string expression
        execute()               execute an Ex command and get the output
        win_execute()           like execute() but in a specified window
        trim()                  trim characters from a string</p>
</div>
<div class="paragraph">
<p>List manipulation:                                      <strong>list-functions</strong>
        get()                   get an item without error for wrong index
        len()                   number of items in a List
        empty()                 check if List is empty
        insert()                insert an item somewhere in a List
        add()                   append an item to a List
        extend()                append a List to a List
        remove()                remove one or more items from a List
        copy()                  make a shallow copy of a List
        deepcopy()              make a full copy of a List
        filter()                remove selected items from a List
        map()                   change each List item
        sort()                  sort a List
        reverse()               reverse the order of a List
        uniq()                  remove copies of repeated adjacent items
        split()                 split a String into a List
        join()                  join List items into a String
        range()                 return a List with a sequence of numbers
        string()                String representation of a List
        call()                  call a function with List as arguments
        index()                 index of a value in a List
        max()                   maximum value in a List
        min()                   minimum value in a List
        count()                 count number of times a value appears in a List
        repeat()                repeat a List multiple times</p>
</div>
<div class="paragraph">
<p>Dictionary manipulation:                                <strong>dict-functions</strong>
        get()                   get an entry without an error for a wrong key
        len()                   number of entries in a Dictionary
        has_key()               check whether a key appears in a Dictionary
        empty()                 check if Dictionary is empty
        remove()                remove an entry from a Dictionary
        extend()                add entries from one Dictionary to another
        filter()                remove selected entries from a Dictionary
        map()                   change each Dictionary entry
        keys()                  get List of Dictionary keys
        values()                get List of Dictionary values
        items()                 get List of Dictionary key-value pairs
        copy()                  make a shallow copy of a Dictionary
        deepcopy()              make a full copy of a Dictionary
        string()                String representation of a Dictionary
        max()                   maximum value in a Dictionary
        min()                   minimum value in a Dictionary
        count()                 count number of times a value appears</p>
</div>
<div class="paragraph">
<p>Floating point computation:                             <strong>float-functions</strong>
        float2nr()              convert Float to Number
        abs()                   absolute value (also works for Number)
        round()                 round off
        ceil()                  round up
        floor()                 round down
        trunc()                 remove value after decimal point
        fmod()                  remainder of division
        exp()                   exponential
        log()                   natural logarithm (logarithm to base e)
        log10()                 logarithm to base 10
        pow()                   value of x to the exponent y
        sqrt()                  square root
        sin()                   sine
        cos()                   cosine
        tan()                   tangent
        asin()                  arc sine
        acos()                  arc cosine
        atan()                  arc tangent
        atan2()                 arc tangent
        sinh()                  hyperbolic sine
        cosh()                  hyperbolic cosine
        tanh()                  hyperbolic tangent
        isnan()                 check for not a number</p>
</div>
<div class="paragraph">
<p>Other computation:                                      <strong>bitwise-function</strong>
        and()                   bitwise AND
        invert()                bitwise invert
        or()                    bitwise OR
        xor()                   bitwise XOR
        sha256()                SHA-256 hash</p>
</div>
<div class="paragraph">
<p>Variables:                                              <strong>var-functions</strong>
        type()                  type of a variable
        islocked()              check if a variable is locked
        funcref()               get a Funcref for a function reference
        function()              get a Funcref for a function name
        getbufvar()             get a variable value from a specific buffer
        setbufvar()             set a variable in a specific buffer
        getwinvar()             get a variable from specific window
        gettabvar()             get a variable from specific tab page
        gettabwinvar()          get a variable from specific window &amp; tab page
        setwinvar()             set a variable in a specific window
        settabvar()             set a variable in a specific tab page
        settabwinvar()          set a variable in a specific window &amp; tab page
        garbagecollect()        possibly free memory</p>
</div>
<div class="paragraph">
<p>Cursor and mark position:               <strong>cursor-functions</strong> <strong>mark-functions</strong>
        col()                   column number of the cursor or a mark
        virtcol()               screen column of the cursor or a mark
        line()                  line number of the cursor or mark
        wincol()                window column number of the cursor
        winline()               window line number of the cursor
        cursor()                position the cursor at a line/column
        screencol()             get screen column of the cursor
        screenrow()             get screen row of the cursor
        screenpos()             screen row and col of a text character
        getcurpos()             get position of the cursor
        getpos()                get position of cursor, mark, etc.
        setpos()                set position of cursor, mark, etc.
        byte2line()             get line number at a specific byte count
        line2byte()             byte count at a specific line
        diff_filler()           get the number of filler lines above a line
        screenattr()            get attribute at a screen line/row
        screenchar()            get character code at a screen line/row
        screenchars()           get character codes at a screen line/row
        screenstring()          get string of characters at a screen line/row</p>
</div>
<div class="paragraph">
<p>Working with text in the current buffer:                <strong>text-functions</strong>
        getline()               get a line or list of lines from the buffer
        setline()               replace a line in the buffer
        append()                append line or list of lines in the buffer
        indent()                indent of a specific line
        cindent()               indent according to C indenting
        lispindent()            indent according to Lisp indenting
        nextnonblank()          find next non-blank line
        prevnonblank()          find previous non-blank line
        search()                find a match for a pattern
        searchpos()             find a match for a pattern
        searchpair()            find the other end of a start/skip/end
        searchpairpos()         find the other end of a start/skip/end
        searchdecl()            search for the declaration of a name
        getcharsearch()         return character search information
        setcharsearch()         set character search information</p>
</div>
<div class="paragraph">
<p>Working with text in another buffer:
        getbufline()            get a list of lines from the specified buffer
        setbufline()            replace a line in the specified buffer
        appendbufline()         append a list of lines in the specified buffer
        deletebufline()         delete lines from a specified buffer</p>
</div>
<div class="paragraph">
<p>System functions and manipulation of files:
        glob()                  expand wildcards
        globpath()              expand wildcards in a number of directories
        glob2regpat()           convert a glob pattern into a search pattern
        findfile()              find a file in a list of directories
        finddir()               find a directory in a list of directories
        resolve()               find out where a shortcut points to
        fnamemodify()           modify a file name
        pathshorten()           shorten directory names in a path
        simplify()              simplify a path without changing its meaning
        executable()            check if an executable program exists
        exepath()               full path of an executable program
        filereadable()          check if a file can be read
        filewritable()          check if a file can be written to
        getfperm()              get the permissions of a file
        setfperm()              set the permissions of a file
        getftype()              get the kind of a file
        isdirectory()           check if a directory exists
        getfsize()              get the size of a file
        getcwd()                get the current working directory
        haslocaldir()           check if current window used |:lcd| or |:tcd|
        tempname()              get the name of a temporary file
        mkdir()                 create a new directory
        chdir()                 change current working directory
        delete()                delete a file
        rename()                rename a file
        system()                get the result of a shell command as a string
        systemlist()            get the result of a shell command as a list
        environ()               get all environment variables
        getenv()                get one environment variable
        setenv()                set an environment variable
        hostname()              name of the system
        readfile()              read a file into a List of lines
        readdir()               get a List of file names in a directory
        writefile()             write a List of lines or Blob into a file</p>
</div>
<div class="paragraph">
<p>Date and Time:                          <strong>date-functions</strong> <strong>time-functions</strong>
        getftime()              get last modification time of a file
        localtime()             get current time in seconds
        strftime()              convert time to a string
        strptime()              convert a date/time string to time
        reltime()               get the current or elapsed time accurately
        reltimestr()            convert reltime() result to a string
        reltimefloat()          convert reltime() result to a Float</p>
</div>
<div class="paragraph">
<p>Buffers, windows and the argument list:
        argc()                  number of entries in the argument list
        argidx()                current position in the argument list
        arglistid()             get id of the argument list
        argv()                  get one entry from the argument list
        bufadd()                add a file to the list of buffers
        bufexists()             check if a buffer exists
        buflisted()             check if a buffer exists and is listed
        bufload()               ensure a buffer is loaded
        bufloaded()             check if a buffer exists and is loaded
        bufname()               get the name of a specific buffer
        bufnr()                 get the buffer number of a specific buffer
        tabpagebuflist()        return List of buffers in a tab page
        tabpagenr()             get the number of a tab page
        tabpagewinnr()          like winnr() for a specified tab page
        winnr()                 get the window number for the current window
        bufwinid()              get the window ID of a specific buffer
        bufwinnr()              get the window number of a specific buffer
        winbufnr()              get the buffer number of a specific window
        listener_add()          add a callback to listen to changes
        listener_flush()        invoke listener callbacks
        listener_remove()       remove a listener callback
        win_findbuf()           find windows containing a buffer
        win_getid()             get window ID of a window
        win_gotoid()            go to window with ID
        win_id2tabwin()         get tab and window nr from window ID
        win_id2win()            get window nr from window ID
        getbufinfo()            get a list with buffer information
        gettabinfo()            get a list with tab page information
        getwininfo()            get a list with window information
        getchangelist()         get a list of change list entries
        getjumplist()           get a list of jump list entries
        swapinfo()              information about a swap file
        swapname()              get the swap file path of a buffer</p>
</div>
<div class="paragraph">
<p>Command line:                                   <strong>command-line-functions</strong>
        getcmdline()            get the current command line
        getcmdpos()             get position of the cursor in the command line
        setcmdpos()             set position of the cursor in the command line
        getcmdtype()            return the current command-line type
        getcmdwintype()         return the current command-line window type
        getcompletion()         list of command-line completion matches</p>
</div>
<div class="paragraph">
<p>Quickfix and location lists:                    <strong>quickfix-functions</strong>
        getqflist()             list of quickfix errors
        setqflist()             modify a quickfix list
        getloclist()            list of location list items
        setloclist()            modify a location list</p>
</div>
<div class="paragraph">
<p>Insert mode completion:                         <strong>completion-functions</strong>
        complete()              set found matches
        complete_add()          add to found matches
        complete_check()        check if completion should be aborted
        complete_info()         get current completion information
        pumvisible()            check if the popup menu is displayed
        pum_getpos()            position and size of popup menu if visible</p>
</div>
<div class="paragraph">
<p>Folding:                                        <strong>folding-functions</strong>
        foldclosed()            check for a closed fold at a specific line
        foldclosedend()         like foldclosed() but return the last line
        foldlevel()             check for the fold level at a specific line
        foldtext()              generate the line displayed for a closed fold
        foldtextresult()        get the text displayed for a closed fold</p>
</div>
<div class="paragraph">
<p>Syntax and highlighting:          <strong>syntax-functions</strong> <strong>highlighting-functions</strong>
        clearmatches()          clear all matches defined by |matchadd()| and
                                the |:match| commands
        getmatches()            get all matches defined by |matchadd()| and
                                the |:match| commands
        hlexists()              check if a highlight group exists
        hlID()                  get ID of a highlight group
        synID()                 get syntax ID at a specific position
        synIDattr()             get a specific attribute of a syntax ID
        synIDtrans()            get translated syntax ID
        synstack()              get list of syntax IDs at a specific position
        synconcealed()          get info about concealing
        diff_hlID()             get highlight ID for diff mode at a position
        matchadd()              define a pattern to highlight (a "match")
        matchaddpos()           define a list of positions to highlight
        matcharg()              get info about |:match| arguments
        matchdelete()           delete a match defined by |matchadd()| or a
                                |:match| command
        setmatches()            restore a list of matches saved by
                                |getmatches()|</p>
</div>
<div class="paragraph">
<p>Spelling:                                       <strong>spell-functions</strong>
        spellbadword()          locate badly spelled word at or after cursor
        spellsuggest()          return suggested spelling corrections
        soundfold()             return the sound-a-like equivalent of a word</p>
</div>
<div class="paragraph">
<p>History:                                        <strong>history-functions</strong>
        histadd()               add an item to a history
        histdel()               delete an item from a history
        histget()               get an item from a history
        histnr()                get highest index of a history list</p>
</div>
<div class="paragraph">
<p>Interactive:                                    <strong>interactive-functions</strong>
        browse()                put up a file requester
        browsedir()             put up a directory requester
        confirm()               let the user make a choice
        getchar()               get a character from the user
        getcharmod()            get modifiers for the last typed character
        getmousepos()           get last known mouse position
        feedkeys()              put characters in the typeahead queue
        input()                 get a line from the user
        inputlist()             let the user pick an entry from a list
        inputsecret()           get a line from the user without showing it
        inputdialog()           get a line from the user in a dialog
        inputsave()             save and clear typeahead
        inputrestore()          restore typeahead</p>
</div>
<div class="paragraph">
<p>GUI:                                            <strong>gui-functions</strong>
        getfontname()           get name of current font being used
        getwinpos()             position of the Vim window
        getwinposx()            X position of the Vim window
        getwinposy()            Y position of the Vim window
        balloon_show()          set the balloon content
        balloon_split()         split a message for a balloon
        balloon_gettext()       get the text in the balloon</p>
</div>
<div class="paragraph">
<p>Vim server:                                     <strong>server-functions</strong>
        serverlist()            return the list of server names
        remote_startserver()    run a server
        remote_send()           send command characters to a Vim server
        remote_expr()           evaluate an expression in a Vim server
        server2client()         send a reply to a client of a Vim server
        remote_peek()           check if there is a reply from a Vim server
        remote_read()           read a reply from a Vim server
        foreground()            move the Vim window to the foreground
        remote_foreground()     move the Vim server window to the foreground</p>
</div>
<div class="paragraph">
<p>Window size and position:                       <strong>window-size-functions</strong>
        winheight()             get height of a specific window
        winwidth()              get width of a specific window
        win_screenpos()         get screen position of a window
        winlayout()             get layout of windows in a tab page
        winrestcmd()            return command to restore window sizes
        winsaveview()           get view of current window
        winrestview()           restore saved view of current window</p>
</div>
<div class="paragraph">
<p>Mappings and Menus:                         <strong>mapping-functions</strong>
        hasmapto()              check if a mapping exists
        mapcheck()              check if a matching mapping exists
        maparg()                get rhs of a mapping
        menu_info()             get information about a menu item
        wildmenumode()          check if the wildmode is active</p>
</div>
<div class="paragraph">
<p>Testing:                                    <strong>test-functions</strong>
        assert_equal()          assert that two expressions values are equal
        assert_equalfile()      assert that two file contents are equal
        assert_notequal()       assert that two expressions values are not equal
        assert_inrange()        assert that an expression is inside a range
        assert_match()          assert that a pattern matches the value
        assert_notmatch()       assert that a pattern does not match the value
        assert_false()          assert that an expression is false
        assert_true()           assert that an expression is true
        assert_exception()      assert that a command throws an exception
        assert_beeps()          assert that a command beeps
        assert_fails()          assert that a command fails
        assert_report()         report a test failure
        test_alloc_fail()       make memory allocation fail
        test_autochdir()        enable 'autochdir' during startup
        test_override()         test with Vim internal overrides
        test_garbagecollect_now()   free memory right now
        test_getvalue()         get value of an internal variable
        test_ignore_error()     ignore a specific error message
        test_null_blob()        return a null Blob
        test_null_channel()     return a null Channel
        test_null_dict()        return a null Dict
        test_null_job()         return a null Job
        test_null_list()        return a null List
        test_null_partial()     return a null Partial function
        test_null_string()      return a null String
        test_settime()          set the time Vim uses internally
        test_setmouse()         set the mouse position
        test_feedinput()        add key sequence to input buffer
        test_option_not_set()   reset flag indicating option was set
        test_scrollbar()        simulate scrollbar movement in the GUI</p>
</div>
<div class="paragraph">
<p>Inter-process communication:                <strong>channel-functions</strong>
        ch_canread()            check if there is something to read
        ch_open()               open a channel
        ch_close()              close a channel
        ch_close_in()           close the in part of a channel
        ch_read()               read a message from a channel
        ch_readblob()           read a Blob from a channel
        ch_readraw()            read a raw message from a channel
        ch_sendexpr()           send a JSON message over a channel
        ch_sendraw()            send a raw message over a channel
        ch_evalexpr()           evaluates an expression over channel
        ch_evalraw()            evaluates a raw string over channel
        ch_status()             get status of a channel
        ch_getbufnr()           get the buffer number of a channel
        ch_getjob()             get the job associated with a channel
        ch_info()               get channel information
        ch_log()                write a message in the channel log file
        ch_logfile()            set the channel log file
        ch_setoptions()         set the options for a channel
        json_encode()           encode an expression to a JSON string
        json_decode()           decode a JSON string to Vim types
        js_encode()             encode an expression to a JSON string
        js_decode()             decode a JSON string to Vim types</p>
</div>
<div class="paragraph">
<p>Jobs:                                           <strong>job-functions</strong>
        job_start()             start a job
        job_stop()              stop a job
        job_status()            get the status of a job
        job_getchannel()        get the channel used by a job
        job_info()              get information about a job
        job_setoptions()        set options for a job</p>
</div>
<div class="paragraph">
<p>Signs:                                          <strong>sign-functions</strong>
        sign_define()           define or update a sign
        sign_getdefined()       get a list of defined signs
        sign_getplaced()        get a list of placed signs
        sign_jump()             jump to a sign
        sign_place()            place a sign
        sign_placelist()        place a list of signs
        sign_undefine()         undefine a sign
        sign_unplace()          unplace a sign
        sign_unplacelist()      unplace a list of signs</p>
</div>
<div class="paragraph">
<p>Terminal window:                                <strong>terminal-functions</strong>
        term_start()            open a terminal window and run a job
        term_list()             get the list of terminal buffers
        term_sendkeys()         send keystrokes to a terminal
        term_wait()             wait for screen to be updated
        term_getjob()           get the job associated with a terminal
        term_scrape()           get row of a terminal screen
        term_getline()          get a line of text from a terminal
        term_getattr()          get the value of attribute {what}
        term_getcursor()        get the cursor position of a terminal
        term_getscrolled()      get the scroll count of a terminal
        term_getaltscreen()     get the alternate screen flag
        term_getsize()          get the size of a terminal
        term_getstatus()        get the status of a terminal
        term_gettitle()         get the title of a terminal
        term_gettty()           get the tty name of a terminal
        term_setansicolors()    set 16 ANSI colors, used for GUI
        term_getansicolors()    get 16 ANSI colors, used for GUI
        term_dumpdiff()         display difference between two screen dumps
        term_dumpload()         load a terminal screen dump in a window
        term_dumpwrite()        dump contents of a terminal screen to a file
        term_setkill()          set signal to stop job in a terminal
        term_setrestore()       set command to restore a terminal
        term_setsize()          set the size of a terminal</p>
</div>
<div class="paragraph">
<p>Popup window:                                   <strong>popup-window-functions</strong>
        popup_create()          create popup centered in the screen
        popup_atcursor()        create popup just above the cursor position,
                                closes when the cursor moves away
        popup_beval()           at the position indicated by v:beval_
                                variables, closes when the mouse moves away
        popup_notification()    show a notification for three seconds
        popup_dialog()          create popup centered with padding and border
        popup_menu()            prompt for selecting an item from a list
        popup_hide()            hide a popup temporarily
        popup_show()            show a previously hidden popup
        popup_move()            change the position and size of a popup
        popup_setoptions()      override options of a popup
        popup_settext()         replace the popup buffer contents
        popup_close()           close one popup
        popup_clear()           close all popups
        popup_filter_menu()     select from a list of items
        popup_filter_yesno()    blocks until 'y' or 'n' is pressed
        popup_getoptions()      get current options for a popup
        popup_getpos()          get actual position and size of a popup</p>
</div>
<div class="paragraph">
<p>Timers:                                         <strong>timer-functions</strong>
        timer_start()           create a timer
        timer_pause()           pause or unpause a timer
        timer_stop()            stop a timer
        timer_stopall()         stop all timers
        timer_info()            get information about timers</p>
</div>
<div class="paragraph">
<p>Tags:                                           <strong>tag-functions</strong>
        taglist()               get list of matching tags
        tagfiles()              get a list of tags files
        gettagstack()           get the tag stack of a window
        settagstack()           modify the tag stack of a window</p>
</div>
<div class="paragraph">
<p>Prompt Buffer:                                  <strong>promptbuffer-functions</strong>
        prompt_setcallback()    set prompt callback for a buffer
        prompt_setinterrupt()   set interrupt callback for a buffer
        prompt_setprompt()      set the prompt text for a buffer</p>
</div>
<div class="paragraph">
<p>Various:                                        <strong>various-functions</strong>
        mode()                  get current editing mode
        visualmode()            last visual mode used
        exists()                check if a variable, function, etc. exists
        has()                   check if a feature is supported in Vim
        changenr()              return number of most recent change
        cscope_connection()     check if a cscope connection exists
        did_filetype()          check if a FileType autocommand was used
        eventhandler()          check if invoked by an event handler
        getpid()                get process ID of Vim</p>
</div>
<div class="literalblock">
<div class="content">
<pre>libcall()               call a function in an external library
libcallnr()             idem, returning a number</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>undofile()              get the name of the undo file
undotree()              return the state of the undo tree</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>getreg()                get contents of a register
getregtype()            get type of a register
setreg()                set contents and type of a register
reg_executing()         return the name of the register being executed
reg_recording()         return the name of the register being recorded</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>shiftwidth()            effective value of 'shiftwidth'</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>wordcount()             get byte/word/char count of buffer</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>luaeval()               evaluate Lua expression
mzeval()                evaluate |MzScheme| expression
perleval()              evaluate Perl expression (|+perl|)
py3eval()               evaluate Python expression (|+python3|)
pyeval()                evaluate Python expression (|+python|)
pyxeval()               evaluate |python_x| expression
debugbreak()            interrupt a program being debugged</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_a_function">Defining a function</h3>
<div class="paragraph">
<p>Vim enables you to define your own functions.  The basic function declaration
begins as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:function {name}({var1}, {var2}, ...)
:  {body}
:endfunction</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
Function names must begin with a capital letter.</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s define a short function to return the smaller of two numbers.  It starts
with this line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:function Min(num1, num2)</pre>
</div>
</div>
<div class="paragraph">
<p>This tells Vim that the function is named "Min" and it takes two arguments:
"num1" and "num2".
   The first thing you need to do is to check to see which number is smaller:
   &gt;
        :  if a:num1 &lt; a:num2</p>
</div>
<div class="paragraph">
<p>The special prefix "a:" tells Vim that the variable is a function argument.
Let&#8217;s assign the variable "smaller" the value of the smallest number:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:  if a:num1 &lt; a:num2
:    let smaller = a:num1
:  else
:    let smaller = a:num2
:  endif</pre>
</div>
</div>
<div class="paragraph">
<p>The variable "smaller" is a local variable.  Variables used inside a function
are local unless prefixed by something like "g:", "a:", or "s:".</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
To access a global variable from inside a function you must prepend
"g:" to it.  Thus "g:today" inside a function is used for the global
variable "today", and "today" is another variable, local to the
function.</pre>
</div>
</div>
<div class="paragraph">
<p>You now use the ":return" statement to return the smallest number to the user.
Finally, you end the function:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:  return smaller
:endfunction</pre>
</div>
</div>
<div class="paragraph">
<p>The complete function definition is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:function Min(num1, num2)
:  if a:num1 &lt; a:num2
:    let smaller = a:num1
:  else
:    let smaller = a:num2
:  endif
:  return smaller
:endfunction</pre>
</div>
</div>
<div class="paragraph">
<p>For people who like short functions, this does the same thing:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:function Min(num1, num2)
:  if a:num1 &lt; a:num2
:    return a:num1
:  endif
:  return a:num2
:endfunction</pre>
</div>
</div>
<div class="paragraph">
<p>A user defined function is called in exactly the same way as a built-in
function.  Only the name is different.  The Min function can be used like
this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:echo Min(5, 8)</pre>
</div>
</div>
<div class="paragraph">
<p>Only now will the function be executed and the lines be interpreted by Vim.
If there are mistakes, like using an undefined variable or function, you will
now get an error message.  When defining the function these errors are not
detected.</p>
</div>
<div class="paragraph">
<p>When a function reaches ":endfunction" or ":return" is used without an
argument, the function returns zero.</p>
</div>
<div class="paragraph">
<p>To redefine a function that already exists, use the ! for the ":function"
command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:function!  Min(num1, num2, num3)</pre>
</div>
</div>
<div class="sect3">
<h4 id="_using_a_range">USING A RANGE</h4>
<div class="paragraph">
<p>The ":call" command can be given a line range.  This can have one of two
meanings.  When a function has been defined with the "range" keyword, it will
take care of the line range itself.
  The function will be passed the variables "a:firstline" and "a:lastline".
These will have the line numbers from the range the function was called with.
Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:function Count_words() range
:  let lnum = a:firstline
:  let n = 0
:  while lnum &lt;= a:lastline
:    let n = n + len(split(getline(lnum)))
:    let lnum = lnum + 1
:  endwhile
:  echo "found " . n . " words"
:endfunction</pre>
</div>
</div>
<div class="paragraph">
<p>You can call this function with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:10,30call Count_words()</pre>
</div>
</div>
<div class="paragraph">
<p>It will be executed once and echo the number of words.
   The other way to use a line range is by defining a function without the
"range" keyword.  The function will be called once for every line in the
range, with the cursor in that line.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:function  Number()
:  echo "line " . line(".") . " contains: " . getline(".")
:endfunction</pre>
</div>
</div>
<div class="paragraph">
<p>If you call this function with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:10,15call Number()</pre>
</div>
</div>
<div class="paragraph">
<p>The function will be called six times.</p>
</div>
</div>
<div class="sect3">
<h4 id="_variable_number_of_arguments">VARIABLE NUMBER OF ARGUMENTS</h4>
<div class="paragraph">
<p>Vim enables you to define functions that have a variable number of arguments.
The following command, for instance, defines a function that must have 1
argument (start) and can have up to 20 additional arguments:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:function Show(start, ...)</pre>
</div>
</div>
<div class="paragraph">
<p>The variable "a:1" contains the first optional argument, "a:2" the second, and
so on.  The variable "a:0" contains the number of extra arguments.
   For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:function Show(start, ...)
:  echohl Title
:  echo "start is " . a:start
:  echohl None
:  let index = 1
:  while index &lt;= a:0
:    echo "  Arg " . index . " is " . a:{index}
:    let index = index + 1
:  endwhile
:  echo ""
:endfunction</pre>
</div>
</div>
<div class="paragraph">
<p>This uses the ":echohl" command to specify the highlighting used for the
following ":echo" command.  ":echohl None" stops it again.  The ":echon"
command works like ":echo", but doesn&#8217;t output a line break.</p>
</div>
<div class="paragraph">
<p>You can also use the a:000 variable, it is a List of all the "&#8230;&#8203;" arguments.
See |a:000|.</p>
</div>
</div>
<div class="sect3">
<h4 id="_listing_functions">LISTING FUNCTIONS</h4>
<div class="paragraph">
<p>The ":function" command lists the names and arguments of all user-defined
functions:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :function
&lt;       function Show(start, ...)
        function GetVimIndent()
        function SetSyn(name)</pre>
</div>
</div>
<div class="paragraph">
<p>To see what a function does, use its name as an argument for ":function":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :function SetSyn
&lt;       1     if &amp;syntax == ''
        2       let &amp;syntax = a:name
        3     endif
           endfunction</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_debugging">DEBUGGING</h4>
<div class="paragraph">
<p>The line number is useful for when you get an error message or when debugging.
See |debug-scripts| about debugging mode.
   You can also set the 'verbose' option to 12 or higher to see all function
calls.  Set it to 15 or higher to see every executed line.</p>
</div>
</div>
<div class="sect3">
<h4 id="_deleting_a_function">DELETING A FUNCTION</h4>
<div class="paragraph">
<p>To delete the Show() function:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:delfunction Show</pre>
</div>
</div>
<div class="paragraph">
<p>You get an error when the function doesn&#8217;t exist.</p>
</div>
</div>
<div class="sect3">
<h4 id="_function_references">FUNCTION REFERENCES</h4>
<div class="paragraph">
<p>Sometimes it can be useful to have a variable point to one function or
another.  You can do it with the function() function.  It turns the name of a
function into a reference:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :let result = 0         " or 1
        :function! Right()
        :  return 'Right!'
        :endfunc
        :function! Wrong()
        :  return 'Wrong!'
        :endfunc
        :
        :if result == 1
        :  let Afunc = function('Right')
        :else
        :  let Afunc = function('Wrong')
        :endif
        :echo call(Afunc, [])
&lt;       Wrong!</pre>
</div>
</div>
<div class="paragraph">
<p>Note that the name of a variable that holds a function reference must start
with a capital.  Otherwise it could be confused with the name of a builtin
function.
   The way to invoke a function that a variable refers to is with the call()
function.  Its first argument is the function reference, the second argument
is a List with arguments.</p>
</div>
<div class="paragraph">
<p>Function references are most useful in combination with a Dictionary, as is
explained in the next section.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lists_and_dictionaries">Lists and Dictionaries</h3>
<div class="paragraph">
<p>So far we have used the basic types String and Number.  Vim also supports two
composite types: List and Dictionary.</p>
</div>
<div class="paragraph">
<p>A List is an ordered sequence of things.  The things can be any kind of value,
thus you can make a List of numbers, a List of Lists and even a List of mixed
items.  To create a List with three strings:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let alist = ['aap', 'mies', 'noot']</pre>
</div>
</div>
<div class="paragraph">
<p>The List items are enclosed in square brackets and separated by commas.  To
create an empty List:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let alist = []</pre>
</div>
</div>
<div class="paragraph">
<p>You can add items to a List with the add() function:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :let alist = []
        :call add(alist, 'foo')
        :call add(alist, 'bar')
        :echo alist
&lt;       ['foo', 'bar']</pre>
</div>
</div>
<div class="paragraph">
<p>List concatenation is done with +:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :echo alist + ['foo', 'bar']
&lt;       ['foo', 'bar', 'foo', 'bar']</pre>
</div>
</div>
<div class="paragraph">
<p>Or, if you want to extend a List directly:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :let alist = ['one']
        :call extend(alist, ['two', 'three'])
        :echo alist
&lt;       ['one', 'two', 'three']</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that using add() will have a different effect:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :let alist = ['one']
        :call add(alist, ['two', 'three'])
        :echo alist
&lt;       ['one', ['two', 'three']]</pre>
</div>
</div>
<div class="paragraph">
<p>The second argument of add() is added as a single item.</p>
</div>
<div class="sect3">
<h4 id="_for_loop">FOR LOOP</h4>
<div class="paragraph">
<p>One of the nice things you can do with a List is iterate over it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :let alist = ['one', 'two', 'three']
        :for n in alist
        :  echo n
        :endfor
&lt;       one
        two
        three</pre>
</div>
</div>
<div class="paragraph">
<p>This will loop over each element in List "alist", assigning the value to
variable "n".  The generic form of a for loop is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:for {varname} in {listexpression}
:  {commands}
:endfor</pre>
</div>
</div>
<div class="paragraph">
<p>To loop a certain number of times you need a List of a specific length.  The
range() function creates one for you:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :for a in range(3)
        :  echo a
        :endfor
&lt;       0
        1
        2</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the first item of the List that range() produces is zero, thus the
last item is one less than the length of the list.
   You can also specify the maximum value, the stride and even go backwards:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :for a in range(8, 4, -2)
        :  echo a
        :endfor
&lt;       8
        6
        4</pre>
</div>
</div>
<div class="paragraph">
<p>A more useful example, looping over lines in the buffer:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:for line in getline(1, 20)
:  if line =~ "Date: "
:    echo matchstr(line, 'Date: \zs.*')
:  endif
:endfor</pre>
</div>
</div>
<div class="paragraph">
<p>This looks into lines 1 to 20 (inclusive) and echoes any date found in there.</p>
</div>
</div>
<div class="sect3">
<h4 id="_dictionaries">DICTIONARIES</h4>
<div class="paragraph">
<p>A Dictionary stores key-value pairs.  You can quickly lookup a value if you
know the key.  A Dictionary is created with curly braces:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can lookup words by putting the key in square brackets:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :echo uk2nl['two']
&lt;       twee</pre>
</div>
</div>
<div class="paragraph">
<p>The generic form for defining a Dictionary is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>{&lt;key&gt; : &lt;value&gt;, ...}</pre>
</div>
</div>
<div class="paragraph">
<p>An empty Dictionary is one without any keys:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>{}</pre>
</div>
</div>
<div class="paragraph">
<p>The possibilities with Dictionaries are numerous.  There are various functions
for them as well.  For example, you can obtain a list of the keys and loop
over them:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :for key in keys(uk2nl)
        :  echo key
        :endfor
&lt;       three
        one
        two</pre>
</div>
</div>
<div class="paragraph">
<p>You will notice the keys are not ordered.  You can sort the list to get a
specific order:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :for key in sort(keys(uk2nl))
        :  echo key
        :endfor
&lt;       one
        three
        two</pre>
</div>
</div>
<div class="paragraph">
<p>But you can never get back the order in which items are defined.  For that you
need to use a List, it stores items in an ordered sequence.</p>
</div>
</div>
<div class="sect3">
<h4 id="_dictionary_functions">DICTIONARY FUNCTIONS</h4>
<div class="paragraph">
<p>The items in a Dictionary can normally be obtained with an index in square
brackets:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :echo uk2nl['one']
&lt;       een</pre>
</div>
</div>
<div class="paragraph">
<p>A method that does the same, but without so many punctuation characters:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :echo uk2nl.one
&lt;       een</pre>
</div>
</div>
<div class="paragraph">
<p>This only works for a key that is made of ASCII letters, digits and the
underscore.  You can also assign a new value this way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :let uk2nl.four = 'vier'
        :echo uk2nl
&lt;       {'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'}</pre>
</div>
</div>
<div class="paragraph">
<p>And now for something special: you can directly define a function and store a
reference to it in the dictionary:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:function uk2nl.translate(line) dict
:  return join(map(split(a:line), 'get(self, v:val, "???")'))
:endfunction</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s first try it out:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :echo uk2nl.translate('three two five one')
&lt;       drie twee ??? een</pre>
</div>
</div>
<div class="paragraph">
<p>The first special thing you notice is the "dict" at the end of the ":function"
line.  This marks the function as being used from a Dictionary.  The "self"
local variable will then refer to that Dictionary.
   Now let&#8217;s break up the complicated return command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>split(a:line)</pre>
</div>
</div>
<div class="paragraph">
<p>The split() function takes a string, chops it into whitespace separated words
and returns a list with these words.  Thus in the example it returns:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :echo split('three two five one')
&lt;       ['three', 'two', 'five', 'one']</pre>
</div>
</div>
<div class="paragraph">
<p>This list is the first argument to the map() function.  This will go through
the list, evaluating its second argument with "v:val" set to the value of each
item.  This is a shortcut to using a for loop.  This command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let alist = map(split(a:line), 'get(self, v:val, "???")')</pre>
</div>
</div>
<div class="paragraph">
<p>Is equivalent to:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let alist = split(a:line)
:for idx in range(len(alist))
:  let alist[idx] = get(self, alist[idx], "???")
:endfor</pre>
</div>
</div>
<div class="paragraph">
<p>The get() function checks if a key is present in a Dictionary.  If it is, then
the value is retrieved.  If it isn&#8217;t, then the default value is returned, in
the example it&#8217;s '???'.  This is a convenient way to handle situations where a
key may not be present and you don&#8217;t want an error message.</p>
</div>
<div class="paragraph">
<p>The join() function does the opposite of split(): it joins together a list of
words, putting a space in between.
  This combination of split(), map() and join() is a nice way to filter a line
of words in a very compact way.</p>
</div>
</div>
<div class="sect3">
<h4 id="_object_oriented_programming">OBJECT ORIENTED PROGRAMMING</h4>
<div class="paragraph">
<p>Now that you can put both values and functions in a Dictionary, you can
actually use a Dictionary like an object.
   Above we used a Dictionary for translating Dutch to English.  We might want
to do the same for other languages.  Let&#8217;s first make an object (aka
Dictionary) that has the translate function, but no words to translate:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let transdict = {}
:function transdict.translate(line) dict
:  return join(map(split(a:line), 'get(self.words, v:val, "???")'))
:endfunction</pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s slightly different from the function above, using 'self.words' to lookup
word translations.  But we don&#8217;t have a self.words.  Thus you could call this
an abstract class.</p>
</div>
<div class="paragraph">
<p>Now we can instantiate a Dutch translation object:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :let uk2nl = copy(transdict)
        :let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}
        :echo uk2nl.translate('three one')
&lt;       drie een</pre>
</div>
</div>
<div class="paragraph">
<p>And a German translator:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :let uk2de = copy(transdict)
        :let uk2de.words = {'one': 'eins', 'two': 'zwei', 'three': 'drei'}
        :echo uk2de.translate('three one')
&lt;       drei eins</pre>
</div>
</div>
<div class="paragraph">
<p>You see that the copy() function is used to make a copy of the "transdict"
Dictionary and then the copy is changed to add the words.  The original
remains the same, of course.</p>
</div>
<div class="paragraph">
<p>Now you can go one step further, and use your preferred translator:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :if $LANG =~ "de"
        :  let trans = uk2de
        :else
        :  let trans = uk2nl
        :endif
        :echo trans.translate('one two three')
&lt;       een twee drie</pre>
</div>
</div>
<div class="paragraph">
<p>Here "trans" refers to one of the two objects (Dictionaries).  No copy is
made.  More about List and Dictionary identity can be found at |list-identity|
and |dict-identity|.</p>
</div>
<div class="paragraph">
<p>Now you might use a language that isn&#8217;t supported.  You can overrule the
translate() function to do nothing:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :let uk2uk = copy(transdict)
        :function! uk2uk.translate(line)
        :  return a:line
        :endfunction
        :echo uk2uk.translate('three one wladiwostok')
&lt;       three one wladiwostok</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that a ! was used to overwrite the existing function reference.  Now
use "uk2uk" when no recognized language is found:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        :if $LANG =~ "de"
        :  let trans = uk2de
        :elseif $LANG =~ "nl"
        :  let trans = uk2nl
        :else
        :  let trans = uk2uk
        :endif
        :echo trans.translate('one two three')
&lt;       one two three</pre>
</div>
</div>
<div class="paragraph">
<p>For further reading see |Lists| and |Dictionaries|.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>Let&#8217;s start with an example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:try
:   read ~/templates/pascal.tmpl
:catch /E484:/
:   echo "Sorry, the Pascal template file cannot be found."
:endtry</pre>
</div>
</div>
<div class="paragraph">
<p>The ":read" command will fail if the file does not exist.  Instead of
generating an error message, this code catches the error and gives the user a
nice message.</p>
</div>
<div class="paragraph">
<p>For the commands in between ":try" and ":endtry" errors are turned into
exceptions.  An exception is a string.  In the case of an error the string
contains the error message.  And every error message has a number.  In this
case, the error we catch contains "E484:".  This number is guaranteed to stay
the same (the text may change, e.g., it may be translated).</p>
</div>
<div class="paragraph">
<p>When the ":read" command causes another error, the pattern "E484:" will not
match in it.  Thus this exception will not be caught and result in the usual
error message.</p>
</div>
<div class="paragraph">
<p>You might be tempted to do this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:try
:   read ~/templates/pascal.tmpl
:catch
:   echo "Sorry, the Pascal template file cannot be found."
:endtry</pre>
</div>
</div>
<div class="paragraph">
<p>This means all errors are caught.  But then you will not see errors that are
useful, such as "E21: Cannot make changes, 'modifiable' is off".</p>
</div>
<div class="paragraph">
<p>Another useful mechanism is the ":finally" command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let tmp = tempname()
:try
:   exe ".,$write " . tmp
:   exe "!filter " . tmp
:   .,$delete
:   exe "$read " . tmp
:finally
:   call delete(tmp)
:endtry</pre>
</div>
</div>
<div class="paragraph">
<p>This filters the lines from the cursor until the end of the file through the
"filter" command, which takes a file name argument.  No matter if the
filtering works, something goes wrong in between ":try" and ":finally" or the
user cancels the filtering by pressing CTRL-C, the "call delete(tmp)" is
always executed.  This makes sure you don&#8217;t leave the temporary file behind.</p>
</div>
<div class="paragraph">
<p>More information about exception handling can be found in the reference
manual: |exception-handling|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_various_remarks">Various remarks</h3>
<div class="paragraph">
<p>Here is a summary of items that apply to Vim scripts.  They are also mentioned
elsewhere, but form a nice checklist.</p>
</div>
<div class="paragraph">
<p>The end-of-line character depends on the system.  For Unix a single &lt;NL&gt;
character is used.  For MS-Windows and the like, &lt;CR&gt;&lt;LF&gt; is used.  This is
important when using mappings that end in a &lt;CR&gt;.  See |:source_crnl|.</p>
</div>
<div class="sect3">
<h4 id="_white_space">WHITE SPACE</h4>
<div class="paragraph">
<p>Blank lines are allowed and ignored.</p>
</div>
<div class="paragraph">
<p>Leading whitespace characters (blanks and TABs) are always ignored.  The
whitespaces between parameters (e.g. between the "set" and the "cpoptions" in
the example below) are reduced to one blank character and plays the role of a
separator, the whitespaces after the last (visible) character may or may not
be ignored depending on the situation, see below.</p>
</div>
<div class="paragraph">
<p>For a ":set" command involving the "=" (equal) sign, such as in:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set cpoptions    =aABceFst</pre>
</div>
</div>
<div class="paragraph">
<p>the whitespace immediately before the "=" sign is ignored.  But there can be
no whitespace after the "=" sign!</p>
</div>
<div class="paragraph">
<p>To include a whitespace character in the value of an option, it must be
escaped by a "\" (backslash)  as in the following example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set tags=my\ nice\ file</pre>
</div>
</div>
<div class="paragraph">
<p>The same example written as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set tags=my nice file</pre>
</div>
</div>
<div class="paragraph">
<p>will issue an error, because it is interpreted as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set tags=my
:set nice
:set file</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_comments">COMMENTS</h4>
<div class="paragraph">
<p>The character " (the double quote mark) starts a comment.  Everything after
and including this character until the end-of-line is considered a comment and
is ignored, except for commands that don&#8217;t consider comments, as shown in
examples below.  A comment can start on any character position on the line.</p>
</div>
<div class="paragraph">
<p>There is a little "catch" with comments for some commands.  Examples:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:abbrev dev development         " shorthand
:map &lt;F3&gt; o#include             " insert include
:execute cmd                    " do it
:!ls *.c                        " list C files</pre>
</div>
</div>
<div class="paragraph">
<p>The abbreviation 'dev' will be expanded to 'development     " shorthand'.  The
mapping of &lt;F3&gt; will actually be the whole line after the 'o# &#8230;&#8203;.' including
the '" insert include'.  The "execute" command will give an error.  The "!"
command will send everything after it to the shell, causing an error for an
unmatched '"' character.
   There can be no comment after ":map", ":abbreviate", ":execute" and "!"
commands (there are a few more commands with this restriction).  For the
":map", ":abbreviate" and ":execute" commands there is a trick:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:abbrev dev development|" shorthand
:map &lt;F3&gt; o#include|" insert include
:execute cmd                    |" do it</pre>
</div>
</div>
<div class="paragraph">
<p>With the '|' character the command is separated from the next one.  And that
next command is only a comment.  For the last command you need to do two
things: |:execute| and use '|':
        :exe '!ls *.c'                  |" list C files</p>
</div>
<div class="paragraph">
<p>Notice that there is no white space before the '|' in the abbreviation and
mapping.  For these commands, any character until the end-of-line or '|' is
included.  As a consequence of this behavior, you don&#8217;t always see that
trailing whitespace is included:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map &lt;F4&gt; o#include</pre>
</div>
</div>
<div class="paragraph">
<p>To spot these problems, you can set the 'list' option when editing vimrc
files.</p>
</div>
<div class="paragraph">
<p>For Unix there is one special way to comment a line, that allows making a Vim
script executable:
        #!/usr/bin/env vim -S
        echo "this is a Vim script"
        quit</p>
</div>
<div class="paragraph">
<p>The "<mark>" command by itself lists a line with the line number.  Adding an
exclamation mark changes it into doing nothing, so that you can add the shell
command to execute the rest of the file. |:</mark>!| |-S|</p>
</div>
</div>
<div class="sect3">
<h4 id="_pitfalls">PITFALLS</h4>
<div class="paragraph">
<p>Even bigger problem arises in the following example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map ,ab o#include
:unmap ,ab</pre>
</div>
</div>
<div class="paragraph">
<p>Here the unmap command will not work, because it tries to unmap ",ab ".  This
does not exist as a mapped sequence.  An error will be issued, which is very
hard to identify, because the ending whitespace character in ":unmap ,ab " is
not visible.</p>
</div>
<div class="paragraph">
<p>And this is the same as what happens when one uses a comment after an 'unmap'
command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:unmap ,ab     " comment</pre>
</div>
</div>
<div class="paragraph">
<p>Here the comment part will be ignored.  However, Vim will try to unmap
',ab     ', which does not exist.  Rewrite it as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:unmap ,ab|    " comment</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_restoring_the_view">RESTORING THE VIEW</h4>
<div class="paragraph">
<p>Sometimes you want to make a change and go back to where the cursor was.
Restoring the relative position would also be nice, so that the same line
appears at the top of the window.
   This example yanks the current line, puts it above the first line in the
file and then restores the view:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>map ,p ma"aYHmbgg"aP`bzt`a</pre>
</div>
</div>
<div class="paragraph">
<p>What this does:
        ma"aYHmbgg"aP`bzt`a
&lt;       ma                      set mark a at cursor position
          "aY                   yank current line into register a
             Hmb                go to top line in window and set mark b there
                gg              go to first line in file
                  "aP           put the yanked line above it
                     `b         go back to top line in display
                       zt       position the text in the window as before
                         `a     go back to saved cursor position</p>
</div>
</div>
<div class="sect3">
<h4 id="_packaging">PACKAGING</h4>
<div class="paragraph">
<p>To avoid your function names to interfere with functions that you get from
others, use this scheme:
- Prepend a unique string before each function name.  I often use an
  abbreviation.  For example, "OW_" is used for the option window functions.
- Put the definition of your functions together in a file.  Set a global
  variable to indicate that the functions have been loaded.  When sourcing the
  file again, first unload the functions.
Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>" This is the XXX package</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>if exists("XXX_loaded")
  delfun XXX_one
  delfun XXX_two
endif</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>function XXX_one(a)
        ... body of function ...
endfun</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>function XXX_two(b)
        ... body of function ...
endfun</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>let XXX_loaded = 1</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_writing_a_plugin">Writing a plugin</h3>
<div class="paragraph">
<p>You can write a Vim script in such a way that many people can use it.  This is
called a plugin.  Vim users can drop your script in their plugin directory and
use its features right away |add-plugin|.</p>
</div>
<div class="paragraph">
<p>There are actually two types of plugins:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  global plugins: For all types of files.
filetype plugins: Only for files of a specific type.</pre>
</div>
</div>
<div class="paragraph">
<p>In this section the first type is explained.  Most items are also relevant for
writing filetype plugins.  The specifics for filetype plugins are in the next
section |write-filetype-plugin|.</p>
</div>
<div class="sect3">
<h4 id="_name">NAME</h4>
<div class="paragraph">
<p>First of all you must choose a name for your plugin.  The features provided
by the plugin should be clear from its name.  And it should be unlikely that
someone else writes a plugin with the same name but which does something
different.  And please limit the name to 8 characters, to avoid problems on
old MS-Windows systems.</p>
</div>
<div class="paragraph">
<p>A script that corrects typing mistakes could be called "typecorr.vim".  We
will use it here as an example.</p>
</div>
<div class="paragraph">
<p>For the plugin to work for everybody, it should follow a few guidelines.  This
will be explained step-by-step.  The complete example plugin is at the end.</p>
</div>
</div>
<div class="sect3">
<h4 id="_body">BODY</h4>
<div class="paragraph">
<p>Let&#8217;s start with the body of the plugin, the lines that do the actual work:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>14     iabbrev teh the
15     iabbrev otehr other
16     iabbrev wnat want
17     iabbrev synchronisation
18             \ synchronization
19     let s:count = 4</pre>
</div>
</div>
<div class="paragraph">
<p>The actual list should be much longer, of course.</p>
</div>
<div class="paragraph">
<p>The line numbers have only been added to explain a few things, don&#8217;t put them
in your plugin file!</p>
</div>
</div>
<div class="sect3">
<h4 id="_header">HEADER</h4>
<div class="paragraph">
<p>You will probably add new corrections to the plugin and soon have several
versions lying around.  And when distributing this file, people will want to
know who wrote this wonderful plugin and where they can send remarks.
Therefore, put a header at the top of your plugin:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>1     " Vim global plugin for correcting typing mistakes
2     " Last Change:  2000 Oct 15
3     " Maintainer:   Bram Moolenaar &lt;Bram@vim.org&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>About copyright and licensing: Since plugins are very useful and it&#8217;s hardly
worth restricting their distribution, please consider making your plugin
either public domain or use the Vim |license|.  A short note about this near
the top of the plugin should be sufficient.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>4     " License:      This file is placed in the public domain.</pre>
</div>
</div>
<div class="paragraph">
<p>LINE CONTINUATION, AVOIDING SIDE EFFECTS                <strong>use-cpo-save</strong></p>
</div>
<div class="paragraph">
<p>In line 18 above, the line-continuation mechanism is used |line-continuation|.
Users with 'compatible' set will run into trouble here, they will get an error
message.  We can&#8217;t just reset 'compatible', because that has a lot of side
effects.  To avoid this, we will set the 'cpoptions' option to its Vim default
value and restore it later.  That will allow the use of line-continuation and
make the script work for most people.  It is done like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>11     let s:save_cpo = &amp;cpo
12     set cpo&amp;vim
..
42     let &amp;cpo = s:save_cpo
43     unlet s:save_cpo</pre>
</div>
</div>
<div class="paragraph">
<p>We first store the old value of 'cpoptions' in the s:save_cpo variable.  At
the end of the plugin this value is restored.</p>
</div>
<div class="paragraph">
<p>Notice that a script-local variable is used |s:var|.  A global variable could
already be in use for something else.  Always use script-local variables for
things that are only used in the script.</p>
</div>
</div>
<div class="sect3">
<h4 id="_not_loading">NOT LOADING</h4>
<div class="paragraph">
<p>It&#8217;s possible that a user doesn&#8217;t always want to load this plugin.  Or the
system administrator has dropped it in the system-wide plugin directory, but a
user has his own plugin he wants to use.  Then the user must have a chance to
disable loading this specific plugin.  This will make it possible:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>6     if exists("g:loaded_typecorr")
7       finish
8     endif
9     let g:loaded_typecorr = 1</pre>
</div>
</div>
<div class="paragraph">
<p>This also avoids that when the script is loaded twice it would cause error
messages for redefining functions and cause trouble for autocommands that are
added twice.</p>
</div>
<div class="paragraph">
<p>The name is recommended to start with "loaded_" and then the file name of the
plugin, literally.  The "g:" is prepended just to avoid mistakes when using
the variable in a function (without "g:" it would be a variable local to the
function).</p>
</div>
<div class="paragraph">
<p>Using "finish" stops Vim from reading the rest of the file, it&#8217;s much quicker
than using if-endif around the whole file.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mapping">MAPPING</h4>
<div class="paragraph">
<p>Now let&#8217;s make the plugin more interesting: We will add a mapping that adds a
correction for the word under the cursor.  We could just pick a key sequence
for this mapping, but the user might already use it for something else.  To
allow the user to define which keys a mapping in a plugin uses, the &lt;Leader&gt;
item can be used:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>22       map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd</pre>
</div>
</div>
<div class="paragraph">
<p>The "&lt;Plug&gt;TypecorrAdd" thing will do the work, more about that further on.</p>
</div>
<div class="paragraph">
<p>The user can set the "mapleader" variable to the key sequence that he wants
this mapping to start with.  Thus if the user has done:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>let mapleader = "_"</pre>
</div>
</div>
<div class="paragraph">
<p>the mapping will define "_a".  If the user didn&#8217;t do this, the default value
will be used, which is a backslash.  Then a map for "\a" will be defined.</p>
</div>
<div class="paragraph">
<p>Note that &lt;unique&gt; is used, this will cause an error message if the mapping
already happened to exist. |:map-&lt;unique&gt;|</p>
</div>
<div class="paragraph">
<p>But what if the user wants to define his own key sequence?  We can allow that
with this mechanism:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>21     if !hasmapto('&lt;Plug&gt;TypecorrAdd')
22       map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd
23     endif</pre>
</div>
</div>
<div class="paragraph">
<p>This checks if a mapping to "&lt;Plug&gt;TypecorrAdd" already exists, and only
defines the mapping from "&lt;Leader&gt;a" if it doesn&#8217;t.  The user then has a
chance of putting this in his vimrc file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>map ,c  &lt;Plug&gt;TypecorrAdd</pre>
</div>
</div>
<div class="paragraph">
<p>Then the mapped key sequence will be ",c" instead of "_a" or "\a".</p>
</div>
</div>
<div class="sect3">
<h4 id="_pieces">PIECES</h4>
<div class="paragraph">
<p>If a script gets longer, you often want to break up the work in pieces.  You
can use functions or mappings for this.  But you don&#8217;t want these functions
and mappings to interfere with the ones from other scripts.  For example, you
could define a function Add(), but another script could try to define the same
function.  To avoid this, we define the function local to the script by
prepending it with "s:".</p>
</div>
<div class="paragraph">
<p>We will define a function that adds a new typing correction:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>30     function s:Add(from, correct)
31       let to = input("type the correction for " . a:from . ": ")
32       exe ":iabbrev " . a:from . " " . to
..
36     endfunction</pre>
</div>
</div>
<div class="paragraph">
<p>Now we can call the function s:Add() from within this script.  If another
script also defines s:Add(), it will be local to that script and can only
be called from the script it was defined in.  There can also be a global Add()
function (without the "s:"), which is again another function.</p>
</div>
<div class="paragraph">
<p>&lt;SID&gt; can be used with mappings.  It generates a script ID, which identifies
the current script.  In our typing correction plugin we use it like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>24     noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd  &lt;SID&gt;Add
..
28     noremap &lt;SID&gt;Add  :call &lt;SID&gt;Add(expand("&lt;cword&gt;"), 1)&lt;CR&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Thus when a user types "\a", this sequence is invoked:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>\a  -&gt;  &lt;Plug&gt;TypecorrAdd  -&gt;  &lt;SID&gt;Add  -&gt;  :call &lt;SID&gt;Add()</pre>
</div>
</div>
<div class="paragraph">
<p>If another script would also map &lt;SID&gt;Add, it would get another script ID and
thus define another mapping.</p>
</div>
<div class="paragraph">
<p>Note that instead of s:Add() we use &lt;SID&gt;Add() here.  That is because the
mapping is typed by the user, thus outside of the script.  The &lt;SID&gt; is
translated to the script ID, so that Vim knows in which script to look for
the Add() function.</p>
</div>
<div class="paragraph">
<p>This is a bit complicated, but it&#8217;s required for the plugin to work together
with other plugins.  The basic rule is that you use &lt;SID&gt;Add() in mappings and
s:Add() in other places (the script itself, autocommands, user commands).</p>
</div>
<div class="paragraph">
<p>We can also add a menu entry to do the same as the mapping:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>26     noremenu &lt;script&gt; Plugin.Add\ Correction      &lt;SID&gt;Add</pre>
</div>
</div>
<div class="paragraph">
<p>The "Plugin" menu is recommended for adding menu items for plugins.  In this
case only one item is used.  When adding more items, creating a submenu is
recommended.  For example, "Plugin.CVS" could be used for a plugin that offers
CVS operations "Plugin.CVS.checkin", "Plugin.CVS.checkout", etc.</p>
</div>
<div class="paragraph">
<p>Note that in line 28 ":noremap" is used to avoid that any other mappings cause
trouble.  Someone may have remapped ":call", for example.  In line 24 we also
use ":noremap", but we do want "&lt;SID&gt;Add" to be remapped.  This is why
"&lt;script&gt;" is used here.  This only allows mappings which are local to the
script. |:map-&lt;script&gt;|  The same is done in line 26 for ":noremenu".
|:menu-&lt;script&gt;|</p>
</div>
<div class="paragraph">
<p>&lt;SID&gt; AND &lt;Plug&gt;                                        <strong>using-&lt;Plug&gt;</strong></p>
</div>
<div class="paragraph">
<p>Both &lt;SID&gt; and &lt;Plug&gt; are used to avoid that mappings of typed keys interfere
with mappings that are only to be used from other mappings.  Note the
difference between using &lt;SID&gt; and &lt;Plug&gt;:</p>
</div>
<div class="paragraph">
<p>&lt;Plug&gt;  is visible outside of the script.  It is used for mappings which the
        user might want to map a key sequence to.  &lt;Plug&gt; is a special code
        that a typed key will never produce.
        To make it very unlikely that other plugins use the same sequence of
        characters, use this structure: &lt;Plug&gt; scriptname mapname
        In our example the scriptname is "Typecorr" and the mapname is "Add".
        This results in "&lt;Plug&gt;TypecorrAdd".  Only the first character of
        scriptname and mapname is uppercase, so that we can see where mapname
        starts.</p>
</div>
<div class="paragraph">
<p>&lt;SID&gt;   is the script ID, a unique identifier for a script.
        Internally Vim translates &lt;SID&gt; to "&lt;SNR&gt;123_", where "123" can be any
        number.  Thus a function "&lt;SID&gt;Add()" will have a name "&lt;SNR&gt;11_Add()"
        in one script, and "&lt;SNR&gt;22_Add()" in another.  You can see this if
        you use the ":function" command to get a list of functions.  The
        translation of &lt;SID&gt; in mappings is exactly the same, that&#8217;s how you
        can call a script-local function from a mapping.</p>
</div>
</div>
<div class="sect3">
<h4 id="_user_command">USER COMMAND</h4>
<div class="paragraph">
<p>Now let&#8217;s add a user command to add a correction:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>38     if !exists(":Correct")
39       command -nargs=1  Correct  :call s:Add(&lt;q-args&gt;, 0)
40     endif</pre>
</div>
</div>
<div class="paragraph">
<p>The user command is defined only if no command with the same name already
exists.  Otherwise we would get an error here.  Overriding the existing user
command with ":command!" is not a good idea, this would probably make the user
wonder why the command he defined himself doesn&#8217;t work.  |:command|</p>
</div>
</div>
<div class="sect3">
<h4 id="_script_variables">SCRIPT VARIABLES</h4>
<div class="paragraph">
<p>When a variable starts with "s:" it is a script variable.  It can only be used
inside a script.  Outside the script it&#8217;s not visible.  This avoids trouble
with using the same variable name in different scripts.  The variables will be
kept as long as Vim is running.  And the same variables are used when sourcing
the same script again. |s:var|</p>
</div>
<div class="paragraph">
<p>The fun is that these variables can also be used in functions, autocommands
and user commands that are defined in the script.  In our example we can add
a few lines to count the number of corrections:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>19     let s:count = 4
..
30     function s:Add(from, correct)
..
34       let s:count = s:count + 1
35       echo s:count . " corrections now"
36     endfunction</pre>
</div>
</div>
<div class="paragraph">
<p>First s:count is initialized to 4 in the script itself.  When later the
s:Add() function is called, it increments s:count.  It doesn&#8217;t matter from
where the function was called, since it has been defined in the script, it
will use the local variables from this script.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_result">THE RESULT</h4>
<div class="paragraph">
<p>Here is the resulting complete example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre> 1     " Vim global plugin for correcting typing mistakes
 2     " Last Change:  2000 Oct 15
 3     " Maintainer:   Bram Moolenaar &lt;Bram@vim.org&gt;
 4     " License:      This file is placed in the public domain.
 5
 6     if exists("g:loaded_typecorr")
 7       finish
 8     endif
 9     let g:loaded_typecorr = 1
10
11     let s:save_cpo = &amp;cpo
12     set cpo&amp;vim
13
14     iabbrev teh the
15     iabbrev otehr other
16     iabbrev wnat want
17     iabbrev synchronisation
18             \ synchronization
19     let s:count = 4
20
21     if !hasmapto('&lt;Plug&gt;TypecorrAdd')
22       map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd
23     endif
24     noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd  &lt;SID&gt;Add
25
26     noremenu &lt;script&gt; Plugin.Add\ Correction      &lt;SID&gt;Add
27
28     noremap &lt;SID&gt;Add  :call &lt;SID&gt;Add(expand("&lt;cword&gt;"), 1)&lt;CR&gt;
29
30     function s:Add(from, correct)
31       let to = input("type the correction for " . a:from . ": ")
32       exe ":iabbrev " . a:from . " " . to
33       if a:correct | exe "normal viws\&lt;C-R&gt;\" \b\e" | endif
34       let s:count = s:count + 1
35       echo s:count . " corrections now"
36     endfunction
37
38     if !exists(":Correct")
39       command -nargs=1  Correct  :call s:Add(&lt;q-args&gt;, 0)
40     endif
41
42     let &amp;cpo = s:save_cpo
43     unlet s:save_cpo</pre>
</div>
</div>
<div class="paragraph">
<p>Line 33 wasn&#8217;t explained yet.  It applies the new correction to the word under
the cursor.  The |:normal| command is used to use the new abbreviation.  Note
that mappings and abbreviations are expanded here, even though the function
was called from a mapping defined with ":noremap".</p>
</div>
<div class="paragraph">
<p>Using "unix" for the 'fileformat' option is recommended.  The Vim scripts will
then work everywhere.  Scripts with 'fileformat' set to "dos" do not work on
Unix.  Also see |:source_crnl|.  To be sure it is set right, do this before
writing the file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set fileformat=unix</pre>
</div>
</div>
<div class="paragraph">
<p>DOCUMENTATION                                           <strong>write-local-help</strong></p>
</div>
<div class="paragraph">
<p>It&#8217;s a good idea to also write some documentation for your plugin.  Especially
when its behavior can be changed by the user.  See |add-local-help| for how
they are installed.</p>
</div>
<div class="paragraph">
<p>Here is a simple example for a plugin help file, called "typecorr.txt":</p>
</div>
<div class="literalblock">
<div class="content">
<pre> 1     *typecorr.txt*  Plugin for correcting typing mistakes
 2
 3     If you make typing mistakes, this plugin will have them corrected
 4     automatically.
 5
 6     There are currently only a few corrections.  Add your own if you like.
 7
 8     Mappings:
 9     &lt;Leader&gt;a   or   &lt;Plug&gt;TypecorrAdd
10             Add a correction for the word under the cursor.
11
12     Commands:
13     :Correct {word}
14             Add a correction for {word}.
15
16                                                     *typecorr-settings*
17     This plugin doesn't have any settings.</pre>
</div>
</div>
<div class="paragraph">
<p>The first line is actually the only one for which the format matters.  It will
be extracted from the help file to be put in the "LOCAL ADDITIONS:" section of
help.txt |local-additions|.  The first "*" must be in the first column of the
first line.  After adding your help file do ":help" and check that the entries
line up nicely.</p>
</div>
<div class="paragraph">
<p>You can add more tags inside ** in your help file.  But be careful not to use
existing help tags.  You would probably use the name of your plugin in most of
them, like "typecorr-settings" in the example.</p>
</div>
<div class="paragraph">
<p>Using references to other parts of the help in || is recommended.  This makes
it easy for the user to find associated help.</p>
</div>
<div class="paragraph">
<p>FILETYPE DETECTION                                      <strong>plugin-filetype</strong></p>
</div>
<div class="paragraph">
<p>If your filetype is not already detected by Vim, you should create a filetype
detection snippet in a separate file.  It is usually in the form of an
autocommand that sets the filetype when the file name matches a pattern.
Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>au BufNewFile,BufRead *.foo                     set filetype=foofoo</pre>
</div>
</div>
<div class="paragraph">
<p>Write this single-line file as "ftdetect/foofoo.vim" in the first directory
that appears in 'runtimepath'.  For Unix that would be
"~/.vim/ftdetect/foofoo.vim".  The convention is to use the name of the
filetype for the script name.</p>
</div>
<div class="paragraph">
<p>You can make more complicated checks if you like, for example to inspect the
contents of the file to recognize the language.  Also see |new-filetype|.</p>
</div>
<div class="paragraph">
<p>SUMMARY                                                 <strong>plugin-special</strong></p>
</div>
<div class="paragraph">
<p>Summary of special things to use in a plugin:</p>
</div>
<div class="paragraph">
<p>s:name                  Variables local to the script.</p>
</div>
<div class="paragraph">
<p>&lt;SID&gt;                   Script-ID, used for mappings and functions local to
                        the script.</p>
</div>
<div class="paragraph">
<p>hasmapto()              Function to test if the user already defined a mapping
                        for functionality the script offers.</p>
</div>
<div class="paragraph">
<p>&lt;Leader&gt;                Value of "mapleader", which the user defines as the
                        keys that plugin mappings start with.</p>
</div>
<div class="paragraph">
<p>:map &lt;unique&gt;           Give a warning if a mapping already exists.</p>
</div>
<div class="paragraph">
<p>:noremap &lt;script&gt;       Use only mappings local to the script, not global
                        mappings.</p>
</div>
<div class="paragraph">
<p>exists(":Cmd")          Check if a user command already exists.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_writing_a_filetype_plugin">Writing a filetype plugin</h3>
<div class="paragraph">
<p>A filetype plugin is like a global plugin, except that it sets options and
defines mappings for the current buffer only.  See |add-filetype-plugin| for
how this type of plugin is used.</p>
</div>
<div class="paragraph">
<p>First read the section on global plugins above |41.11|.  All that is said there
also applies to filetype plugins.  There are a few extras, which are explained
here.  The essential thing is that a filetype plugin should only have an
effect on the current buffer.</p>
</div>
<div class="sect3">
<h4 id="_disabling">DISABLING</h4>
<div class="paragraph">
<p>If you are writing a filetype plugin to be used by many people, they need a
chance to disable loading it.  Put this at the top of the plugin:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1</pre>
</div>
</div>
<div class="paragraph">
<p>This also needs to be used to avoid that the same plugin is executed twice for
the same buffer (happens when using an ":edit" command without arguments).</p>
</div>
<div class="paragraph">
<p>Now users can disable loading the default plugin completely by making a
filetype plugin with only this line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>let b:did_ftplugin = 1</pre>
</div>
</div>
<div class="paragraph">
<p>This does require that the filetype plugin directory comes before $VIMRUNTIME
in 'runtimepath'!</p>
</div>
<div class="paragraph">
<p>If you do want to use the default plugin, but overrule one of the settings,
you can write the different setting in a script:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>setlocal textwidth=70</pre>
</div>
</div>
<div class="paragraph">
<p>Now write this in the "after" directory, so that it gets sourced after the
distributed "vim.vim" ftplugin |after-directory|.  For Unix this would be
"~/.vim/after/ftplugin/vim.vim".  Note that the default plugin will have set
"b:did_ftplugin", but it is ignored here.</p>
</div>
</div>
<div class="sect3">
<h4 id="_options_3">OPTIONS</h4>
<div class="paragraph">
<p>To make sure the filetype plugin only affects the current buffer use the &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:setlocal</pre>
</div>
</div>
<div class="paragraph">
<p>command to set options.  And only set options which are local to a buffer (see
the help for the option to check that).  When using |:setlocal| for global
options or options local to a window, the value will change for many buffers,
and that is not what a filetype plugin should do.</p>
</div>
<div class="paragraph">
<p>When an option has a value that is a list of flags or items, consider using
"+=" and "-=" to keep the existing value.  Be aware that the user may have
changed an option value already.  First resetting to the default value and
then changing it is often a good idea.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:setlocal formatoptions&amp; formatoptions+=ro</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mappings">MAPPINGS</h4>
<div class="paragraph">
<p>To make sure mappings will only work in the current buffer use the &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map &lt;buffer&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>command.  This needs to be combined with the two-step mapping explained above.
An example of how to define functionality in a filetype plugin:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if !hasmapto('&lt;Plug&gt;JavaImport')
  map &lt;buffer&gt; &lt;unique&gt; &lt;LocalLeader&gt;i &lt;Plug&gt;JavaImport
endif
noremap &lt;buffer&gt; &lt;unique&gt; &lt;Plug&gt;JavaImport oimport ""&lt;Left&gt;&lt;Esc&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>|hasmapto()| is used to check if the user has already defined a map to
&lt;Plug&gt;JavaImport.  If not, then the filetype plugin defines the default
mapping.  This starts with |&lt;LocalLeader&gt;|, which allows the user to select
the key(s) he wants filetype plugin mappings to start with.  The default is a
backslash.
"&lt;unique&gt;" is used to give an error message if the mapping already exists or
overlaps with an existing mapping.
|:noremap| is used to avoid that any other mappings that the user has defined
interferes.  You might want to use ":noremap &lt;script&gt;" to allow remapping
mappings defined in this script that start with &lt;SID&gt;.</p>
</div>
<div class="paragraph">
<p>The user must have a chance to disable the mappings in a filetype plugin,
without disabling everything.  Here is an example of how this is done for a
plugin for the mail filetype:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>" Add mappings, unless the user didn't want this.
if !exists("no_plugin_maps") &amp;&amp; !exists("no_mail_maps")
  " Quote text by inserting "&gt; "
  if !hasmapto('&lt;Plug&gt;MailQuote')
    vmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
    nmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote
  endif
  vnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :s/^/&gt; /&lt;CR&gt;
  nnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :.,$s/^/&gt; /&lt;CR&gt;
endif</pre>
</div>
</div>
<div class="paragraph">
<p>Two global variables are used:
|no_plugin_maps|        disables mappings for all filetype plugins
|no_mail_maps|          disables mappings for the "mail" filetype</p>
</div>
</div>
<div class="sect3">
<h4 id="_user_commands">USER COMMANDS</h4>
<div class="paragraph">
<p>To add a user command for a specific file type, so that it can only be used in
one buffer, use the "-buffer" argument to |:command|.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:command -buffer  Make  make %:r.s</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_variables_2">VARIABLES</h4>
<div class="paragraph">
<p>A filetype plugin will be sourced for each buffer of the type it&#8217;s for.  Local
script variables |s:var| will be shared between all invocations.  Use local
buffer variables |b:var| if you want a variable specifically for one buffer.</p>
</div>
</div>
<div class="sect3">
<h4 id="_functions">FUNCTIONS</h4>
<div class="paragraph">
<p>When defining a function, this only needs to be done once.  But the filetype
plugin will be sourced every time a file with this filetype will be opened.
This construct makes sure the function is only defined once:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:if !exists("*s:Func")
:  function s:Func(arg)
:    ...
:  endfunction
:endif</pre>
</div>
</div>
<div class="paragraph">
<p>UNDO                                            <strong>undo_indent</strong> <strong>undo_ftplugin</strong></p>
</div>
<div class="paragraph">
<p>When the user does ":setfiletype xyz" the effect of the previous filetype
should be undone.  Set the b:undo_ftplugin variable to the commands that will
undo the settings in your filetype plugin.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>let b:undo_ftplugin = "setlocal fo&lt; com&lt; tw&lt; commentstring&lt;"
        \ . "| unlet b:match_ignorecase b:match_words b:match_skip"</pre>
</div>
</div>
<div class="paragraph">
<p>Using ":setlocal" with "&lt;" after the option name resets the option to its
global value.  That is mostly the best way to reset the option value.</p>
</div>
<div class="paragraph">
<p>This does require removing the "C" flag from 'cpoptions' to allow line
continuation, as mentioned above |use-cpo-save|.</p>
</div>
<div class="paragraph">
<p>For undoing the effect of an indent script, the b:undo_indent variable should
be set accordingly.</p>
</div>
</div>
<div class="sect3">
<h4 id="_file_name">FILE NAME</h4>
<div class="paragraph">
<p>The filetype must be included in the file name |ftplugin-name|.  Use one of
these three forms:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>.../ftplugin/stuff.vim
.../ftplugin/stuff_foo.vim
.../ftplugin/stuff/bar.vim</pre>
</div>
</div>
<div class="paragraph">
<p>"stuff" is the filetype, "foo" and "bar" are arbitrary names.</p>
</div>
<div class="paragraph">
<p>SUMMARY                                                 <strong>ftplugin-special</strong></p>
</div>
<div class="paragraph">
<p>Summary of special things to use in a filetype plugin:</p>
</div>
<div class="paragraph">
<p>&lt;LocalLeader&gt;           Value of "maplocalleader", which the user defines as
                        the keys that filetype plugin mappings start with.</p>
</div>
<div class="paragraph">
<p>:map &lt;buffer&gt;           Define a mapping local to the buffer.</p>
</div>
<div class="paragraph">
<p>:noremap &lt;script&gt;       Only remap mappings defined in this script that start
                        with &lt;SID&gt;.</p>
</div>
<div class="paragraph">
<p>:setlocal               Set an option for the current buffer only.</p>
</div>
<div class="paragraph">
<p>:command -buffer        Define a user command local to the buffer.</p>
</div>
<div class="paragraph">
<p>exists("*s:Func")       Check if a function was already defined.</p>
</div>
<div class="paragraph">
<p>Also see |plugin-special|, the special things used for all plugins.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_writing_a_compiler_plugin">Writing a compiler plugin</h3>
<div class="paragraph">
<p>A compiler plugin sets options for use with a specific compiler.  The user can
load it with the |:compiler| command.  The main use is to set the
'errorformat' and 'makeprg' options.</p>
</div>
<div class="paragraph">
<p>Easiest is to have a look at examples.  This command will edit all the default
compiler plugins:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:next $VIMRUNTIME/compiler/*.vim</pre>
</div>
</div>
<div class="paragraph">
<p>Use |:next| to go to the next plugin file.</p>
</div>
<div class="paragraph">
<p>There are two special items about these files.  First is a mechanism to allow
a user to overrule or add to the default file.  The default files start with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:if exists("current_compiler")
:  finish
:endif
:let current_compiler = "mine"</pre>
</div>
</div>
<div class="paragraph">
<p>When you write a compiler file and put it in your personal runtime directory
(e.g., ~/.vim/compiler for Unix), you set the "current_compiler" variable to
make the default file skip the settings.</p>
</div>
<div class="paragraph">
<p>The second mechanism is to use ":set" for ":compiler!" and ":setlocal" for
":compiler".  Vim defines the ":CompilerSet" user command for this.  However,
older Vim versions don&#8217;t, thus your plugin should define it then.  This is an
example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if exists(":CompilerSet") != 2
  command -nargs=* CompilerSet setlocal &lt;args&gt;
endif
CompilerSet errorformat&amp;              " use the default 'errorformat'
CompilerSet makeprg=nmake</pre>
</div>
</div>
<div class="paragraph">
<p>When you write a compiler plugin for the Vim distribution or for a system-wide
runtime directory, use the mechanism mentioned above.  When
"current_compiler" was already set by a user plugin nothing will be done.</p>
</div>
<div class="paragraph">
<p>When you write a compiler plugin to overrule settings from a default plugin,
don&#8217;t check "current_compiler".  This plugin is supposed to be loaded
last, thus it should be in a directory at the end of 'runtimepath'.  For Unix
that could be ~/.vim/after/compiler.</p>
</div>
</div>
<div class="sect2">
<h3 id="_writing_a_plugin_that_loads_quickly">Writing a plugin that loads quickly</h3>
<div class="paragraph">
<p>A plugin may grow and become quite long.  The startup delay may become
noticeable, while you hardly ever use the plugin.  Then it&#8217;s time for a
quickload plugin.</p>
</div>
<div class="paragraph">
<p>The basic idea is that the plugin is loaded twice.  The first time user
commands and mappings are defined that offer the functionality.  The second
time the functions that implement the functionality are defined.</p>
</div>
<div class="paragraph">
<p>It may sound surprising that quickload means loading a script twice.  What we
mean is that it loads quickly the first time, postponing the bulk of the
script to the second time, which only happens when you actually use it.  When
you always use the functionality it actually gets slower!</p>
</div>
<div class="paragraph">
<p>Note that since Vim 7 there is an alternative: use the |autoload|
functionality |41.15|.</p>
</div>
<div class="paragraph">
<p>The following example shows how it&#8217;s done:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>" Vim global plugin for demonstrating quick loading
" Last Change:  2005 Feb 25
" Maintainer:   Bram Moolenaar &lt;Bram@vim.org&gt;
" License:      This file is placed in the public domain.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>if !exists("s:did_load")
        command -nargs=* BNRead  call BufNetRead(&lt;f-args&gt;)
        map &lt;F19&gt; :call BufNetWrite('something')&lt;CR&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>        let s:did_load = 1
        exe 'au FuncUndefined BufNet* source ' . expand('&lt;sfile&gt;')
        finish
endif</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>function BufNetRead(...)
        echo 'BufNetRead(' . string(a:000) . ')'
        " read functionality here
endfunction</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>function BufNetWrite(...)
        echo 'BufNetWrite(' . string(a:000) . ')'
        " write functionality here
endfunction</pre>
</div>
</div>
<div class="paragraph">
<p>When the script is first loaded "s:did_load" is not set.  The commands between
the "if" and "endif" will be executed.  This ends in a |:finish| command, thus
the rest of the script is not executed.</p>
</div>
<div class="paragraph">
<p>The second time the script is loaded "s:did_load" exists and the commands
after the "endif" are executed.  This defines the (possible long)
BufNetRead() and BufNetWrite() functions.</p>
</div>
<div class="paragraph">
<p>If you drop this script in your plugin directory Vim will execute it on
startup.  This is the sequence of events that happens:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The "BNRead" command is defined and the &lt;F19&gt; key is mapped when the script
is sourced at startup.  A |FuncUndefined| autocommand is defined.  The
":finish" command causes the script to terminate early.</p>
</li>
<li>
<p>The user types the BNRead command or presses the &lt;F19&gt; key.  The
BufNetRead() or BufNetWrite() function will be called.</p>
</li>
<li>
<p>Vim can&#8217;t find the function and triggers the |FuncUndefined| autocommand
event.  Since the pattern "BufNet*" matches the invoked function, the
command "source fname" will be executed.  "fname" will be equal to the name
of the script, no matter where it is located, because it comes from
expanding "&lt;sfile&gt;" (see |expand()|).</p>
</li>
<li>
<p>The script is sourced again, the "s:did_load" variable exists and the
functions are defined.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Notice that the functions that are loaded afterwards match the pattern in the
|FuncUndefined| autocommand.  You must make sure that no other plugin defines
functions that match this pattern.</p>
</div>
</div>
<div class="sect2">
<h3 id="_writing_library_scripts">Writing library scripts</h3>
<div class="paragraph">
<p>Some functionality will be required in several places.  When this becomes more
than a few lines you will want to put it in one script and use it from many
scripts.  We will call that one script a library script.</p>
</div>
<div class="paragraph">
<p>Manually loading a library script is possible, so long as you avoid loading it
when it&#8217;s already done.  You can do this with the |exists()| function.
Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if !exists('*MyLibFunction')
   runtime library/mylibscript.vim
endif
call MyLibFunction(arg)</pre>
</div>
</div>
<div class="paragraph">
<p>Here you need to know that MyLibFunction() is defined in a script
"library/mylibscript.vim" in one of the directories in 'runtimepath'.</p>
</div>
<div class="paragraph">
<p>To make this a bit simpler Vim offers the autoload mechanism.  Then the
example looks like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>call mylib#myfunction(arg)</pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s a lot simpler, isn&#8217;t it?  Vim will recognize the function name and when
it&#8217;s not defined search for the script "autoload/mylib.vim" in 'runtimepath'.
That script must define the "mylib#myfunction()" function.</p>
</div>
<div class="paragraph">
<p>You can put many other functions in the mylib.vim script, you are free to
organize your functions in library scripts.  But you must use function names
where the part before the '#' matches the script name.  Otherwise Vim would
not know what script to load.</p>
</div>
<div class="paragraph">
<p>If you get really enthusiastic and write lots of library scripts, you may
want to use subdirectories.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>call netlib#ftp#read('somefile')</pre>
</div>
</div>
<div class="paragraph">
<p>For Unix the library script used for this could be:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>~/.vim/autoload/netlib/ftp.vim</pre>
</div>
</div>
<div class="paragraph">
<p>Where the function is defined like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>function netlib#ftp#read(fname)
        "  Read the file fname through ftp
endfunction</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the name the function is defined with is exactly the same as the
name used for calling the function.  And the part before the last '#'
exactly matches the subdirectory and script name.</p>
</div>
<div class="paragraph">
<p>You can use the same mechanism for variables:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>let weekdays = dutch#weekdays</pre>
</div>
</div>
<div class="paragraph">
<p>This will load the script "autoload/dutch.vim", which should contain something
like:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
        \ 'donderdag', 'vrijdag', 'zaterdag']</pre>
</div>
</div>
<div class="paragraph">
<p>Further reading: |autoload|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_distributing_vim_scripts">Distributing Vim scripts</h3>
<div class="paragraph">
<p>Vim users will look for scripts on the Vim website: <a href="http://www.vim.org" class="bare">http://www.vim.org</a>.
If you made something that is useful for others, share it!</p>
</div>
<div class="paragraph">
<p>Vim scripts can be used on any system.  There might not be a tar or gzip
command.  If you want to pack files together and/or compress them the "zip"
utility is recommended.</p>
</div>
<div class="paragraph">
<p>For utmost portability use Vim itself to pack scripts together.  This can be
done with the Vimball utility.  See |vimball|.</p>
</div>
<div class="paragraph">
<p>It&#8217;s good if you add a line to allow automatic updating.  See |glvs-plugins|.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_42.txt|  Add new menus</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_add_new_menus">Add new menus</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By now you know that Vim is very flexible.  This includes the menus used in
the GUI.  You can define your own menu entries to make certain commands easily
accessible.  This is for mouse-happy users only.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Introduction</p>
</li>
<li>
<p>Menu commands</p>
</li>
<li>
<p>Various</p>
</li>
<li>
<p>Toolbar and popup menus</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_introduction_2">Introduction</h3>
<div class="paragraph">
<p>The menus that Vim uses are defined in the file "$VIMRUNTIME/menu.vim".  If
you want to write your own menus, you might first want to look through that
file.
   To define a menu item, use the ":menu" command.  The basic form of this
command is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:menu {menu-item} {keys}</pre>
</div>
</div>
<div class="paragraph">
<p>The {menu-item} describes where on the menu to put the item.  A typical
{menu-item} is "File.Save", which represents the item "Save" under the
"File" menu.  A dot is used to separate the names.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:menu File.Save  :update&lt;CR&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The ":update" command writes the file when it was modified.
   You can add another level: "Edit.Settings.Shiftwidth" defines a submenu
"Settings" under the "Edit" menu, with an item "Shiftwidth".  You could use
even deeper levels.  Don&#8217;t use this too much, you need to move the mouse quite
a bit to use such an item.
   The ":menu" command is very similar to the ":map" command: the left side
specifies how the item is triggered and the right hand side defines the
characters that are executed.  {keys} are characters, they are used just like
you would have typed them.  Thus in Insert mode, when {keys} is plain text,
that text is inserted.</p>
</div>
<div class="sect3">
<h4 id="_accelerators">ACCELERATORS</h4>
<div class="paragraph">
<p>The ampersand character (&amp;) is used to indicate an accelerator.  For instance,
you can use Alt-F to select "File" and S to select "Save".  (The 'winaltkeys'
option may disable this though!).  Therefore, the {menu-item} looks like
"&amp;File.&amp;Save".  The accelerator characters will be underlined in the menu.
   You must take care that each key is used only once in each menu.  Otherwise
you will not know which of the two will actually be used.  Vim doesn&#8217;t warn
you for this.</p>
</div>
</div>
<div class="sect3">
<h4 id="_priorities">PRIORITIES</h4>
<div class="paragraph">
<p>The actual definition of the File.Save menu item is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:menu 10.340 &amp;File.&amp;Save&lt;Tab&gt;:w  :confirm w&lt;CR&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The number 10.340 is called the priority number.  It is used by the editor to
decide where it places the menu item.  The first number (10) indicates the
position on the menu bar.  Lower numbered menus are positioned to the left,
higher numbers to the right.
   These are the priorities used for the standard menus:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>10    20     40     50      60       70               9999</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>+------------------------------------------------------------+
| File  Edit  Tools  Syntax  Buffers  Window            Help |
+------------------------------------------------------------+</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the Help menu is given a very high number, to make it appear on
the far right.
   The second number (340) determines the location of the item within the
pull-down menu.  Lower numbers go on top, higher number on the bottom.  These
are the priorities in the File menu:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>            +-----------------+
10.310      |Open...          |
10.320      |Split-Open...    |
10.325      |New              |
10.330      |Close            |
10.335      |---------------- |
10.340      |Save             |
10.350      |Save As...       |
10.400      |---------------- |
10.410      |Split Diff with  |
10.420      |Split Patched By |
10.500      |---------------- |
10.510      |Print            |
10.600      |---------------- |
10.610      |Save-Exit        |
10.620      |Exit             |
            +-----------------+</pre>
</div>
</div>
<div class="paragraph">
<p>Notice that there is room in between the numbers.  This is where you can
insert your own items, if you really want to (it&#8217;s often better to leave the
standard menus alone and add a new menu for your own items).
   When you create a submenu, you can add another ".number" to the priority.
Thus each name in {menu-item} has its priority number.</p>
</div>
</div>
<div class="sect3">
<h4 id="_special_characters_2">SPECIAL CHARACTERS</h4>
<div class="paragraph">
<p>The {menu-item} in this example is "&amp;File.&amp;Save&lt;Tab&gt;:w".  This brings up an
important point: {menu-item} must be one word.  If you want to put a dot,
space or tabs in the name, you either use the &lt;&gt; notation (&lt;Space&gt; and &lt;Tab&gt;,
for instance) or use the backslash (\) escape. &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:menu 10.305 &amp;File.&amp;Do\ It\.\.\. :exit&lt;CR&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the name of the menu item "Do It&#8230;&#8203;" contains a space and the
command is ":exit&lt;CR&gt;".</p>
</div>
<div class="paragraph">
<p>The &lt;Tab&gt; character in a menu name is used to separate the part that defines
the menu name from the part that gives a hint to the user.  The part after the
&lt;Tab&gt; is displayed right aligned in the menu.  In the File.Save menu the name
used is "&amp;File.&amp;Save&lt;Tab&gt;:w".  Thus the menu name is "File.Save" and the hint
is ":w".</p>
</div>
</div>
<div class="sect3">
<h4 id="_separators">SEPARATORS</h4>
<div class="paragraph">
<p>The separator lines, used to group related menu items together, can be defined
by using a name that starts and ends in a '-'.  For example "-sep-".  When
using several separators the names must be different.  Otherwise the names
don&#8217;t matter.
   The command from a separator will never be executed, but you have to define
one anyway.  A single colon will do.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:amenu 20.510 Edit.-sep3- :</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_menu_commands">Menu commands</h3>
<div class="paragraph">
<p>You can define menu items that exist for only certain modes.  This works just
like the variations on the ":map" command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:menu           Normal, Visual and Operator-pending mode
:nmenu          Normal mode
:vmenu          Visual mode
:omenu          Operator-pending mode
:menu!          Insert and Command-line mode
:imenu          Insert mode
:cmenu          Command-line mode
:tlmenu         Terminal mode
:amenu          All modes (except for Terminal mode)</pre>
</div>
</div>
<div class="paragraph">
<p>To avoid that the commands of a menu item are being mapped, use the command
":noremenu", ":nnoremenu", ":anoremenu", etc.</p>
</div>
<div class="paragraph">
<p>USING :AMENU</p>
</div>
<div class="paragraph">
<p>The ":amenu" command is a bit different.  It assumes that the {keys} you
give are to be executed in Normal mode.  When Vim is in Visual or Insert mode
when the menu is used, Vim first has to go back to Normal mode.  ":amenu"
inserts a CTRL-C or CTRL-O for you.  For example, if you use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:amenu  90.100 Mine.Find\ Word  *</pre>
</div>
</div>
<div class="paragraph">
<p>Then the resulting menu commands will be:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Normal mode:            *
Visual mode:            CTRL-C *
Operator-pending mode:  CTRL-C *
Insert mode:            CTRL-O *
Command-line mode:      CTRL-C *</pre>
</div>
</div>
<div class="paragraph">
<p>When in Command-line mode the CTRL-C will abandon the command typed so far.
In Visual and Operator-pending mode CTRL-C will stop the mode.  The CTRL-O in
Insert mode will execute the command and then return to Insert mode.
   CTRL-O only works for one command.  If you need to use two or more
commands, put them in a function and call that function.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:amenu  Mine.Next\ File  :call &lt;SID&gt;NextFile()&lt;CR&gt;
:function &lt;SID&gt;NextFile()
:  next
:  1/^Code
:endfunction</pre>
</div>
</div>
<div class="paragraph">
<p>This menu entry goes to the next file in the argument list with ":next".  Then
it searches for the line that starts with "Code".
   The &lt;SID&gt; before the function name is the script ID.  This makes the
function local to the current Vim script file.  This avoids problems when a
function with the same name is defined in another script file.  See |&lt;SID&gt;|.</p>
</div>
<div class="sect3">
<h4 id="_silent_menus">SILENT MENUS</h4>
<div class="paragraph">
<p>The menu executes the {keys} as if you typed them.  For a ":" command this
means you will see the command being echoed on the command line.  If it&#8217;s a
long command, the hit-Enter prompt will appear.  That can be very annoying!
   To avoid this, make the menu silent.  This is done with the &lt;silent&gt;
argument.  For example, take the call to NextFile() in the previous example.
When you use this menu, you will see this on the command line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:call &lt;SNR&gt;34_NextFile()</pre>
</div>
</div>
<div class="paragraph">
<p>To avoid this text on the command line, insert "&lt;silent&gt;" as the first
argument:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:amenu &lt;silent&gt; Mine.Next\ File :call &lt;SID&gt;NextFile()&lt;CR&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t use "&lt;silent&gt;" too often.  It is not needed for short commands.  If you
make a menu for someone else, being able the see the executed command will
give him a hint about what he could have typed, instead of using the mouse.</p>
</div>
</div>
<div class="sect3">
<h4 id="_listing_menus">LISTING MENUS</h4>
<div class="paragraph">
<p>When a menu command is used without a {keys} part, it lists the already
defined menus.  You can specify a {menu-item}, or part of it, to list specific
menus.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:amenu</pre>
</div>
</div>
<div class="paragraph">
<p>This lists all menus.  That&#8217;s a long list!  Better specify the name of a menu
to get a shorter list:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:amenu Edit</pre>
</div>
</div>
<div class="paragraph">
<p>This lists only the "Edit" menu items for all modes.  To list only one
specific menu item for Insert mode:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:imenu Edit.Undo</pre>
</div>
</div>
<div class="paragraph">
<p>Take care that you type exactly the right name.  Case matters here.  But the
'&amp;' for accelerators can be omitted.  The &lt;Tab&gt; and what comes after it can be
left out as well.</p>
</div>
</div>
<div class="sect3">
<h4 id="_deleting_menus">DELETING MENUS</h4>
<div class="paragraph">
<p>To delete a menu, the same command is used as for listing, but with "menu"
changed to "unmenu".  Thus ":menu" becomes, ":unmenu", ":nmenu" becomes
":nunmenu", etc.  To delete the "Tools.Make" item for Insert mode:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:iunmenu Tools.Make</pre>
</div>
</div>
<div class="paragraph">
<p>You can delete a whole menu, with all its items, by using the menu name.
Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:aunmenu Syntax</pre>
</div>
</div>
<div class="paragraph">
<p>This deletes the Syntax menu and all the items in it.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_various_3">Various</h3>
<div class="paragraph">
<p>You can change the appearance of the menus with flags in 'guioptions'.  In the
default value they are all included, except "M".  You can remove a flag with a
command like:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set guioptions-=m</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>m               When removed the menubar is not displayed.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>M               When added the default menus are not loaded.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>g               When removed the inactive menu items are not made grey
                but are completely removed.  (Does not work on all
                systems.)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>t               When removed the tearoff feature is not enabled.</pre>
</div>
</div>
<div class="paragraph">
<p>The dotted line at the top of a menu is not a separator line.  When you select
this item, the menu is "teared-off": It is displayed in a separate window.
This is called a tearoff menu.  This is useful when you use the same menu
often.</p>
</div>
<div class="paragraph">
<p>For translating menu items, see |:menutrans|.</p>
</div>
<div class="paragraph">
<p>Since the mouse has to be used to select a menu item, it is a good idea to use
the ":browse" command for selecting a file.  And ":confirm" to get a dialog
instead of an error message, e.g., when the current buffer contains changes.
These two can be combined:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:amenu File.Open  :browse confirm edit&lt;CR&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The ":browse" makes a file browser appear to select the file to edit.  The
":confirm" will pop up a dialog when the current buffer has changes.  You can
then select to save the changes, throw them away or cancel the command.
   For more complicated items, the confirm() and inputdialog() functions can
be used.  The default menus contain a few examples.</p>
</div>
</div>
<div class="sect2">
<h3 id="_toolbar_and_popup_menus">Toolbar and popup menus</h3>
<div class="paragraph">
<p>There are two special menus: ToolBar and PopUp.  Items that start with these
names do not appear in the normal menu bar.</p>
</div>
<div class="sect3">
<h4 id="_toolbar">TOOLBAR</h4>
<div class="paragraph">
<p>The toolbar appears only when the "T" flag is included in the 'guioptions'
option.
   The toolbar uses icons rather than text to represent the command.  For
example, the {menu-item} named "ToolBar.New" causes the "New" icon to appear
on the toolbar.
   The Vim editor has 28 built-in icons.  You can find a table here:
|builtin-tools|.  Most of them are used in the default toolbar.  You can
redefine what these items do (after the default menus are setup).
   You can add another bitmap for a toolbar item.  Or define a new toolbar
item with a bitmap.  For example, define a new toolbar item with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tmenu ToolBar.Compile  Compile the current file
:amenu ToolBar.Compile  :!cc %:S -o %:r:S&lt;CR&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Now you need to create the icon.  For MS-Windows it must be in bitmap format,
with the name "Compile.bmp".  For Unix XPM format is used, the file name is
"Compile.xpm".  The size must be 18 by 18 pixels.  On MS-Windows other sizes
can be used as well, but it will look ugly.
   Put the bitmap in the directory "bitmaps" in one of the directories from
'runtimepath'.  E.g., for Unix "~/.vim/bitmaps/Compile.xpm".</p>
</div>
<div class="paragraph">
<p>You can define tooltips for the items in the toolbar.  A tooltip is a short
text that explains what a toolbar item will do.  For example "Open file".  It
appears when the mouse pointer is on the item, without moving for a moment.
This is very useful if the meaning of the picture isn&#8217;t that obvious.
Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tmenu ToolBar.Make  Run make in the current directory</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
Pay attention to the case used.  "Toolbar" and "toolbar" are different
from "ToolBar"!</pre>
</div>
</div>
<div class="paragraph">
<p>To remove a tooltip, use the |:tunmenu| command.</p>
</div>
<div class="paragraph">
<p>The 'toolbar' option can be used to display text instead of a bitmap, or both
text and a bitmap.  Most people use just the bitmap, since the text takes
quite a bit of space.</p>
</div>
</div>
<div class="sect3">
<h4 id="_popup_menu">POPUP MENU</h4>
<div class="paragraph">
<p>The popup menu pops up where the mouse pointer is.  On MS-Windows you activate
it by clicking the right mouse button.  Then you can select an item with the
left mouse button.  On Unix the popup menu is used by pressing and holding the
right mouse button.
   The popup menu only appears when the 'mousemodel' has been set to "popup"
or "popup_setpos".  The difference between the two is that "popup_setpos"
moves the cursor to the mouse pointer position.  When clicking inside a
selection, the selection will be used unmodified.  When there is a selection
but you click outside of it, the selection is removed.
   There is a separate popup menu for each mode.  Thus there are never grey
items like in the normal menus.</p>
</div>
<div class="paragraph">
<p>What is the meaning of life, the universe and everything?  <strong>42</strong>
Douglas Adams, the only person who knew what this question really was about is
now dead, unfortunately.  So now you might wonder what the meaning of death
is&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_43.txt|  Using filetypes</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_filetypes">Using filetypes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When you are editing a file of a certain type, for example a C program or a
shell script, you often use the same option settings and mappings.  You
quickly get tired of manually setting these each time.  This chapter explains
how to do it automatically.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Plugins for a filetype</p>
</li>
<li>
<p>Adding a filetype</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_plugins_for_a_filetype">Plugins for a filetype</h3>
<div class="paragraph">
<p>How to start using filetype plugins has already been discussed here:
|add-filetype-plugin|.  But you probably are not satisfied with the default
settings, because they have been kept minimal.  Suppose that for C files you
want to set the 'softtabstop' option to 4 and define a mapping to insert a
three-line comment.  You do this with only two steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create your own runtime directory.  On Unix this usually is "~/.vim".  In
this directory create the "ftplugin" directory:</p>
<div class="literalblock">
<div class="content">
<pre>mkdir ~/.vim
mkdir ~/.vim/ftplugin</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>When you are not on Unix, check the value of the 'runtimepath' option to
see where Vim will look for the "ftplugin" directory:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>set runtimepath</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>You would normally use the first directory name (before the first comma).
You might want to prepend a directory name to the 'runtimepath' option in
your |vimrc| file if you don't like the default value.</pre>
</div>
</div>
</li>
<li>
<p>Create the file "~/.vim/ftplugin/c.vim", with the contents:</p>
<div class="literalblock">
<div class="content">
<pre>setlocal softtabstop=4
noremap &lt;buffer&gt; &lt;LocalLeader&gt;c o/**************&lt;CR&gt;&lt;CR&gt;/&lt;Esc&gt;
let b:undo_ftplugin = "setl softtabstop&lt; | unmap &lt;buffer&gt; &lt;LocalLeader&gt;c"</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Try editing a C file.  You should notice that the 'softtabstop' option is set
to 4.  But when you edit another file it&#8217;s reset to the default zero.  That is
because the ":setlocal" command was used.  This sets the 'softtabstop' option
only locally to the buffer.  As soon as you edit another buffer, it will be
set to the value set for that buffer.  For a new buffer it will get the
default value or the value from the last ":set" command.</p>
</div>
<div class="paragraph">
<p>Likewise, the mapping for "\c" will disappear when editing another buffer.
The ":map &lt;buffer&gt;" command creates a mapping that is local to the current
buffer.  This works with any mapping command: ":map!", ":vmap", etc.  The
|&lt;LocalLeader&gt;| in the mapping is replaced with the value of the
"maplocalleader" variable.</p>
</div>
<div class="paragraph">
<p>The line to set b:undo_ftplugin is for when the filetype is set to another
value.  In that case you will want to undo your preferences.  The
b:undo_ftplugin variable is executed as a command. Watch out for characters
with a special meaning inside a string, such as a backslash.</p>
</div>
<div class="paragraph">
<p>You can find examples for filetype plugins in this directory:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$VIMRUNTIME/ftplugin/</pre>
</div>
</div>
<div class="paragraph">
<p>More details about writing a filetype plugin can be found here:
|write-plugin|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_a_filetype">Adding a filetype</h3>
<div class="paragraph">
<p>If you are using a type of file that is not recognized by Vim, this is how to
get it recognized.  You need a runtime directory of your own.  See
|your-runtime-dir| above.</p>
</div>
<div class="paragraph">
<p>Create a file "filetype.vim" which contains an autocommand for your filetype.
(Autocommands were explained in section |40.3|.)  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>augroup filetypedetect
au BufNewFile,BufRead *.xyz     setf xyz
augroup END</pre>
</div>
</div>
<div class="paragraph">
<p>This will recognize all files that end in ".xyz" as the "xyz" filetype.  The
":augroup" commands put this autocommand in the "filetypedetect" group.  This
allows removing all autocommands for filetype detection when doing ":filetype
off".  The "setf" command will set the 'filetype' option to its argument,
unless it was set already.  This will make sure that 'filetype' isn&#8217;t set
twice.</p>
</div>
<div class="paragraph">
<p>You can use many different patterns to match the name of your file.  Directory
names can also be included.  See |autocmd-patterns|.  For example, the files
under "/usr/share/scripts/" are all "ruby" files, but don&#8217;t have the expected
file name extension.  Adding this to the example above:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>augroup filetypedetect
au BufNewFile,BufRead *.xyz                     setf xyz
au BufNewFile,BufRead /usr/share/scripts/*      setf ruby
augroup END</pre>
</div>
</div>
<div class="paragraph">
<p>However, if you now edit a file /usr/share/scripts/README.txt, this is not a
ruby file.  The danger of a pattern ending in "*" is that it quickly matches
too many files.  To avoid trouble with this, put the filetype.vim file in
another directory, one that is at the end of 'runtimepath'.  For Unix for
example, you could use "~/.vim/after/filetype.vim".
   You now put the detection of text files in ~/.vim/filetype.vim:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>augroup filetypedetect
au BufNewFile,BufRead *.txt                     setf text
augroup END</pre>
</div>
</div>
<div class="paragraph">
<p>That file is found in 'runtimepath' first.  Then use this in
~/.vim/after/filetype.vim, which is found last:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>augroup filetypedetect
au BufNewFile,BufRead /usr/share/scripts/*      setf ruby
augroup END</pre>
</div>
</div>
<div class="paragraph">
<p>What will happen now is that Vim searches for "filetype.vim" files in each
directory in 'runtimepath'.  First ~/.vim/filetype.vim is found.  The
autocommand to catch *.txt files is defined there.  Then Vim finds the
filetype.vim file in $VIMRUNTIME, which is halfway 'runtimepath'.  Finally
~/.vim/after/filetype.vim is found and the autocommand for detecting ruby
files in /usr/share/scripts is added.
   When you now edit /usr/share/scripts/README.txt, the autocommands are
checked in the order in which they were defined.  The *.txt pattern matches,
thus "setf text" is executed to set the filetype to "text".  The pattern for
ruby matches too, and the "setf ruby" is executed.  But since 'filetype' was
already set to "text", nothing happens here.
   When you edit the file /usr/share/scripts/foobar the same autocommands are
checked.  Only the one for ruby matches and "setf ruby" sets 'filetype' to
ruby.</p>
</div>
<div class="sect3">
<h4 id="_recognizing_by_contents">RECOGNIZING BY CONTENTS</h4>
<div class="paragraph">
<p>If your file cannot be recognized by its file name, you might be able to
recognize it by its contents.  For example, many script files start with a
line like:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#!/bin/xyz</pre>
</div>
</div>
<div class="paragraph">
<p>To recognize this script create a file "scripts.vim" in your runtime directory
(same place where filetype.vim goes).  It might look like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if did_filetype()
  finish
endif
if getline(1) =~ '^#!.*[/\\]xyz\&gt;'
  setf xyz
endif</pre>
</div>
</div>
<div class="paragraph">
<p>The first check with did_filetype() is to avoid that you will check the
contents of files for which the filetype was already detected by the file
name.  That avoids wasting time on checking the file when the "setf" command
won&#8217;t do anything.
   The scripts.vim file is sourced by an autocommand in the default
filetype.vim file.  Therefore, the order of checks is:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>filetype.vim files before $VIMRUNTIME in 'runtimepath'</p>
</li>
<li>
<p>first part of $VIMRUNTIME/filetype.vim</p>
</li>
<li>
<p>all scripts.vim files in 'runtimepath'</p>
</li>
<li>
<p>remainder of $VIMRUNTIME/filetype.vim</p>
</li>
<li>
<p>filetype.vim files after $VIMRUNTIME in 'runtimepath'</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If this is not sufficient for you, add an autocommand that matches all files
and sources a script or executes a function to check the contents of the file.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_44.txt|  Your own syntax highlighted</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_your_own_syntax_highlighted">Your own syntax highlighted</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vim comes with highlighting for a couple of hundred different file types.  If
the file you are editing isn&#8217;t included, read this chapter to find out how to
get this type of file highlighted.  Also see |:syn-define| in the reference
manual.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Basic syntax commands</p>
</li>
<li>
<p>Keywords</p>
</li>
<li>
<p>Matches</p>
</li>
<li>
<p>Regions</p>
</li>
<li>
<p>Nested items</p>
</li>
<li>
<p>Following groups</p>
</li>
<li>
<p>Other arguments</p>
</li>
<li>
<p>Clusters</p>
</li>
<li>
<p>Including another syntax file</p>
</li>
<li>
<p>Synchronizing</p>
</li>
<li>
<p>Installing a syntax file</p>
</li>
<li>
<p>Portable syntax file layout</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_basic_syntax_commands">Basic syntax commands</h3>
<div class="paragraph">
<p>Using an existing syntax file to start with will save you a lot of time.  Try
finding a syntax file in $VIMRUNTIME/syntax for a language that is similar.
These files will also show you the normal layout of a syntax file.  To
understand it, you need to read the following.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with the basic arguments.  Before we start defining any new
syntax, we need to clear out any old definitions:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax clear</pre>
</div>
</div>
<div class="paragraph">
<p>This isn&#8217;t required in the final syntax file, but very useful when
experimenting.</p>
</div>
<div class="paragraph">
<p>There are more simplifications in this chapter.  If you are writing a syntax
file to be used by others, read all the way through the end to find out the
details.</p>
</div>
<div class="sect3">
<h4 id="_listing_defined_items">LISTING DEFINED ITEMS</h4>
<div class="paragraph">
<p>To check which syntax items are currently defined, use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax</pre>
</div>
</div>
<div class="paragraph">
<p>You can use this to check which items have actually been defined.  Quite
useful when you are experimenting with a new syntax file.  It also shows the
colors used for each item, which helps to find out what is what.
   To list the items in a specific syntax group use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax list {group-name}</pre>
</div>
</div>
<div class="paragraph">
<p>This also can be used to list clusters (explained in |44.8|).  Just include
the @ in the name.</p>
</div>
</div>
<div class="sect3">
<h4 id="_matching_case">MATCHING CASE</h4>
<div class="paragraph">
<p>Some languages are not case sensitive, such as Pascal.  Others, such as C, are
case sensitive.  You need to tell which type you have with the following
commands:
        :syntax case match
        :syntax case ignore</p>
</div>
<div class="paragraph">
<p>The "match" argument means that Vim will match the case of syntax elements.
Therefore, "int" differs from "Int" and "INT".  If the "ignore" argument is
used, the following are equivalent: "Procedure", "PROCEDURE" and "procedure".
   The ":syntax case" commands can appear anywhere in a syntax file and affect
the syntax definitions that follow.  In most cases, you have only one ":syntax
case" command in your syntax file; if you work with an unusual language that
contains both case-sensitive and non-case-sensitive elements, however, you can
scatter the ":syntax case" command throughout the file.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_keywords_2">Keywords</h3>
<div class="paragraph">
<p>The most basic syntax elements are keywords.  To define a keyword, use the
following form:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax keyword {group} {keyword} ...</pre>
</div>
</div>
<div class="paragraph">
<p>The {group} is the name of a syntax group.  With the ":highlight" command you
can assign colors to a {group}.  The {keyword} argument is an actual keyword.
Here are a few examples:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax keyword xType int long char
:syntax keyword xStatement if then else endif</pre>
</div>
</div>
<div class="paragraph">
<p>This example uses the group names "xType" and "xStatement".  By convention,
each group name is prefixed by the filetype for the language being defined.
This example defines syntax for the x language (eXample language without an
interesting name).  In a syntax file for "csh" scripts the name "cshType"
would be used.  Thus the prefix is equal to the value of 'filetype'.
   These commands cause the words "int", "long" and "char" to be highlighted
one way and the words "if", "then", "else" and "endif" to be highlighted
another way.  Now you need to connect the x group names to standard Vim
names.  You do this with the following commands:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:highlight link xType Type
:highlight link xStatement Statement</pre>
</div>
</div>
<div class="paragraph">
<p>This tells Vim to highlight "xType" like "Type" and "xStatement" like
"Statement".  See |group-name| for the standard names.</p>
</div>
<div class="sect3">
<h4 id="_unusual_keywords">UNUSUAL KEYWORDS</h4>
<div class="paragraph">
<p>The characters used in a keyword must be in the 'iskeyword' option.  If you
use another character, the word will never match.  Vim doesn&#8217;t give a warning
message for this.
   The x language uses the '-' character in keywords.  This is how it&#8217;s done:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:setlocal iskeyword+=-
:syntax keyword xStatement when-not</pre>
</div>
</div>
<div class="paragraph">
<p>The ":setlocal" command is used to change 'iskeyword' only for the current
buffer.  Still it does change the behavior of commands like "w" and "*".  If
that is not wanted, don&#8217;t define a keyword but use a match (explained in the
next section).</p>
</div>
<div class="paragraph">
<p>The x language allows for abbreviations.  For example, "next" can be
abbreviated to "n", "ne" or "nex".  You can define them by using this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax keyword xStatement n[ext]</pre>
</div>
</div>
<div class="paragraph">
<p>This doesn&#8217;t match "nextone", keywords always match whole words only.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_matches">Matches</h3>
<div class="paragraph">
<p>Consider defining something a bit more complex.  You want to match ordinary
identifiers.  To do this, you define a match syntax item.  This one matches
any word consisting of only lowercase letters:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax match xIdentifier /\&lt;\l\+\&gt;/</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
Keywords overrule any other syntax item.  Thus the keywords "if",
"then", etc., will be keywords, as defined with the ":syntax keyword"
commands above, even though they also match the pattern for
xIdentifier.</pre>
</div>
</div>
<div class="paragraph">
<p>The part at the end is a pattern, like it&#8217;s used for searching.  The // is
used to surround the pattern (like how it&#8217;s done in a ":substitute" command).
You can use any other character, like a plus or a quote.</p>
</div>
<div class="paragraph">
<p>Now define a match for a comment.  In the x language it is anything from # to
the end of a line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax match xComment /#.*/</pre>
</div>
</div>
<div class="paragraph">
<p>Since you can use any search pattern, you can highlight very complex things
with a match item.  See |pattern| for help on search patterns.</p>
</div>
</div>
<div class="sect2">
<h3 id="_regions">Regions</h3>
<div class="paragraph">
<p>In the example x language, strings are enclosed in double quotation marks (").
To highlight strings you define a region.  You need a region start (double
quote) and a region end (double quote).  The definition is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax region xString start=/"/ end=/"/</pre>
</div>
</div>
<div class="paragraph">
<p>The "start" and "end" directives define the patterns used to find the start
and end of the region.  But what about strings that look like this?</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"A string with a double quote (\") in it"</pre>
</div>
</div>
<div class="paragraph">
<p>This creates a problem: The double quotation marks in the middle of the string
will end the region.  You need to tell Vim to skip over any escaped double
quotes in the string.  Do this with the skip keyword:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax region xString start=/"/ skip=/\\"/ end=/"/</pre>
</div>
</div>
<div class="paragraph">
<p>The double backslash matches a single backslash, since the backslash is a
special character in search patterns.</p>
</div>
<div class="paragraph">
<p>When to use a region instead of a match?  The main difference is that a match
item is a single pattern, which must match as a whole.  A region starts as
soon as the "start" pattern matches.  Whether the "end" pattern is found or
not doesn&#8217;t matter.  Thus when the item depends on the "end" pattern to match,
you cannot use a region.  Otherwise, regions are often simpler to define.  And
it is easier to use nested items, as is explained in the next section.</p>
</div>
</div>
<div class="sect2">
<h3 id="_nested_items">Nested items</h3>
<div class="paragraph">
<p>Take a look at this comment:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>%Get input  TODO: Skip white space</pre>
</div>
</div>
<div class="paragraph">
<p>You want to highlight TODO in big yellow letters, even though it is in a
comment that is highlighted blue.  To let Vim know about this, you define the
following syntax groups:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax keyword xTodo TODO contained
:syntax match xComment /%.*/ contains=xTodo</pre>
</div>
</div>
<div class="paragraph">
<p>In the first line, the "contained" argument tells Vim that this keyword can
exist only inside another syntax item.  The next line has "contains=xTodo".
This indicates that the xTodo syntax element is inside it.  The result is that
the comment line as a whole is matched with "xComment" and made blue.  The
word TODO inside it is matched by xTodo and highlighted yellow (highlighting
for xTodo was setup for this).</p>
</div>
<div class="sect3">
<h4 id="_recursive_nesting">RECURSIVE NESTING</h4>
<div class="paragraph">
<p>The x language defines code blocks in curly braces.  And a code block may
contain other code blocks.  This can be defined this way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax region xBlock start=/{/ end=/}/ contains=xBlock</pre>
</div>
</div>
<div class="paragraph">
<p>Suppose you have this text:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>while i &lt; b {
        if a {
                b = c;
        }
}</pre>
</div>
</div>
<div class="paragraph">
<p>First a xBlock starts at the { in the first line.  In the second line another
{ is found.  Since we are inside a xBlock item, and it contains itself, a
nested xBlock item will start here.  Thus the "b = c" line is inside the
second level xBlock region.  Then a } is found in the next line, which matches
with the end pattern of the region.  This ends the nested xBlock.  Because the
} is included in the nested region, it is hidden from the first xBlock region.
Then at the last } the first xBlock region ends.</p>
</div>
</div>
<div class="sect3">
<h4 id="_keeping_the_end">KEEPING THE END</h4>
<div class="paragraph">
<p>Consider the following two syntax items:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax region xComment start=/%/ end=/$/ contained
:syntax region xPreProc start=/#/ end=/$/ contains=xComment</pre>
</div>
</div>
<div class="paragraph">
<p>You define a comment as anything from % to the end of the line.  A
preprocessor directive is anything from # to the end of the line.  Because you
can have a comment on a preprocessor line, the preprocessor definition
includes a "contains=xComment" argument.  Now look what happens with this
text:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#define X = Y  % Comment text
int foo = 1;</pre>
</div>
</div>
<div class="paragraph">
<p>What you see is that the second line is also highlighted as xPreProc.  The
preprocessor directive should end at the end of the line.  That is why
you have used "end=/$/".  So what is going wrong?
   The problem is the contained comment.  The comment starts with % and ends
at the end of the line.  After the comment ends, the preprocessor syntax
continues.  This is after the end of the line has been seen, so the next
line is included as well.
   To avoid this problem and to avoid a contained syntax item eating a needed
end of line, use the "keepend" argument.  This takes care of
the double end-of-line matching:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax region xComment start=/%/ end=/$/ contained
:syntax region xPreProc start=/#/ end=/$/ contains=xComment keepend</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_containing_many_items">CONTAINING MANY ITEMS</h4>
<div class="paragraph">
<p>You can use the contains argument to specify that everything can be contained.
For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax region xList start=/\[/ end=/\]/ contains=ALL</pre>
</div>
</div>
<div class="paragraph">
<p>All syntax items will be contained in this one.  It also contains itself, but
not at the same position (that would cause an endless loop).
   You can specify that some groups are not contained.  Thus contain all
groups but the ones that are listed:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax region xList start=/\[/ end=/\]/ contains=ALLBUT,xString</pre>
</div>
</div>
<div class="paragraph">
<p>With the "TOP" item you can include all items that don&#8217;t have a "contained"
argument.  "CONTAINED" is used to only include items with a "contained"
argument.  See |:syn-contains| for the details.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_following_groups">Following groups</h3>
<div class="paragraph">
<p>The x language has statements in this form:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if (condition) then</pre>
</div>
</div>
<div class="paragraph">
<p>You want to highlight the three items differently.  But "(condition)" and
"then" might also appear in other places, where they get different
highlighting.  This is how you can do this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax match xIf /if/ nextgroup=xIfCondition skipwhite
:syntax match xIfCondition /([^)]*)/ contained nextgroup=xThen skipwhite
:syntax match xThen /then/ contained</pre>
</div>
</div>
<div class="paragraph">
<p>The "nextgroup" argument specifies which item can come next.  This is not
required.  If none of the items that are specified are found, nothing happens.
For example, in this text:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if not (condition) then</pre>
</div>
</div>
<div class="paragraph">
<p>The "if" is matched by xIf.  "not" doesn&#8217;t match the specified nextgroup
xIfCondition, thus only the "if" is highlighted.</p>
</div>
<div class="paragraph">
<p>The "skipwhite" argument tells Vim that white space (spaces and tabs) may
appear in between the items.  Similar arguments are "skipnl", which allows a
line break in between the items, and "skipempty", which allows empty lines.
Notice that "skipnl" doesn&#8217;t skip an empty line, something must match after
the line break.</p>
</div>
</div>
<div class="sect2">
<h3 id="_other_arguments">Other arguments</h3>
<div class="sect3">
<h4 id="_matchgroup">MATCHGROUP</h4>
<div class="paragraph">
<p>When you define a region, the entire region is highlighted according to the
group name specified.  To highlight the text enclosed in parentheses () with
the group xInside, for example, use the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax region xInside start=/(/ end=/)/</pre>
</div>
</div>
<div class="paragraph">
<p>Suppose, that you want to highlight the parentheses differently.  You can do
this with a lot of convoluted region statements, or you can use the
"matchgroup" argument.  This tells Vim to highlight the start and end of a
region with a different highlight group (in this case, the xParen group):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax region xInside matchgroup=xParen start=/(/ end=/)/</pre>
</div>
</div>
<div class="paragraph">
<p>The "matchgroup" argument applies to the start or end match that comes after
it.  In the previous example both start and end are highlighted with xParen.
To highlight the end with xParenEnd:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax region xInside matchgroup=xParen start=/(/
        \ matchgroup=xParenEnd end=/)/</pre>
</div>
</div>
<div class="paragraph">
<p>A side effect of using "matchgroup" is that contained items will not match in
the start or end of the region.  The example for "transparent" uses this.</p>
</div>
</div>
<div class="sect3">
<h4 id="_transparent">TRANSPARENT</h4>
<div class="paragraph">
<p>In a C language file you would like to highlight the () text after a "while"
differently from the () text after a "for".  In both of these there can be
nested () items, which should be highlighted in the same way.  You must make
sure the () highlighting stops at the matching ).  This is one way to do this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax region cWhile matchgroup=cWhile start=/while\s*(/ end=/)/
        \ contains=cCondNest
:syntax region cFor matchgroup=cFor start=/for\s*(/ end=/)/
        \ contains=cCondNest
:syntax region cCondNest start=/(/ end=/)/ contained transparent</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can give cWhile and cFor different highlighting.  The cCondNest item
can appear in either of them, but take over the highlighting of the item it is
contained in.  The "transparent" argument causes this.
   Notice that the "matchgroup" argument has the same group as the item
itself.  Why define it then?  Well, the side effect of using a matchgroup is
that contained items are not found in the match with the start item then.
This avoids that the cCondNest group matches the ( just after the "while" or
"for".  If this would happen, it would span the whole text until the matching
) and the region would continue after it.  Now cCondNest only matches after
the match with the start pattern, thus after the first (.</p>
</div>
</div>
<div class="sect3">
<h4 id="_offsets_2">OFFSETS</h4>
<div class="paragraph">
<p>Suppose you want to define a region for the text between ( and ) after an
"if".  But you don&#8217;t want to include the "if" or the ( and ).  You can do this
by specifying offsets for the patterns.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax region xCond start=/if\s*(/ms=e+1 end=/)/me=s-1</pre>
</div>
</div>
<div class="paragraph">
<p>The offset for the start pattern is "ms=e+1".  "ms" stands for Match Start.
This defines an offset for the start of the match.  Normally the match starts
where the pattern matches.  "e+1" means that the match now starts at the end
of the pattern match, and then one character further.
   The offset for the end pattern is "me=s-1".  "me" stands for Match End.
"s-1" means the start of the pattern match and then one character back.  The
result is that in this text:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if (foo == bar)</pre>
</div>
</div>
<div class="paragraph">
<p>Only the text "foo == bar" will be highlighted as xCond.</p>
</div>
<div class="paragraph">
<p>More about offsets here: |:syn-pattern-offset|.</p>
</div>
</div>
<div class="sect3">
<h4 id="_oneline">ONELINE</h4>
<div class="paragraph">
<p>The "oneline" argument indicates that the region does not cross a line
boundary.  For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax region xIfThen start=/if/ end=/then/ oneline</pre>
</div>
</div>
<div class="paragraph">
<p>This defines a region that starts at "if" and ends at "then".  But if there is
no "then" after the "if", the region doesn&#8217;t match.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
When using "oneline" the region doesn't start if the end pattern
doesn't match in the same line.  Without "oneline" Vim does _not_
check if there is a match for the end pattern.  The region starts even
when the end pattern doesn't match in the rest of the file.</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_continuation_lines_and_avoiding_them">CONTINUATION LINES AND AVOIDING THEM</h4>
<div class="paragraph">
<p>Things now become a little more complex.  Let&#8217;s define a preprocessor line.
This starts with a # in the first column and continues until the end of the
line.  A line that ends with \ makes the next line a continuation line.  The
way you handle this is to allow the syntax item to contain a continuation
pattern:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax region xPreProc start=/^#/ end=/$/ contains=xLineContinue
:syntax match xLineContinue "\\$" contained</pre>
</div>
</div>
<div class="paragraph">
<p>In this case, although xPreProc normally matches a single line, the group
contained in it (namely xLineContinue) lets it go on for more than one line.
For example, it would match both of these lines:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#define SPAM  spam spam spam \
                bacon and spam</pre>
</div>
</div>
<div class="paragraph">
<p>In this case, this is what you want.  If it is not what you want, you can call
for the region to be on a single line by adding "excludenl" to the contained
pattern.  For example, you want to highlight "end" in xPreProc, but only at
the end of the line.  To avoid making the xPreProc continue on the next line,
like xLineContinue does, use "excludenl" like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax region xPreProc start=/^#/ end=/$/
        \ contains=xLineContinue,xPreProcEnd
:syntax match xPreProcEnd excludenl /end$/ contained
:syntax match xLineContinue "\\$" contained</pre>
</div>
</div>
<div class="paragraph">
<p>"excludenl" must be placed before the pattern.  Since "xLineContinue" doesn&#8217;t
have "excludenl", a match with it will extend xPreProc to the next line as
before.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_clusters">Clusters</h3>
<div class="paragraph">
<p>One of the things you will notice as you start to write a syntax file is that
you wind up generating a lot of syntax groups.  Vim enables you to define a
collection of syntax groups called a cluster.
   Suppose you have a language that contains for loops, if statements, while
loops, and functions.  Each of them contains the same syntax elements: numbers
and identifiers.  You define them like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax match xFor /^for.*/ contains=xNumber,xIdent
:syntax match xIf /^if.*/ contains=xNumber,xIdent
:syntax match xWhile /^while.*/ contains=xNumber,xIdent</pre>
</div>
</div>
<div class="paragraph">
<p>You have to repeat the same "contains=" every time.  If you want to add
another contained item, you have to add it three times.  Syntax clusters
simplify these definitions by enabling you to have one cluster stand for
several syntax groups.
   To define a cluster for the two items that the three groups contain, use
the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax cluster xState contains=xNumber,xIdent</pre>
</div>
</div>
<div class="paragraph">
<p>Clusters are used inside other syntax items just like any syntax group.
Their names start with @.  Thus, you can define the three groups like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax match xFor /^for.*/ contains=@xState
:syntax match xIf /^if.*/ contains=@xState
:syntax match xWhile /^while.*/ contains=@xState</pre>
</div>
</div>
<div class="paragraph">
<p>You can add new group names to this cluster with the "add" argument:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax cluster xState add=xString</pre>
</div>
</div>
<div class="paragraph">
<p>You can remove syntax groups from this list as well:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax cluster xState remove=xNumber</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_including_another_syntax_file">Including another syntax file</h3>
<div class="paragraph">
<p>The C language syntax is a superset of the C language.  Because you do not
want to write two syntax files, you can have the C syntax file read in the
one for C by using the following command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:runtime! syntax/c.vim</pre>
</div>
</div>
<div class="paragraph">
<p>The ":runtime!" command searches 'runtimepath' for all "syntax/c.vim" files.
This makes the C parts of the C syntax be defined like for C files.  If you
have replaced the c.vim syntax file, or added items with an extra file, these
will be loaded as well.
   After loading the C syntax items the specific C items can be defined.
For example, add keywords that are not used in C:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax keyword cppStatement    new delete this friend using</pre>
</div>
</div>
<div class="paragraph">
<p>This works just like in any other syntax file.</p>
</div>
<div class="paragraph">
<p>Now consider the Perl language.  A Perl script consists of two distinct parts:
a documentation section in POD format, and a program written in Perl itself.
The POD section starts with "=head" and ends with "=cut".
   You want to define the POD syntax in one file, and use it from the Perl
syntax file.  The ":syntax include" command reads in a syntax file and stores
the elements it defined in a syntax cluster.  For Perl, the statements are as
follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax include @Pod &lt;sfile&gt;:p:h/pod.vim
:syntax region perlPOD start=/^=head/ end=/^=cut/ contains=@Pod</pre>
</div>
</div>
<div class="paragraph">
<p>When "=head" is found in a Perl file, the perlPOD region starts.  In this
region the @Pod cluster is contained.  All the items defined as top-level
items in the pod.vim syntax files will match here.  When "=cut" is found, the
region ends and we go back to the items defined in the Perl file.
   The ":syntax include" command is clever enough to ignore a ":syntax clear"
command in the included file.  And an argument such as "contains=ALL" will
only contain items defined in the included file, not in the file that includes
it.
   The "&lt;sfile&gt;:p:h/" part uses the name of the current file (&lt;sfile&gt;),
expands it to a full path (:p) and then takes the head (:h).  This results in
the directory name of the file.  This causes the pod.vim file in the same
directory to be included.</p>
</div>
</div>
<div class="sect2">
<h3 id="_synchronizing">Synchronizing</h3>
<div class="paragraph">
<p>Compilers have it easy.  They start at the beginning of a file and parse it
straight through.  Vim does not have it so easy.  It must start in the middle,
where the editing is being done.  So how does it tell where it is?
   The secret is the ":syntax sync" command.  This tells Vim how to figure out
where it is.  For example, the following command tells Vim to scan backward
for the beginning or end of a C-style comment and begin syntax coloring from
there:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax sync ccomment</pre>
</div>
</div>
<div class="paragraph">
<p>You can tune this processing with some arguments.  The "minlines" argument
tells Vim the minimum number of lines to look backward, and "maxlines" tells
the editor the maximum number of lines to scan.
   For example, the following command tells Vim to look at least 10 lines
before the top of the screen:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax sync ccomment minlines=10 maxlines=500</pre>
</div>
</div>
<div class="paragraph">
<p>If it cannot figure out where it is in that space, it starts looking farther
and farther back until it figures out what to do.  But it looks no farther
back than 500 lines.  (A large "maxlines" slows down processing.  A small one
might cause synchronization to fail.)
   To make synchronizing go a bit faster, tell Vim which syntax items can be
skipped.  Every match and region that only needs to be used when actually
displaying text can be given the "display" argument.
   By default, the comment to be found will be colored as part of the Comment
syntax group.  If you want to color things another way, you can specify a
different syntax group:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax sync ccomment xAltComment</pre>
</div>
</div>
<div class="paragraph">
<p>If your programming language does not have C-style comments in it, you can try
another method of synchronization.  The simplest way is to tell Vim to space
back a number of lines and try to figure out things from there.  The following
command tells Vim to go back 150 lines and start parsing from there:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax sync minlines=150</pre>
</div>
</div>
<div class="paragraph">
<p>A large "minlines" value can make Vim slower, especially when scrolling
backwards in the file.
   Finally, you can specify a syntax group to look for by using this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax sync match {sync-group-name}
        \ grouphere {group-name} {pattern}</pre>
</div>
</div>
<div class="paragraph">
<p>This tells Vim that when it sees {pattern} the syntax group named {group-name}
begins just after the pattern given.  The {sync-group-name} is used to give a
name to this synchronization specification.  For example, the sh scripting
language begins an if statement with "if" and ends it with "fi":</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if [ --f file.txt ] ; then
        echo "File exists"
fi</pre>
</div>
</div>
<div class="paragraph">
<p>To define a "grouphere" directive for this syntax, you use the following
command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax sync match shIfSync grouphere shIf "\&lt;if\&gt;"</pre>
</div>
</div>
<div class="paragraph">
<p>The "groupthere" argument tells Vim that the pattern ends a group.  For
example, the end of the if/fi group is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax sync match shIfSync groupthere NONE "\&lt;fi\&gt;"</pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the NONE tells Vim that you are not in any special syntax
region.  In particular, you are not inside an if block.</p>
</div>
<div class="paragraph">
<p>You also can define matches and regions that are with no "grouphere" or
"groupthere" arguments.  These groups are for syntax groups skipped during
synchronization.  For example, the following skips over anything inside {},
even if it would normally match another synchronization method:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax sync match xSpecial /{.*}/</pre>
</div>
</div>
<div class="paragraph">
<p>More about synchronizing in the reference manual: |:syn-sync|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_installing_a_syntax_file">Installing a syntax file</h3>
<div class="paragraph">
<p>When your new syntax file is ready to be used, drop it in a "syntax" directory
in 'runtimepath'.  For Unix that would be "~/.vim/syntax".
  The name of the syntax file must be equal to the file type, with ".vim"
added.  Thus for the x language, the full path of the file would be:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>~/.vim/syntax/x.vim</pre>
</div>
</div>
<div class="paragraph">
<p>You must also make the file type be recognized.  See |43.2|.</p>
</div>
<div class="paragraph">
<p>If your file works well, you might want to make it available to other Vim
users.  First read the next section to make sure your file works well for
others.  Then e-mail it to the Vim maintainer: &lt;<a href="mailto:maintainer@vim.org">maintainer@vim.org</a>&gt;.  Also
explain how the filetype can be detected.  With a bit of luck your file will
be included in the next Vim version!</p>
</div>
<div class="sect3">
<h4 id="_adding_to_an_existing_syntax_file">ADDING TO AN EXISTING SYNTAX FILE</h4>
<div class="paragraph">
<p>We were assuming you were adding a completely new syntax file.  When an existing
syntax file works, but is missing some items, you can add items in a separate
file.  That avoids changing the distributed syntax file, which will be lost
when installing a new version of Vim.
   Write syntax commands in your file, possibly using group names from the
existing syntax.  For example, to add new variable types to the C syntax file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:syntax keyword cType off_t uint</pre>
</div>
</div>
<div class="paragraph">
<p>Write the file with the same name as the original syntax file.  In this case
"c.vim".  Place it in a directory near the end of 'runtimepath'.  This makes
it loaded after the original syntax file.  For Unix this would be:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>~/.vim/after/syntax/c.vim</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_portable_syntax_file_layout">Portable syntax file layout</h3>
<div class="paragraph">
<p>Wouldn&#8217;t it be nice if all Vim users exchange syntax files?  To make this
possible, the syntax file must follow a few guidelines.</p>
</div>
<div class="paragraph">
<p>Start with a header that explains what the syntax file is for, who maintains
it and when it was last updated.  Don&#8217;t include too much information about
changes history, not many people will read it.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>" Vim syntax file
" Language:     C
" Maintainer:   Bram Moolenaar &lt;Bram@vim.org&gt;
" Last Change:  2001 Jun 18
" Remark:       Included by the C++ syntax.</pre>
</div>
</div>
<div class="paragraph">
<p>Use the same layout as the other syntax files.  Using an existing syntax file
as an example will save you a lot of time.</p>
</div>
<div class="paragraph">
<p>Choose a good, descriptive name for your syntax file.  Use lowercase letters
and digits.  Don&#8217;t make it too long, it is used in many places: The name of
the syntax file "name.vim", 'filetype', b:current_syntax and the start of each
syntax group (nameType, nameStatement, nameString, etc).</p>
</div>
<div class="paragraph">
<p>Start with a check for "b:current_syntax".  If it is defined, some other
syntax file, earlier in 'runtimepath' was already loaded:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if exists("b:current_syntax")
  finish
endif</pre>
</div>
</div>
<div class="paragraph">
<p>Set "b:current_syntax" to the name of the syntax at the end.  Don&#8217;t forget
that included files do this too, you might have to reset "b:current_syntax" if
you include two files.</p>
</div>
<div class="paragraph">
<p>Do not include anything that is a user preference.  Don&#8217;t set 'tabstop',
'expandtab', etc.  These belong in a filetype plugin.</p>
</div>
<div class="paragraph">
<p>Do not include mappings or abbreviations.  Only include setting 'iskeyword' if
it is really necessary for recognizing keywords.</p>
</div>
<div class="paragraph">
<p>To allow users select their own preferred colors, make a different group name
for every kind of highlighted item.  Then link each of them to one of the
standard highlight groups.  That will make it work with every color scheme.
If you select specific colors it will look bad with some color schemes.  And
don&#8217;t forget that some people use a different background color, or have only
eight colors available.</p>
</div>
<div class="paragraph">
<p>For the linking use "hi def link", so that the user can select different
highlighting before your syntax file is loaded.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>hi def link nameString        String
hi def link nameNumber        Number
hi def link nameCommand       Statement
... etc ...</pre>
</div>
</div>
<div class="paragraph">
<p>Add the "display" argument to items that are not used when syncing, to speed
up scrolling backwards and CTRL-L.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_45.txt|  Select your language</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_select_your_language">Select your language</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The messages in Vim can be given in several languages.  This chapter explains
how to change which one is used.  Also, the different ways to work with files
in various languages is explained.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Language for Messages</p>
</li>
<li>
<p>Language for Menus</p>
</li>
<li>
<p>Using another encoding</p>
</li>
<li>
<p>Editing files with a different encoding</p>
</li>
<li>
<p>Entering language text</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_language_for_messages">Language for Messages</h3>
<div class="paragraph">
<p>When you start Vim, it checks the environment to find out what language you
are using.  Mostly this should work fine, and you get the messages in your
language (if they are available).  To see what the current language is, use
this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:language</pre>
</div>
</div>
<div class="paragraph">
<p>If it replies with "C", this means the default is being used, which is
English.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
Using different languages only works when Vim was compiled to handle
it.  To find out if it works, use the ":version" command and check the
output for "+gettext" and "+multi_lang".  If they are there, you are
OK.  If you see "-gettext" or "-multi_lang" you will have to find
another Vim.</pre>
</div>
</div>
<div class="paragraph">
<p>What if you would like your messages in a different language?  There are
several ways.  Which one you should use depends on the capabilities of your
system.
   The first way is to set the environment to the desired language before
starting Vim.  Example for Unix:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>env LANG=de_DE.ISO_8859-1  vim</pre>
</div>
</div>
<div class="paragraph">
<p>This only works if the language is available on your system.  The advantage is
that all the GUI messages and things in libraries will use the right language
as well.  A disadvantage is that you must do this before starting Vim.  If you
want to change language while Vim is running, you can use the second method:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:language fr_FR.ISO_8859-1</pre>
</div>
</div>
<div class="paragraph">
<p>This way you can try out several names for your language.  You will get an
error message when it&#8217;s not supported on your system.  You don&#8217;t get an error
when translated messages are not available.  Vim will silently fall back to
using English.
   To find out which languages are supported on your system, find the
directory where they are listed.  On my system it is "/usr/share/locale".  On
some systems it&#8217;s in "/usr/lib/locale".  The manual page for "setlocale"
should give you a hint where it is found on your system.
   Be careful to type the name exactly as it should be.  Upper and lowercase
matter, and the '-' and '_' characters are easily confused.</p>
</div>
<div class="paragraph">
<p>You can also set the language separately for messages, edited text and the
time format.  See |:language|.</p>
</div>
<div class="paragraph">
<p>DO-IT-YOURSELF MESSAGE TRANSLATION</p>
</div>
<div class="paragraph">
<p>If translated messages are not available for your language, you could write
them yourself.  To do this, get the source code for Vim and the GNU gettext
package.  After unpacking the sources, instructions can be found in the
directory src/po/README.txt.
   It&#8217;s not too difficult to do the translation.  You don&#8217;t need to be a
programmer.  You must know both English and the language you are translating
to, of course.
   When you are satisfied with the translation, consider making it available
to others.  Upload it at vim-online (<a href="http://vim.sf.net" class="bare">http://vim.sf.net</a>) or e-mail it to
the Vim maintainer &lt;<a href="mailto:maintainer@vim.org">maintainer@vim.org</a>&gt;.  Or both.</p>
</div>
</div>
<div class="sect2">
<h3 id="_language_for_menus">Language for Menus</h3>
<div class="paragraph">
<p>The default menus are in English.  To be able to use your local language, they
must be translated.  Normally this is automatically done for you if the
environment is set for your language, just like with messages.  You don&#8217;t need
to do anything extra for this.  But it only works if translations for the
language are available.
   Suppose you are in Germany, with the language set to German, but prefer to
use "File" instead of "Datei".  You can switch back to using the English menus
this way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set langmenu=none</pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to specify a language:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set langmenu=nl_NL.ISO_8859-1</pre>
</div>
</div>
<div class="paragraph">
<p>Like above, differences between "-" and "_" matter.  However, upper/lowercase
differences are ignored here.
   The 'langmenu' option must be set before the menus are loaded.  Once the
menus have been defined changing 'langmenu' has no direct effect.  Therefore,
put the command to set 'langmenu' in your vimrc file.
   If you really want to switch menu language while running Vim, you can do it
this way:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:source $VIMRUNTIME/delmenu.vim
:set langmenu=de_DE.ISO_8859-1
:source $VIMRUNTIME/menu.vim</pre>
</div>
</div>
<div class="paragraph">
<p>There is one drawback: All menus that you defined yourself will be gone.  You
will need to redefine them as well.</p>
</div>
<div class="paragraph">
<p>DO-IT-YOURSELF MENU TRANSLATION</p>
</div>
<div class="paragraph">
<p>To see which menu translations are available, look in this directory:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$VIMRUNTIME/lang</pre>
</div>
</div>
<div class="paragraph">
<p>The files are called menu_{language}.vim.  If you don&#8217;t see the language you
want to use, you can do your own translations.  The simplest way to do this is
by copying one of the existing language files, and change it.
   First find out the name of your language with the ":language" command.  Use
this name, but with all letters made lowercase.  Then copy the file to your
own runtime directory, as found early in 'runtimepath'.  For example, for Unix
you would do:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:!cp $VIMRUNTIME/lang/menu_ko_kr.euckr.vim ~/.vim/lang/menu_nl_be.iso_8859-1.vim</pre>
</div>
</div>
<div class="paragraph">
<p>You will find hints for the translation in "$VIMRUNTIME/lang/README.txt".</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_another_encoding">Using another encoding</h3>
<div class="paragraph">
<p>Vim guesses that the files you are going to edit are encoded for your
language.  For many European languages this is "latin1".  Then each byte is
one character.  That means there are 256 different characters possible.  For
Asian languages this is not sufficient.  These mostly use a double-byte
encoding, providing for over ten thousand possible characters.  This still
isn&#8217;t enough when a text is to contain several different languages.  This is
where Unicode comes in.  It was designed to include all characters used in
commonly used languages.  This is the "Super encoding that replaces all
others".  But it isn&#8217;t used that much yet.
   Fortunately, Vim supports these three kinds of encodings.  And, with some
restrictions, you can use them even when your environment uses another
language than the text.
   Nevertheless, when you only edit files that are in the encoding of your
language, the default should work fine and you don&#8217;t need to do anything.  The
following is only relevant when you want to edit different languages.</p>
</div>
<div class="sect3">
<h4 id="_using_unicode_in_the_gui">USING UNICODE IN THE GUI</h4>
<div class="paragraph">
<p>The nice thing about Unicode is that other encodings can be converted to it
and back without losing information.  When you make Vim use Unicode
internally, you will be able to edit files in any encoding.
   Unfortunately, the number of systems supporting Unicode is still limited.
Thus it&#8217;s unlikely that your language uses it.  You need to tell Vim you want
to use Unicode, and how to handle interfacing with the rest of the system.
   Let&#8217;s start with the GUI version of Vim, which is able to display Unicode
characters.  This should work:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set encoding=utf-8
:set guifont=-misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1</pre>
</div>
</div>
<div class="paragraph">
<p>The 'encoding' option tells Vim the encoding of the characters that you use.
This applies to the text in buffers (files you are editing), registers, Vim
script files, etc.  You can regard 'encoding' as the setting for the internals
of Vim.
   This example assumes you have this font on your system.  The name in the
example is for the X Window System.  This font is in a package that is used to
enhance xterm with Unicode support.  If you don&#8217;t have this font, you might
find it here:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http://www.cl.cam.ac.uk/~mgk25/download/ucs-fonts.tar.gz</pre>
</div>
</div>
<div class="paragraph">
<p>For MS-Windows, some fonts have a limited number of Unicode characters.  Try
using the "Courier New" font.  You can use the Edit/Select Font&#8230;&#8203; menu to
select and try out the fonts available.  Only fixed-width fonts can be used
though.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set guifont=courier_new:h12</pre>
</div>
</div>
<div class="paragraph">
<p>If it doesn&#8217;t work well, try getting a fontpack.  If Microsoft didn&#8217;t move it,
you can find it here:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http://www.microsoft.com/typography/fonts/default.aspx</pre>
</div>
</div>
<div class="paragraph">
<p>Now you have told Vim to use Unicode internally and display text with a
Unicode font.  Typed characters still arrive in the encoding of your original
language.  This requires converting them to Unicode.  Tell Vim the language
from which to convert with the 'termencoding' option.  You can do it like
this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let &amp;termencoding = &amp;encoding
:set encoding=utf-8</pre>
</div>
</div>
<div class="paragraph">
<p>This assigns the old value of 'encoding' to 'termencoding' before setting
'encoding' to utf-8.  You will have to try out if this really works for your
setup.  It should work especially well when using an input method for an Asian
language, and you want to edit Unicode text.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_unicode_in_a_unicode_terminal">USING UNICODE IN A UNICODE TERMINAL</h4>
<div class="paragraph">
<p>There are terminals that support Unicode directly.  The standard xterm that
comes with XFree86 is one of them.  Let&#8217;s use that as an example.
   First of all, the xterm must have been compiled with Unicode support.  See
|UTF8-xterm| how to check that and how to compile it when needed.
   Start the xterm with the "-u8" argument.  You might also need so specify a
font.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>xterm -u8 -fn -misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1</pre>
</div>
</div>
<div class="paragraph">
<p>Now you can run Vim inside this terminal.  Set 'encoding' to "utf-8" as
before.  That&#8217;s all.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_unicode_in_an_ordinary_terminal">USING UNICODE IN AN ORDINARY TERMINAL</h4>
<div class="paragraph">
<p>Suppose you want to work with Unicode files, but don&#8217;t have a terminal with
Unicode support.  You can do this with Vim, although characters that are not
supported by the terminal will not be displayed.  The layout of the text
will be preserved.  &gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let &amp;termencoding = &amp;encoding
:set encoding=utf-8</pre>
</div>
</div>
<div class="paragraph">
<p>This is the same as what was used for the GUI.  But it works differently: Vim
will convert the displayed text before sending it to the terminal.  That
avoids that the display is messed up with strange characters.
   For this to work the conversion between 'termencoding' and 'encoding' must
be possible.  Vim will convert from latin1 to Unicode, thus that always works.
For other conversions the |+iconv| feature is required.
   Try editing a file with Unicode characters in it.  You will notice that Vim
will put a question mark (or underscore or some other character) in places
where a character should be that the terminal can&#8217;t display.  Move the cursor
to a question mark and use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ga</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will display a line with the code of the character.  This gives you a hint
about what character it is.  You can look it up in a Unicode table.  You could
actually view a file that way, if you have lots of time at hand.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
Since 'encoding' is used for all text inside Vim, changing it makes
all non-ASCII text invalid.  You will notice this when using registers
and the 'viminfo' file (e.g., a remembered search pattern).  It's
recommended to set 'encoding' in your vimrc file, and leave it alone.</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_editing_files_with_a_different_encoding">Editing files with a different encoding</h3>
<div class="paragraph">
<p>Suppose you have setup Vim to use Unicode, and you want to edit a file that is
in 16-bit Unicode.  Sounds simple, right?  Well, Vim actually uses utf-8
encoding internally, thus the 16-bit encoding must be converted, since there
is a difference between the character set (Unicode) and the encoding (utf-8 or
16-bit).
   Vim will try to detect what kind of file you are editing.  It uses the
encoding names in the 'fileencodings' option.  When using Unicode, the default
value is: "ucs-bom,utf-8,latin1".  This means that Vim checks the file to see
if it&#8217;s one of these encodings:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ucs-bom         File must start with a Byte Order Mark (BOM).  This
                allows detection of 16-bit, 32-bit and utf-8 Unicode
                encodings.
utf-8           utf-8 Unicode.  This is rejected when a sequence of
                bytes is illegal in utf-8.
latin1          The good old 8-bit encoding.  Always works.</pre>
</div>
</div>
<div class="paragraph">
<p>When you start editing that 16-bit Unicode file, and it has a BOM, Vim will
detect this and convert the file to utf-8 when reading it.  The 'fileencoding'
option (without s at the end) is set to the detected value.  In this case it
is "utf-16le".  That means it&#8217;s Unicode, 16-bit and little-endian.  This
file format is common on MS-Windows (e.g., for registry files).
   When writing the file, Vim will compare 'fileencoding' with 'encoding'.  If
they are different, the text will be converted.
   An empty value for 'fileencoding' means that no conversion is to be done.
Thus the text is assumed to be encoded with 'encoding'.</p>
</div>
<div class="paragraph">
<p>If the default 'fileencodings' value is not good for you, set it to the
encodings you want Vim to try.  Only when a value is found to be invalid will
the next one be used.  Putting "latin1" first doesn&#8217;t work, because it is
never illegal.  An example, to fall back to Japanese when the file doesn&#8217;t
have a BOM and isn&#8217;t utf-8:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set fileencodings=ucs-bom,utf-8,sjis</pre>
</div>
</div>
<div class="paragraph">
<p>See |encoding-values| for suggested values.  Other values may work as well.
This depends on the conversion available.</p>
</div>
<div class="sect3">
<h4 id="_forcing_an_encoding">FORCING AN ENCODING</h4>
<div class="paragraph">
<p>If the automatic detection doesn&#8217;t work you must tell Vim what encoding the
file is.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:edit ++enc=koi8-r russian.txt</pre>
</div>
</div>
<div class="paragraph">
<p>The "++enc" part specifies the name of the encoding to be used for this file
only.  Vim will convert the file from the specified encoding, Russian in this
example, to 'encoding'.  'fileencoding' will also be set to the specified
encoding, so that the reverse conversion can be done when writing the file.
   The same argument can be used when writing the file.  This way you can
actually use Vim to convert a file.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:write ++enc=utf-8 russian.txt</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Note:
Conversion may result in lost characters.  Conversion from an encoding
to Unicode and back is mostly free of this problem, unless there are
illegal characters.  Conversion from Unicode to other encodings often
loses information when there was more than one language in the file.</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_entering_language_text">Entering language text</h3>
<div class="paragraph">
<p>Computer keyboards don&#8217;t have much more than a hundred keys.  Some languages
have thousands of characters, Unicode has over hundred thousand.  So how do
you type these characters?
   First of all, when you don&#8217;t use too many of the special characters, you
can use digraphs.  This was already explained in |24.9|.
   When you use a language that uses many more characters than keys on your
keyboard, you will want to use an Input Method (IM).  This requires learning
the translation from typed keys to resulting character.  When you need an IM
you probably already have one on your system.  It should work with Vim like
with other programs.  For details see |mbyte-XIM| for the X Window system and
|mbyte-IME| for MS-Windows.</p>
</div>
<div class="sect3">
<h4 id="_keymaps">KEYMAPS</h4>
<div class="paragraph">
<p>For some languages the character set is different from latin, but uses a
similar number of characters.  It&#8217;s possible to map keys to characters.  Vim
uses keymaps for this.
   Suppose you want to type Hebrew.  You can load the keymap like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set keymap=hebrew</pre>
</div>
</div>
<div class="paragraph">
<p>Vim will try to find a keymap file for you.  This depends on the value of
'encoding'.  If no matching file was found, you will get an error message.</p>
</div>
<div class="paragraph">
<p>Now you can type Hebrew in Insert mode.  In Normal mode, and when typing a ":"
command, Vim automatically switches to English.  You can use this command to
switch between Hebrew and English:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CTRL-^</pre>
</div>
</div>
<div class="paragraph">
<p>This only works in Insert mode and Command-line mode.  In Normal mode it does
something completely different (jumps to alternate file).
   The usage of the keymap is indicated in the mode message, if you have the
'showmode' option set.  In the GUI Vim will indicate the usage of keymaps with
a different cursor color.
   You can also change the usage of the keymap with the 'iminsert' and
'imsearch' options.</p>
</div>
<div class="paragraph">
<p>To see the list of mappings, use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:lmap</pre>
</div>
</div>
<div class="paragraph">
<p>To find out which keymap files are available, in the GUI you can use the
Edit/Keymap menu.  Otherwise you can use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:echo globpath(&amp;rtp, "keymap/*.vim")</pre>
</div>
</div>
<div class="paragraph">
<p>DO-IT-YOURSELF KEYMAPS</p>
</div>
<div class="paragraph">
<p>You can create your own keymap file.  It&#8217;s not very difficult.  Start with
a keymap file that is similar to the language you want to use.  Copy it to the
"keymap" directory in your runtime directory.  For example, for Unix, you
would use the directory "~/.vim/keymap".
   The name of the keymap file must look like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        keymap/{name}.vim
or
        keymap/{name}_{encoding}.vim</pre>
</div>
</div>
<div class="paragraph">
<p>{name} is the name of the keymap.  Chose a name that is obvious, but different
from existing keymaps (unless you want to replace an existing keymap file).
{name} cannot contain an underscore.  Optionally, add the encoding used after
an underscore.  Examples:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>keymap/hebrew.vim
keymap/hebrew_utf-8.vim</pre>
</div>
</div>
<div class="paragraph">
<p>The contents of the file should be self-explanatory.  Look at a few of the
keymaps that are distributed with Vim.  For the details, see |mbyte-keymap|.</p>
</div>
</div>
<div class="sect3">
<h4 id="_last_resort">LAST RESORT</h4>
<div class="paragraph">
<p>If all other methods fail, you can enter any character with CTRL-V:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>encoding   type                 range
8-bit      CTRL-V 123           decimal 0-255
8-bit      CTRL-V x a1          hexadecimal 00-ff
16-bit     CTRL-V u 013b        hexadecimal 0000-ffff
31-bit     CTRL-V U 001303a4    hexadecimal 00000000-7fffffff</pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t type the spaces.  See |i_CTRL-V_digit| for the details.</p>
</div>
<div class="paragraph">
<p>Next chapter: |usr_90.txt|  Installing Vim</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_installing_vim">Installing Vim</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before you can use Vim you have to install it.  Depending on your system it&#8217;s
simple or easy.  This chapter gives a few hints and also explains how
upgrading to a new version is done.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Unix</p>
</li>
<li>
<p>MS-Windows</p>
</li>
<li>
<p>Upgrading</p>
</li>
<li>
<p>Common installation issues</p>
</li>
<li>
<p>Uninstalling Vim</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_unix">Unix</h3>
<div class="paragraph">
<p>First you have to decide if you are going to install Vim system-wide or for a
single user.  The installation is almost the same, but the directory where Vim
is installed in differs.
   For a system-wide installation the base directory "/usr/local" is often
used.  But this may be different for your system.  Try finding out where other
packages are installed.
   When installing for a single user, you can use your home directory as the
base.  The files will be placed in subdirectories like "bin" and "shared/vim".</p>
</div>
<div class="sect3">
<h4 id="_from_a_package">FROM A PACKAGE</h4>
<div class="paragraph">
<p>You can get precompiled binaries for many different UNIX systems.  There is a
long list with links on this page:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http://www.vim.org/binaries.html</pre>
</div>
</div>
<div class="paragraph">
<p>Volunteers maintain the binaries, so they are often out of date.  It is a
good idea to compile your own UNIX version from the source.  Also, creating
the editor from the source allows you to control which features are compiled.
This does require a compiler though.</p>
</div>
<div class="paragraph">
<p>If you have a Linux distribution, the "vi" program is probably a minimal
version of Vim.  It doesn&#8217;t do syntax highlighting, for example.  Try finding
another Vim package in your distribution, or search on the web site.</p>
</div>
</div>
<div class="sect3">
<h4 id="_from_sources">FROM SOURCES</h4>
<div class="paragraph">
<p>To compile and install Vim, you will need the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A C compiler (GCC preferred)</p>
</li>
<li>
<p>The GZIP program (you can get it from www.gnu.org)</p>
</li>
<li>
<p>The Vim source and runtime archives</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To get the Vim archives, look in this file for a mirror near you, this should
provide the fastest download:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ftp://ftp.vim.org/pub/vim/MIRRORS</pre>
</div>
</div>
<div class="paragraph">
<p>Or use the home site ftp.vim.org, if you think it&#8217;s fast enough.  Go to the
"unix" directory and you&#8217;ll find a list of files there.  The version number is
embedded in the file name.  You will want to get the most recent version.
   You can get the files for Unix in one big archive that contains everything:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim-8.2.tar.bz2</pre>
</div>
</div>
<div class="paragraph">
<p>You need the bzip2 program to uncompress it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_compiling_2">COMPILING</h4>
<div class="paragraph">
<p>First create a top directory to work in, for example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mkdir ~/vim
cd ~/vim</pre>
</div>
</div>
<div class="paragraph">
<p>Then unpack the archives there.  You can unpack it like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tar xf path/vim-8.2.tar.bz2</pre>
</div>
</div>
<div class="paragraph">
<p>If your tar command doesn&#8217;t support bz2 directly:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>bzip2 -d -c path/vim-8.2.tar.bz2 | tar xf -</pre>
</div>
</div>
<div class="paragraph">
<p>Change "path" to where you have downloaded the file.
If you are satisfied with getting the default features, and your environment
is setup properly, you should be able to compile Vim with just this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>cd vim82/src
make</pre>
</div>
</div>
<div class="paragraph">
<p>The make program will run configure and compile everything.  Further on we
will explain how to compile with different features.
   If there are errors while compiling, carefully look at the error messages.
There should be a hint about what went wrong.  Hopefully you will be able to
correct it.  You might have to disable some features to make Vim compile.
Look in the Makefile for specific hints for your system.</p>
</div>
</div>
<div class="sect3">
<h4 id="_testing">TESTING</h4>
<div class="paragraph">
<p>Now you can check if compiling worked OK:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>make test</pre>
</div>
</div>
<div class="paragraph">
<p>This will run a sequence of test scripts to verify that Vim works as expected.
Vim will be started many times and all kinds of text and messages flash by.
If it is alright you will finally see:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>        test results:
====         ALL DONE</pre>
</div>
</div>
<div class="paragraph">
<p>If you get "TEST FAILURE" some test failed.  If there are one or two messages
about failed tests, Vim might still work, but not perfectly.  If you see a lot
of error messages or Vim doesn&#8217;t finish until the end, there must be something
wrong.  Either try to find out yourself, or find someone who can solve it.
You could look in the |maillist-archive| for a solution.  If everything else
fails, you could ask in the vim |maillist| if someone can help you.</p>
</div>
</div>
<div class="sect3">
<h4 id="_installing">INSTALLING</h4>
<div class="paragraph">
<p>If you want to install in your home directory, edit the Makefile and search
for a line:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#prefix = $(HOME)</pre>
</div>
</div>
<div class="paragraph">
<p>Remove the # at the start of the line.
   When installing for the whole system, Vim has most likely already selected
a good installation directory for you.  You can also specify one, see below.
You need to become root for the following.</p>
</div>
<div class="paragraph">
<p>To install Vim do:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>make install</pre>
</div>
</div>
<div class="paragraph">
<p>That should move all the relevant files to the right place.  Now you can try
running vim to verify that it works.  Use two simple tests to check if Vim can
find its runtime files:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help
:syntax enable</pre>
</div>
</div>
<div class="paragraph">
<p>If this doesn&#8217;t work, use this command to check where Vim is looking for the
runtime files:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:echo $VIMRUNTIME</pre>
</div>
</div>
<div class="paragraph">
<p>You can also start Vim with the "-V" argument to see what happens during
startup:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim -V</pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t forget that the user manual assumes you Vim in a certain way.  After
installing Vim, follow the instructions at |not-compatible| to make Vim work
as assumed in this manual.</p>
</div>
</div>
<div class="sect3">
<h4 id="_selecting_features">SELECTING FEATURES</h4>
<div class="paragraph">
<p>Vim has many ways to select features.  One of the simple ways is to edit the
Makefile.  There are many directions and examples.  Often you can enable or
disable a feature by uncommenting a line.
   An alternative is to run "configure" separately.  This allows you to
specify configuration options manually.  The disadvantage is that you have to
figure out what exactly to type.
   Some of the most interesting configure arguments follow.  These can also be
enabled from the Makefile.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>--prefix={directory}            Top directory where to install Vim.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>--with-features=tiny            Compile with many features disabled.
--with-features=small           Compile with some features disabled.
--with-features=big             Compile with more features enabled.
--with-features=huge            Compile with most features enabled.
                                See |+feature-list| for which feature
                                is enabled in which case.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>--enable-perlinterp             Enable the Perl interface.  There are
                                similar arguments for ruby, python and
                                tcl.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>--disable-gui                   Do not compile the GUI interface.
--without-x                     Do not compile X-windows features.
                                When both of these are used, Vim will
                                not connect to the X server, which
                                makes startup faster.</pre>
</div>
</div>
<div class="paragraph">
<p>To see the whole list use:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>./configure --help</pre>
</div>
</div>
<div class="paragraph">
<p>You can find a bit of explanation for each feature, and links for more
information here: |feature-list|.
   For the adventurous, edit the file "feature.h".  You can also change the
source code yourself!</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ms_windows">MS-Windows</h3>
<div class="paragraph">
<p>There are two ways to install the Vim program for Microsoft Windows.  You can
uncompress several archives, or use a self-installing big archive.  Most users
with fairly recent computers will prefer the second method.  For the first
one, you will need:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An archive with binaries for Vim.</p>
</li>
<li>
<p>The Vim runtime archive.</p>
</li>
<li>
<p>A program to unpack the zip files.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To get the Vim archives, look in this file for a mirror near you, this should
provide the fastest download:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ftp://ftp.vim.org/pub/vim/MIRRORS</pre>
</div>
</div>
<div class="paragraph">
<p>Or use the home site ftp.vim.org, if you think it&#8217;s fast enough.  Go to the
"pc" directory and you&#8217;ll find a list of files there.  The version number is
embedded in the file name.  You will want to get the most recent version.
We will use "82" here, which is version 8.2.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gvim82.exe              The self-installing archive.</pre>
</div>
</div>
<div class="paragraph">
<p>This is all you need for the second method.  Just launch the executable, and
follow the prompts.</p>
</div>
<div class="paragraph">
<p>For the first method you must chose one of the binary archives.  These are
available:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gvim82.zip              The normal MS-Windows GUI version.
gvim82ole.zip           The MS-Windows GUI version with OLE support.
                        Uses more memory, supports interfacing with
                        other OLE applications.
vim82w32.zip            32 bit MS-Windows console version.</pre>
</div>
</div>
<div class="paragraph">
<p>You only need one of them.  Although you could install both a GUI and a
console version.  You always need to get the archive with runtime files.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>vim82rt.zip             The runtime files.</pre>
</div>
</div>
<div class="paragraph">
<p>Use your un-zip program to unpack the files.  For example, using the "unzip"
program:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>cd c:\
unzip path\gvim82.zip
unzip path\vim82rt.zip</pre>
</div>
</div>
<div class="paragraph">
<p>This will unpack the files in the directory "c:\vim\vim82".  If you already
have a "vim" directory somewhere, you will want to move to the directory just
above it.
   Now change to the "vim\vim82" directory and run the install program:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>install</pre>
</div>
</div>
<div class="paragraph">
<p>Carefully look through the messages and select the options you want to use.
If you finally select "do it" the install program will carry out the actions
you selected.
   The install program doesn&#8217;t move the runtime files.  They remain where you
unpacked them.</p>
</div>
<div class="paragraph">
<p>In case you are not satisfied with the features included in the supplied
binaries, you could try compiling Vim yourself.  Get the source archive from
the same location as where the binaries are.  You need a compiler for which a
makefile exists.  Microsoft Visual C, MinGW and Cygwin compilers can be used.
Check the file src/INSTALLpc.txt for hints.</p>
</div>
</div>
<div class="sect2">
<h3 id="_upgrading">Upgrading</h3>
<div class="paragraph">
<p>If you are running one version of Vim and want to install another, here is
what to do.</p>
</div>
<div class="sect3">
<h4 id="_unix_2">UNIX</h4>
<div class="paragraph">
<p>When you type "make install" the runtime files will be copied to a directory
which is specific for this version.  Thus they will not overwrite a previous
version.  This makes it possible to use two or more versions next to
each other.
   The executable "vim" will overwrite an older version.  If you don&#8217;t care
about keeping the old version, running "make install" will work fine.  You can
delete the old runtime files manually.  Just delete the directory with the
version number in it and all files below it.  Example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>rm -rf /usr/local/share/vim/vim74</pre>
</div>
</div>
<div class="paragraph">
<p>There are normally no changed files below this directory.  If you did change
the "filetype.vim" file, for example, you better merge the changes into the
new version before deleting it.</p>
</div>
<div class="paragraph">
<p>If you are careful and want to try out the new version for a while before
switching to it, install the new version under another name.  You need to
specify a configure argument.  For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>./configure --with-vim-name=vim8</pre>
</div>
</div>
<div class="paragraph">
<p>Before running "make install", you could use "make -n install" to check that
no valuable existing files are overwritten.
   When you finally decide to switch to the new version, all you need to do is
to rename the binary to "vim".  For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mv /usr/local/bin/vim8 /usr/local/bin/vim</pre>
</div>
</div>
<div class="paragraph">
<p>MS-WINDOWS</p>
</div>
<div class="paragraph">
<p>Upgrading is mostly equal to installing a new version.  Just unpack the files
in the same place as the previous version.  A new directory will be created,
e.g., "vim82", for the files of the new version.  Your runtime files, vimrc
file, viminfo, etc. will be left alone.
   If you want to run the new version next to the old one, you will have to do
some handwork.  Don&#8217;t run the install program, it will overwrite a few files
of the old version.  Execute the new binaries by specifying the full path.
The program should be able to automatically find the runtime files for the
right version.  However, this won&#8217;t work if you set the $VIMRUNTIME variable
somewhere.
   If you are satisfied with the upgrade, you can delete the files of the
previous version.  See |90.5|.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_common_installation_issues">Common installation issues</h3>
<div class="paragraph">
<p>This section describes some of the common problems that occur when installing
Vim and suggests some solutions.  It also contains answers to many
installation questions.</p>
</div>
<div class="paragraph">
<p>Q: I Do Not Have Root Privileges.  How Do I Install Vim? (Unix)</p>
</div>
<div class="paragraph">
<p>Use the following configuration command to install Vim in a directory called
$HOME/vim:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>./configure --prefix=$HOME</pre>
</div>
</div>
<div class="paragraph">
<p>This gives you a personal copy of Vim.  You need to put $HOME/bin in your
path to execute the editor.  Also see |install-home|.</p>
</div>
<div class="paragraph">
<p>Q: The Colors Are Not Right on My Screen. (Unix)</p>
</div>
<div class="paragraph">
<p>Check your terminal settings by using the following command in a shell:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>echo $TERM</pre>
</div>
</div>
<div class="paragraph">
<p>If the terminal type listed is not correct, fix it.  For more hints, see
|06.2|.  Another solution is to always use the GUI version of Vim, called
gvim.  This avoids the need for a correct terminal setup.</p>
</div>
<div class="paragraph">
<p>Q: My Backspace And Delete Keys Don&#8217;t Work Right</p>
</div>
<div class="paragraph">
<p>The definition of what key sends what code is very unclear for backspace &lt;BS&gt;
and Delete &lt;Del&gt; keys.  First of all, check your $TERM setting.  If there is
nothing wrong with it, try this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set t_kb=^V&lt;BS&gt;
:set t_kD=^V&lt;Del&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>In the first line you need to press CTRL-V and then hit the backspace key.
In the second line you need to press CTRL-V and then hit the Delete key.
You can put these lines in your vimrc file, see |05.1|.  A disadvantage is
that it won&#8217;t work when you use another terminal some day.  Look here for
alternate solutions: |:fixdel|.</p>
</div>
<div class="paragraph">
<p>Q: I Am Using RedHat Linux.  Can I Use the Vim That Comes with the System?</p>
</div>
<div class="paragraph">
<p>By default RedHat installs a minimal version of Vim.  Check your RPM packages
for something named "Vim-enhanced-version.rpm" and install that.</p>
</div>
<div class="paragraph">
<p>Q: How Do I Turn Syntax Coloring On?  How do I make plugins work?</p>
</div>
<div class="paragraph">
<p>Use the example vimrc script.  You can find an explanation on how to use it
here: |not-compatible|.</p>
</div>
<div class="paragraph">
<p>See chapter 6 for information about syntax highlighting: |usr_06.txt|.</p>
</div>
<div class="paragraph">
<p>Q: What Is a Good vimrc File to Use?</p>
</div>
<div class="paragraph">
<p>See the www.vim.org Web site for several good examples.</p>
</div>
<div class="paragraph">
<p>Q: Where Do I Find a Good Vim Plugin?</p>
</div>
<div class="paragraph">
<p>See the Vim-online site: <a href="http://vim.sf.net" class="bare">http://vim.sf.net</a>.  Many users have uploaded useful
Vim scripts and plugins there.</p>
</div>
<div class="paragraph">
<p>Q: Where Do I Find More Tips?</p>
</div>
<div class="paragraph">
<p>See the Vim-online site: <a href="http://vim.sf.net" class="bare">http://vim.sf.net</a>.  There is an archive with hints
from Vim users.  You might also want to search in the |maillist-archive|.</p>
</div>
</div>
<div class="sect2">
<h3 id="_uninstalling_vim">Uninstalling Vim</h3>
<div class="paragraph">
<p>In the unlikely event you want to uninstall Vim completely, this is how you do
it.</p>
</div>
<div class="sect3">
<h4 id="_unix_3">UNIX</h4>
<div class="paragraph">
<p>When you installed Vim as a package, check your package manager to find out
how to remove the package again.
   If you installed Vim from sources you can use this command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>make uninstall</pre>
</div>
</div>
<div class="paragraph">
<p>However, if you have deleted the original files or you used an archive that
someone supplied, you can&#8217;t do this.  Do delete the files manually, here is an
example for when "/usr/local" was used as the root:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>rm -rf /usr/local/share/vim/vim82
rm /usr/local/bin/eview
rm /usr/local/bin/evim
rm /usr/local/bin/ex
rm /usr/local/bin/gview
rm /usr/local/bin/gvim
rm /usr/local/bin/gvim
rm /usr/local/bin/gvimdiff
rm /usr/local/bin/rgview
rm /usr/local/bin/rgvim
rm /usr/local/bin/rview
rm /usr/local/bin/rvim
rm /usr/local/bin/rvim
rm /usr/local/bin/view
rm /usr/local/bin/vim
rm /usr/local/bin/vimdiff
rm /usr/local/bin/vimtutor
rm /usr/local/bin/xxd
rm /usr/local/man/man1/eview.1
rm /usr/local/man/man1/evim.1
rm /usr/local/man/man1/ex.1
rm /usr/local/man/man1/gview.1
rm /usr/local/man/man1/gvim.1
rm /usr/local/man/man1/gvimdiff.1
rm /usr/local/man/man1/rgview.1
rm /usr/local/man/man1/rgvim.1
rm /usr/local/man/man1/rview.1
rm /usr/local/man/man1/rvim.1
rm /usr/local/man/man1/view.1
rm /usr/local/man/man1/vim.1
rm /usr/local/man/man1/vimdiff.1
rm /usr/local/man/man1/vimtutor.1
rm /usr/local/man/man1/xxd.1</pre>
</div>
</div>
<div class="paragraph">
<p>MS-WINDOWS</p>
</div>
<div class="paragraph">
<p>If you installed Vim with the self-installing archive you can run
the "uninstall-gui" program located in the same directory as the other Vim
programs, e.g. "c:\vim\vim82".  You can also launch it from the Start menu if
installed the Vim entries there.  This will remove most of the files, menu
entries and desktop shortcuts.  Some files may remain however, as they need a
Windows restart before being deleted.
   You will be given the option to remove the whole "vim" directory.  It
probably contains your vimrc file and other runtime files that you created, so
be careful.</p>
</div>
<div class="paragraph">
<p>Else, if you installed Vim with the zip archives, the preferred way is to use
the "uninstall" program.  You can find it in the same directory as the
"install" program, e.g., "c:\vim\vim82".  This should also work from the usual
"install/remove software" page.
   However, this only removes the registry entries for Vim.  You have to
delete the files yourself.  Simply select the directory "vim\vim82" and delete
it recursively.  There should be no files there that you changed, but you
might want to check that first.
   The "vim" directory probably contains your vimrc file and other runtime
files that you created.  You might want to keep that.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-05-10 04:16:26 +0430
</div>
</div>
</body>
</html>